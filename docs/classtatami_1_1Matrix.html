<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami::Matrix&lt; Value_, Index_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami.html">tatami</a></li><li class="navelem"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtatami_1_1Matrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami::Matrix&lt; Value_, Index_ &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Virtual class for a matrix.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Matrix_8hpp_source.html">Matrix.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tatami::Matrix&lt; Value_, Index_ &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtatami_1_1Matrix__inherit__graph.png" border="0" usemap="#atatami_1_1Matrix_3_01Value___00_01Index___01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atatami_1_1Matrix_3_01Value___00_01Index___01_4_inherit__map" id="atatami_1_1Matrix_3_01Value___00_01Index___01_4_inherit__map">
<area shape="rect" title="Virtual class for a matrix." alt="" coords="5,596,148,636"/>
<area shape="rect" href="classtatami_1_1CompressedSparseMatrix.html" title=" " alt="" coords="215,5,405,91"/>
<area shape="poly" title=" " alt="" coords="79,580,94,473,118,331,152,194,172,140,194,101,212,83,216,87,198,104,176,142,157,196,124,332,99,473,85,581"/>
<area shape="rect" href="classtatami_1_1DenseMatrix.html" title=" " alt="" coords="239,115,381,171"/>
<area shape="poly" title=" " alt="" coords="74,580,78,500,94,393,109,337,130,281,158,228,194,181,214,165,237,154,240,158,217,169,198,185,162,231,135,283,114,338,99,395,83,500,80,580"/>
<area shape="rect" href="classtatami_1_1FragmentedSparseMatrix.html" title=" " alt="" coords="223,195,397,280"/>
<area shape="poly" title=" " alt="" coords="79,580,90,519,111,443,145,363,167,325,194,290,220,268,224,272,198,294,171,328,149,365,116,445,95,520,85,581"/>
<area shape="rect" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation." alt="" coords="208,305,412,376"/>
<area shape="poly" title=" " alt="" coords="85,580,100,536,123,485,154,433,194,386,210,374,213,378,198,390,159,436,128,487,105,538,90,582"/>
<area shape="rect" href="classtatami_1_1ConstantMatrix.html" title="Matrix containing a constant value." alt="" coords="235,400,385,440"/>
<area shape="poly" title=" " alt="" coords="92,580,132,515,161,480,194,451,233,432,235,437,197,456,165,484,137,518,96,583"/>
<area shape="rect" href="classtatami_1_1DelayedBind.html" title="Delayed combining of a matrix." alt="" coords="242,465,378,506"/>
<area shape="poly" title=" " alt="" coords="107,583,147,548,194,516,241,498,243,503,197,521,150,553,110,587"/>
<area shape="rect" href="classtatami_1_1DelayedSubset.html" title="Delayed subsetting of a matrix with general indices." alt="" coords="196,530,424,571"/>
<area shape="poly" title=" " alt="" coords="162,589,234,569,235,574,164,595"/>
<area shape="rect" href="classtatami_1_1DelayedSubsetBlock.html" title="Delayed subsetting to a contiguous block." alt="" coords="218,596,402,636"/>
<area shape="poly" title=" " alt="" coords="163,614,218,614,218,619,163,619"/>
<area shape="rect" href="classtatami_1_1DelayedSubsetSorted.html" title="Delayed subsetting of a matrix with sorted indices." alt="" coords="196,661,424,702"/>
<area shape="poly" title=" " alt="" coords="164,638,235,658,234,663,162,643"/>
<area shape="rect" href="classtatami_1_1DelayedSubsetSortedUnique.html" title="Delayed subsetting of a matrix with sorted, unique indices." alt="" coords="216,726,404,781"/>
<area shape="poly" title=" " alt="" coords="111,645,150,679,197,711,220,723,218,728,194,716,147,684,107,649"/>
<area shape="rect" href="classtatami_1_1DelayedSubsetUnique.html" title="Delayed subsetting of a matrix with unique indices." alt="" coords="196,805,424,846"/>
<area shape="poly" title=" " alt="" coords="94,649,111,684,134,722,163,759,197,791,216,802,213,807,194,796,159,763,129,725,106,686,89,652"/>
<area shape="rect" href="classtatami_1_1DelayedTranspose.html" title="Delayed transposition of a matrix." alt="" coords="225,870,395,911"/>
<area shape="poly" title=" " alt="" coords="88,651,102,698,124,753,155,808,175,833,197,855,226,872,223,877,194,860,171,837,151,811,119,755,97,699,83,653"/>
<area shape="rect" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation." alt="" coords="216,936,404,976"/>
<area shape="poly" title=" " alt="" coords="84,651,94,710,114,783,129,820,148,857,170,891,197,921,217,935,214,939,194,925,166,894,143,860,124,823,109,784,89,711,79,652"/>
<area shape="rect" href="classtatami_1_1ForcedDense.html" title="Forced dense representation." alt="" coords="240,1001,380,1042"/>
<area shape="poly" title=" " alt="" coords="81,652,88,722,105,812,120,859,140,905,166,948,197,986,217,1001,241,1010,239,1015,215,1005,194,990,161,952,135,908,115,861,100,813,82,723,76,652"/>
<area shape="rect" href="classtatami_1_1FragmentedSparseMatrix.html" title="Fragmented sparse matrix representation." alt="" coords="223,1066,396,1137"/>
<area shape="poly" title=" " alt="" coords="80,652,84,732,101,838,116,895,136,951,163,1004,198,1052,224,1073,221,1077,194,1055,159,1007,131,953,110,896,96,839,79,733,75,652"/>
<area shape="rect" href="classtatami_1_1CompressedSparseColumnMatrix.html" title="Compressed sparse column matrix." alt="" coords="472,258,690,329"/>
<area shape="poly" title=" " alt="" coords="426,317,471,310,472,315,427,323"/>
<area shape="rect" href="classtatami_1_1CompressedSparseRowMatrix.html" title="Compressed sparse row matrix." alt="" coords="480,353,683,424"/>
<area shape="poly" title=" " alt="" coords="427,358,479,368,478,373,427,363"/>
<area shape="rect" href="classtatami_1_1DenseColumnMatrix.html" title="Dense column&#45;major matrix." alt="" coords="488,886,675,927"/>
<area shape="poly" title=" " alt="" coords="418,934,487,921,487,927,419,939"/>
<area shape="rect" href="classtatami_1_1DenseRowMatrix.html" title="Dense row&#45;major matrix." alt="" coords="488,952,675,992"/>
<area shape="poly" title=" " alt="" coords="419,960,487,964,487,969,419,965"/>
<area shape="rect" href="classtatami_1_1FragmentedSparseColumnMatrix.html" title="Fragmented sparse column matrix." alt="" coords="488,1049,674,1120"/>
<area shape="poly" title=" " alt="" coords="412,1092,488,1087,488,1093,412,1098"/>
<area shape="rect" href="classtatami_1_1FragmentedSparseRowMatrix.html" title="Fragmented sparse row matrix." alt="" coords="494,1144,668,1214"/>
<area shape="poly" title=" " alt="" coords="412,1128,495,1152,493,1157,411,1133"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3154ad89a70ee70e4f12784f2461fa2d" id="r_a3154ad89a70ee70e4f12784f2461fa2d"><td class="memItemLeft" align="right" valign="top">typedef Value_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3154ad89a70ee70e4f12784f2461fa2d">value_type</a></td></tr>
<tr class="separator:a3154ad89a70ee70e4f12784f2461fa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7575110444f4b58efcf0fb1a1060541c" id="r_a7575110444f4b58efcf0fb1a1060541c"><td class="memItemLeft" align="right" valign="top">typedef Index_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7575110444f4b58efcf0fb1a1060541c">index_type</a></td></tr>
<tr class="separator:a7575110444f4b58efcf0fb1a1060541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a54fe7b4baf78069d35ff00357a1b6cc6" id="r_a54fe7b4baf78069d35ff00357a1b6cc6"><td class="memItemLeft" align="right" valign="top">virtual Index_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54fe7b4baf78069d35ff00357a1b6cc6">nrow</a> () const =0</td></tr>
<tr class="separator:a54fe7b4baf78069d35ff00357a1b6cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6fec43d5bae3f831841646bc02377b" id="r_a1f6fec43d5bae3f831841646bc02377b"><td class="memItemLeft" align="right" valign="top">virtual Index_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f6fec43d5bae3f831841646bc02377b">ncol</a> () const =0</td></tr>
<tr class="separator:a1f6fec43d5bae3f831841646bc02377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57d65707ce22d8c175e43a82b8c6b90" id="r_ac57d65707ce22d8c175e43a82b8c6b90"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac57d65707ce22d8c175e43a82b8c6b90">is_sparse</a> () const =0</td></tr>
<tr class="separator:ac57d65707ce22d8c175e43a82b8c6b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72c81add2701b7e484a7855b0e62b12" id="r_aa72c81add2701b7e484a7855b0e62b12"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa72c81add2701b7e484a7855b0e62b12">is_sparse_proportion</a> () const =0</td></tr>
<tr class="separator:aa72c81add2701b7e484a7855b0e62b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69382d2a4e66cda1a9eb48dc25ab113a" id="r_a69382d2a4e66cda1a9eb48dc25ab113a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69382d2a4e66cda1a9eb48dc25ab113a">prefer_rows</a> () const =0</td></tr>
<tr class="separator:a69382d2a4e66cda1a9eb48dc25ab113a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddcc730155ca894df1c58b0a963d5e7" id="r_a2ddcc730155ca894df1c58b0a963d5e7"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ddcc730155ca894df1c58b0a963d5e7">prefer_rows_proportion</a> () const =0</td></tr>
<tr class="separator:a2ddcc730155ca894df1c58b0a963d5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68da21245203cf9349648c5452cdb2ca" id="r_a68da21245203cf9349648c5452cdb2ca"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68da21245203cf9349648c5452cdb2ca">uses_oracle</a> (bool row) const =0</td></tr>
<tr class="separator:a68da21245203cf9349648c5452cdb2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6b1ae7819fad55cf7bf5587b7e5a4b" id="r_a0b6b1ae7819fad55cf7bf5587b7e5a4b"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b6b1ae7819fad55cf7bf5587b7e5a4b">dense</a> (bool row, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a0b6b1ae7819fad55cf7bf5587b7e5a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bb7a480d2fd0cc0337577ca98840dc" id="r_a51bb7a480d2fd0cc0337577ca98840dc"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51bb7a480d2fd0cc0337577ca98840dc">dense</a> (bool row, Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a51bb7a480d2fd0cc0337577ca98840dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06803687627cc35e5ef41a887f5e5fad" id="r_a06803687627cc35e5ef41a887f5e5fad"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06803687627cc35e5ef41a887f5e5fad">dense</a> (bool row, <a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a06803687627cc35e5ef41a887f5e5fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168f0e932b5503c9bfc5dbd42754a7a5" id="r_a168f0e932b5503c9bfc5dbd42754a7a5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a168f0e932b5503c9bfc5dbd42754a7a5">dense_row</a> (const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a168f0e932b5503c9bfc5dbd42754a7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6505ab08f36ab2e2487f7598a8df4e" id="r_a3d6505ab08f36ab2e2487f7598a8df4e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d6505ab08f36ab2e2487f7598a8df4e">dense_row</a> (Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a3d6505ab08f36ab2e2487f7598a8df4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6f4909657d2e44196a56c99ffafb5c" id="r_a4b6f4909657d2e44196a56c99ffafb5c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b6f4909657d2e44196a56c99ffafb5c">dense_row</a> (<a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a4b6f4909657d2e44196a56c99ffafb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563d877fa76c04d1faa039ebab88038c" id="r_a563d877fa76c04d1faa039ebab88038c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a563d877fa76c04d1faa039ebab88038c">dense_row</a> (std::vector&lt; Index_ &gt; indices, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a563d877fa76c04d1faa039ebab88038c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48300b3739f26bb10732c572ea9e5c57" id="r_a48300b3739f26bb10732c572ea9e5c57"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48300b3739f26bb10732c572ea9e5c57">dense_column</a> (const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a48300b3739f26bb10732c572ea9e5c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daf387535987b84f7b44c68fb664d33" id="r_a9daf387535987b84f7b44c68fb664d33"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9daf387535987b84f7b44c68fb664d33">dense_column</a> (Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a9daf387535987b84f7b44c68fb664d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce124d5abc915f47e0abdec500b84f3" id="r_a8ce124d5abc915f47e0abdec500b84f3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ce124d5abc915f47e0abdec500b84f3">dense_column</a> (<a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a8ce124d5abc915f47e0abdec500b84f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace58cae1956cbf7474aa7120e0d89cc9" id="r_ace58cae1956cbf7474aa7120e0d89cc9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace58cae1956cbf7474aa7120e0d89cc9">dense_column</a> (std::vector&lt; Index_ &gt; indices, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:ace58cae1956cbf7474aa7120e0d89cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d572f319b614a7e74d426cac94194de" id="r_a4d572f319b614a7e74d426cac94194de"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d572f319b614a7e74d426cac94194de">dense_row</a> () const</td></tr>
<tr class="separator:a4d572f319b614a7e74d426cac94194de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb45e8a21e1792a316fa95064edb9c2" id="r_aacb45e8a21e1792a316fa95064edb9c2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacb45e8a21e1792a316fa95064edb9c2">dense_row</a> (Index_ block_start, Index_ block_length) const</td></tr>
<tr class="separator:aacb45e8a21e1792a316fa95064edb9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371fa940bc33a019b1f6938c2b06201f" id="r_a371fa940bc33a019b1f6938c2b06201f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a371fa940bc33a019b1f6938c2b06201f">dense_row</a> (<a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr) const</td></tr>
<tr class="separator:a371fa940bc33a019b1f6938c2b06201f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3692e08db0886e4e866e28942d46b0" id="r_a3f3692e08db0886e4e866e28942d46b0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f3692e08db0886e4e866e28942d46b0">dense_row</a> (std::vector&lt; Index_ &gt; indices) const</td></tr>
<tr class="separator:a3f3692e08db0886e4e866e28942d46b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2dad77430f29f277f73028c7c2636e2" id="r_aa2dad77430f29f277f73028c7c2636e2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2dad77430f29f277f73028c7c2636e2">dense_column</a> () const</td></tr>
<tr class="separator:aa2dad77430f29f277f73028c7c2636e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478f96c3a39b40a950dda3d115365c89" id="r_a478f96c3a39b40a950dda3d115365c89"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a478f96c3a39b40a950dda3d115365c89">dense_column</a> (Index_ block_start, Index_ block_length) const</td></tr>
<tr class="separator:a478f96c3a39b40a950dda3d115365c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9058c33bd860936d0a6fe4f03397f6b9" id="r_a9058c33bd860936d0a6fe4f03397f6b9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9058c33bd860936d0a6fe4f03397f6b9">dense_column</a> (<a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr) const</td></tr>
<tr class="separator:a9058c33bd860936d0a6fe4f03397f6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b82bffd2c71c4301867e8a0ffcf37f3" id="r_a7b82bffd2c71c4301867e8a0ffcf37f3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b82bffd2c71c4301867e8a0ffcf37f3">dense_column</a> (std::vector&lt; Index_ &gt; indices) const</td></tr>
<tr class="separator:a7b82bffd2c71c4301867e8a0ffcf37f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84772cc4e911a87948d45a1edcabbd0" id="r_af84772cc4e911a87948d45a1edcabbd0"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af84772cc4e911a87948d45a1edcabbd0">sparse</a> (bool row, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:af84772cc4e911a87948d45a1edcabbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af802c74c510eff3316ce0eea99c08810" id="r_af802c74c510eff3316ce0eea99c08810"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af802c74c510eff3316ce0eea99c08810">sparse</a> (bool row, Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:af802c74c510eff3316ce0eea99c08810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d055aed809a2036c10c1fce92bd036" id="r_a59d055aed809a2036c10c1fce92bd036"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59d055aed809a2036c10c1fce92bd036">sparse</a> (bool row, <a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a59d055aed809a2036c10c1fce92bd036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb3651992dff44cdf8d560a527707f6" id="r_afcb3651992dff44cdf8d560a527707f6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcb3651992dff44cdf8d560a527707f6">sparse_row</a> (const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:afcb3651992dff44cdf8d560a527707f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada39dd5987e82eb0aa50c302ee3ed564" id="r_ada39dd5987e82eb0aa50c302ee3ed564"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada39dd5987e82eb0aa50c302ee3ed564">sparse_row</a> (Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:ada39dd5987e82eb0aa50c302ee3ed564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64a711a19ebc55da7b5fdc193db839c" id="r_ac64a711a19ebc55da7b5fdc193db839c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac64a711a19ebc55da7b5fdc193db839c">sparse_row</a> (<a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:ac64a711a19ebc55da7b5fdc193db839c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb26d2551fec7753001e8c274c9661de" id="r_afb26d2551fec7753001e8c274c9661de"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb26d2551fec7753001e8c274c9661de">sparse_row</a> (std::vector&lt; Index_ &gt; indices, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:afb26d2551fec7753001e8c274c9661de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed47eef4ab4a6563db02acc77e22e5eb" id="r_aed47eef4ab4a6563db02acc77e22e5eb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed47eef4ab4a6563db02acc77e22e5eb">sparse_column</a> (const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:aed47eef4ab4a6563db02acc77e22e5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45028c0259b57630cdc23e4f3d08835" id="r_ad45028c0259b57630cdc23e4f3d08835"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad45028c0259b57630cdc23e4f3d08835">sparse_column</a> (Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:ad45028c0259b57630cdc23e4f3d08835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f340c985ed28a230745d87c9cd6ac44" id="r_a9f340c985ed28a230745d87c9cd6ac44"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f340c985ed28a230745d87c9cd6ac44">sparse_column</a> (<a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a9f340c985ed28a230745d87c9cd6ac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518b8f184afb562e8ef722c2feef0875" id="r_a518b8f184afb562e8ef722c2feef0875"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a518b8f184afb562e8ef722c2feef0875">sparse_column</a> (std::vector&lt; Index_ &gt; indices, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a518b8f184afb562e8ef722c2feef0875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedecd4c23762ff43f49cfb0d2c687056" id="r_aedecd4c23762ff43f49cfb0d2c687056"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedecd4c23762ff43f49cfb0d2c687056">sparse_row</a> () const</td></tr>
<tr class="separator:aedecd4c23762ff43f49cfb0d2c687056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aecb2560e570ec8f6e3efb0eddf55d" id="r_ad2aecb2560e570ec8f6e3efb0eddf55d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2aecb2560e570ec8f6e3efb0eddf55d">sparse_row</a> (Index_ block_start, Index_ block_length) const</td></tr>
<tr class="separator:ad2aecb2560e570ec8f6e3efb0eddf55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe0fed52aae518a420114727e1c98a1" id="r_acbe0fed52aae518a420114727e1c98a1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbe0fed52aae518a420114727e1c98a1">sparse_row</a> (<a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr) const</td></tr>
<tr class="separator:acbe0fed52aae518a420114727e1c98a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3011f5e2ee8103fcc4c6488bfd228997" id="r_a3011f5e2ee8103fcc4c6488bfd228997"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3011f5e2ee8103fcc4c6488bfd228997">sparse_row</a> (std::vector&lt; Index_ &gt; indices) const</td></tr>
<tr class="separator:a3011f5e2ee8103fcc4c6488bfd228997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0efad968be5f4b9a36bb50beb8460f8" id="r_ab0efad968be5f4b9a36bb50beb8460f8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column</a> () const</td></tr>
<tr class="separator:ab0efad968be5f4b9a36bb50beb8460f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f592922949fc50786de3eb6f58d0be" id="r_a51f592922949fc50786de3eb6f58d0be"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51f592922949fc50786de3eb6f58d0be">sparse_column</a> (Index_ block_start, Index_ block_length) const</td></tr>
<tr class="separator:a51f592922949fc50786de3eb6f58d0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb6b4e90e3ab5cf0112e7cbd31f18f4" id="r_adfb6b4e90e3ab5cf0112e7cbd31f18f4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfb6b4e90e3ab5cf0112e7cbd31f18f4">sparse_column</a> (<a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr) const</td></tr>
<tr class="separator:adfb6b4e90e3ab5cf0112e7cbd31f18f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbd197a7d1530397cff04660e78f28f" id="r_aebbd197a7d1530397cff04660e78f28f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebbd197a7d1530397cff04660e78f28f">sparse_column</a> (std::vector&lt; Index_ &gt; indices) const</td></tr>
<tr class="separator:aebbd197a7d1530397cff04660e78f28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6502fdebcaeea40490c1780ab6e92b19" id="r_a6502fdebcaeea40490c1780ab6e92b19"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6502fdebcaeea40490c1780ab6e92b19">dense</a> (bool row, std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a6502fdebcaeea40490c1780ab6e92b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b24fe319289ca76f2b366a2ffe798d" id="r_a48b24fe319289ca76f2b366a2ffe798d"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48b24fe319289ca76f2b366a2ffe798d">dense</a> (bool row, std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a48b24fe319289ca76f2b366a2ffe798d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aecaa5038554d2c92c2ab7083497cb6" id="r_a4aecaa5038554d2c92c2ab7083497cb6"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aecaa5038554d2c92c2ab7083497cb6">dense</a> (bool row, std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, <a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a4aecaa5038554d2c92c2ab7083497cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60952db300c69580a9eba01b5f787d6" id="r_aa60952db300c69580a9eba01b5f787d6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa60952db300c69580a9eba01b5f787d6">dense_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:aa60952db300c69580a9eba01b5f787d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc57cd1f625bdc44af4946a0124f7464" id="r_acc57cd1f625bdc44af4946a0124f7464"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc57cd1f625bdc44af4946a0124f7464">dense_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:acc57cd1f625bdc44af4946a0124f7464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab247d39db776da3e2143f4599f76920e" id="r_ab247d39db776da3e2143f4599f76920e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab247d39db776da3e2143f4599f76920e">dense_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, <a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:ab247d39db776da3e2143f4599f76920e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f53f2f7b2a2e5972a91a56065ba28b" id="r_ad8f53f2f7b2a2e5972a91a56065ba28b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8f53f2f7b2a2e5972a91a56065ba28b">dense_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, std::vector&lt; Index_ &gt; indices, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:ad8f53f2f7b2a2e5972a91a56065ba28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca1e41bc821f551d76175687fd2e6b5" id="r_a8ca1e41bc821f551d76175687fd2e6b5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ca1e41bc821f551d76175687fd2e6b5">dense_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a8ca1e41bc821f551d76175687fd2e6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2323a04228d638ec0340036acafa420f" id="r_a2323a04228d638ec0340036acafa420f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2323a04228d638ec0340036acafa420f">dense_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a2323a04228d638ec0340036acafa420f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d717304d7cf4806c182ecd446de144d" id="r_a8d717304d7cf4806c182ecd446de144d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d717304d7cf4806c182ecd446de144d">dense_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, <a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a8d717304d7cf4806c182ecd446de144d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585337cdd3a90c5cf6cf2fdca2b43e84" id="r_a585337cdd3a90c5cf6cf2fdca2b43e84"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a585337cdd3a90c5cf6cf2fdca2b43e84">dense_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, std::vector&lt; Index_ &gt; indices, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a585337cdd3a90c5cf6cf2fdca2b43e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb2b21aad79130762a8cb0c7069d3a3" id="r_a9fb2b21aad79130762a8cb0c7069d3a3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fb2b21aad79130762a8cb0c7069d3a3">dense_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle) const</td></tr>
<tr class="separator:a9fb2b21aad79130762a8cb0c7069d3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cecc240982c961455ede8d329cda207" id="r_a2cecc240982c961455ede8d329cda207"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cecc240982c961455ede8d329cda207">dense_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, Index_ block_start, Index_ block_length) const</td></tr>
<tr class="separator:a2cecc240982c961455ede8d329cda207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32275c6bf6553d6b1833abdce9165b5d" id="r_a32275c6bf6553d6b1833abdce9165b5d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32275c6bf6553d6b1833abdce9165b5d">dense_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, <a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr) const</td></tr>
<tr class="separator:a32275c6bf6553d6b1833abdce9165b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce58d2a5e7b244b49a97cabff56c94b" id="r_a6ce58d2a5e7b244b49a97cabff56c94b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ce58d2a5e7b244b49a97cabff56c94b">dense_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, std::vector&lt; Index_ &gt; indices) const</td></tr>
<tr class="separator:a6ce58d2a5e7b244b49a97cabff56c94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068863a2b525300afb446aa249f67f6b" id="r_a068863a2b525300afb446aa249f67f6b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a068863a2b525300afb446aa249f67f6b">dense_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle) const</td></tr>
<tr class="separator:a068863a2b525300afb446aa249f67f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9d3994a74ebdf26894d92ad3625d8c" id="r_a3a9d3994a74ebdf26894d92ad3625d8c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a9d3994a74ebdf26894d92ad3625d8c">dense_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, Index_ block_start, Index_ block_length) const</td></tr>
<tr class="separator:a3a9d3994a74ebdf26894d92ad3625d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d214b599712ab2f265b06d45d9e7047" id="r_a3d214b599712ab2f265b06d45d9e7047"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d214b599712ab2f265b06d45d9e7047">dense_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, <a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr) const</td></tr>
<tr class="separator:a3d214b599712ab2f265b06d45d9e7047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6421e936b7d10b2dee56c41c6591322e" id="r_a6421e936b7d10b2dee56c41c6591322e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6421e936b7d10b2dee56c41c6591322e">dense_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, std::vector&lt; Index_ &gt; indices) const</td></tr>
<tr class="separator:a6421e936b7d10b2dee56c41c6591322e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5605c18620abdab0f82015b959e9813a" id="r_a5605c18620abdab0f82015b959e9813a"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5605c18620abdab0f82015b959e9813a">sparse</a> (bool row, std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:a5605c18620abdab0f82015b959e9813a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfcf54358970874051e5cc700730707" id="r_aacfcf54358970874051e5cc700730707"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacfcf54358970874051e5cc700730707">sparse</a> (bool row, std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:aacfcf54358970874051e5cc700730707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7557a27bbb09f8453a3e6848ad910e" id="r_abe7557a27bbb09f8453a3e6848ad910e"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe7557a27bbb09f8453a3e6848ad910e">sparse</a> (bool row, std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, <a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const =0</td></tr>
<tr class="separator:abe7557a27bbb09f8453a3e6848ad910e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9914398b94a1a9f3082478d9646fc21d" id="r_a9914398b94a1a9f3082478d9646fc21d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9914398b94a1a9f3082478d9646fc21d">sparse_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a9914398b94a1a9f3082478d9646fc21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67262da7611609ba28f9ac1d9ed20e9" id="r_af67262da7611609ba28f9ac1d9ed20e9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af67262da7611609ba28f9ac1d9ed20e9">sparse_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:af67262da7611609ba28f9ac1d9ed20e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86c164710f168484a0037169bf51622" id="r_af86c164710f168484a0037169bf51622"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af86c164710f168484a0037169bf51622">sparse_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, <a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:af86c164710f168484a0037169bf51622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47155bacf33f5c269c8da4ce96d1adb8" id="r_a47155bacf33f5c269c8da4ce96d1adb8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47155bacf33f5c269c8da4ce96d1adb8">sparse_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, std::vector&lt; Index_ &gt; indices, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a47155bacf33f5c269c8da4ce96d1adb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ce6f1c8ad4f4d2e8d62c8e005c7df8" id="r_a25ce6f1c8ad4f4d2e8d62c8e005c7df8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25ce6f1c8ad4f4d2e8d62c8e005c7df8">sparse_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a25ce6f1c8ad4f4d2e8d62c8e005c7df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576f3bd09c075d59101e561c715c82e2" id="r_a576f3bd09c075d59101e561c715c82e2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a576f3bd09c075d59101e561c715c82e2">sparse_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, Index_ block_start, Index_ block_length, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a576f3bd09c075d59101e561c715c82e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413c72fd73b8e156f3b2fb3f8ebd2497" id="r_a413c72fd73b8e156f3b2fb3f8ebd2497"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a413c72fd73b8e156f3b2fb3f8ebd2497">sparse_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, <a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:a413c72fd73b8e156f3b2fb3f8ebd2497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbdd5c72c285b22942ce2714874b810" id="r_acfbdd5c72c285b22942ce2714874b810"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfbdd5c72c285b22942ce2714874b810">sparse_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, std::vector&lt; Index_ &gt; indices, const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;opt) const</td></tr>
<tr class="separator:acfbdd5c72c285b22942ce2714874b810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69c3729445a087b33bfa9717b8e0bd1" id="r_ac69c3729445a087b33bfa9717b8e0bd1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac69c3729445a087b33bfa9717b8e0bd1">sparse_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle) const</td></tr>
<tr class="separator:ac69c3729445a087b33bfa9717b8e0bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae052d20e59e1cd0c58915f1165c42b44" id="r_ae052d20e59e1cd0c58915f1165c42b44"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae052d20e59e1cd0c58915f1165c42b44">sparse_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, Index_ block_start, Index_ block_length) const</td></tr>
<tr class="separator:ae052d20e59e1cd0c58915f1165c42b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc1dfadd943138f21cf3e9dd1f89147" id="r_a3fc1dfadd943138f21cf3e9dd1f89147"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fc1dfadd943138f21cf3e9dd1f89147">sparse_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, <a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr) const</td></tr>
<tr class="separator:a3fc1dfadd943138f21cf3e9dd1f89147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f8dbf2064d74038813b5c0191a6542" id="r_a59f8dbf2064d74038813b5c0191a6542"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59f8dbf2064d74038813b5c0191a6542">sparse_row</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, std::vector&lt; Index_ &gt; indices) const</td></tr>
<tr class="separator:a59f8dbf2064d74038813b5c0191a6542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8274ac6fb2345fcece74e6fdb35e05d4" id="r_a8274ac6fb2345fcece74e6fdb35e05d4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8274ac6fb2345fcece74e6fdb35e05d4">sparse_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle) const</td></tr>
<tr class="separator:a8274ac6fb2345fcece74e6fdb35e05d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9538dcc44c008dd203e719a855ac7fca" id="r_a9538dcc44c008dd203e719a855ac7fca"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9538dcc44c008dd203e719a855ac7fca">sparse_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, Index_ block_start, Index_ block_length) const</td></tr>
<tr class="separator:a9538dcc44c008dd203e719a855ac7fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917f575b5430e14e2ccda56a5b6903be" id="r_a917f575b5430e14e2ccda56a5b6903be"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a917f575b5430e14e2ccda56a5b6903be">sparse_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, <a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt; indices_ptr) const</td></tr>
<tr class="separator:a917f575b5430e14e2ccda56a5b6903be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c6514d93279e77fb8505d29c334217" id="r_ad3c6514d93279e77fb8505d29c334217"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3c6514d93279e77fb8505d29c334217">sparse_column</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt; oracle, std::vector&lt; Index_ &gt; indices) const</td></tr>
<tr class="separator:ad3c6514d93279e77fb8505d29c334217"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Value_, typename Index_&gt;<br />
class tatami::Matrix&lt; Value_, Index_ &gt;</div><p>Virtual class for a matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Interface for a matrix in the <b>tatami</b> library. This declares methods to iterate through the matrix by row or column, extracting data in either dense or sparse form. Check out <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">DenseMatrix</a></code> and <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">CompressedSparseMatrix</a></code> for examples of concrete subclasses.</p>
<p>To access the matrix data, the <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> methods first return an instance of an extractor class like <code><a class="el" href="classtatami_1_1MyopicDenseExtractor.html" title="Extract an element of the target dimension in dense form without an oracle.">MyopicDenseExtractor</a></code>, which can then be used to retrieve the matrix contents. Creation of the extractor depends on a few parameters:</p>
<ul>
<li>Choice of the "target" dimension. The "target" dimension is defined as the one that is iterated over/indexed into, while the "non-target" dimension is the other dimension. For example, if we were iterating row-wise through a matrix, the rows would constitute the target dimension, while the columns would be the non-target dimension. An element of the target dimension is obtained by indexing into that dimension, e.g., if the rows are the target dimension, then any particular row is an element of the target dimension.</li>
<li>Whether to restrict the non-target dimension (see <code><a class="el" href="namespacetatami.html#a0a2ecaf58e2b69bb4a808e814aeb16a1">tatami::DimensionSelectionType</a></code>). We can choose to extract the full extent of the non-target dimension, a contiguous block, or an indexed subset. For example, if we were iterating row-wise through a matrix, we might only be interested in a subset of columns.</li>
<li>Whether the order of accesses on the target dimension are known. If so, we can potentially improve efficiency by supplying an <code><a class="el" href="classtatami_1_1Oracle.html" title="Predict future access requests on the target dimension.">Oracle</a></code> during extractor construction. For example, if we know we will iterate through the matrix by consecutive rows, we could supply a <code><a class="el" href="classtatami_1_1ConsecutiveOracle.html" title="Predict future accesses along a consecutive sequence.">ConsecutiveOracle</a></code> to allow <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> implementations to optimize for this access pattern.</li>
<li>Whether to obtain the contents for a target dimension element in dense or sparse form. The dense form is simply a contiguous 1-dimensional array of matrix <code>Value_</code>s. The sparse form is a <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">SparseRange</a></code> describing the structural non-zeros for that dimension element.</li>
</ul>
<p><code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> subclasses should describe whether they are dense/sparse and if they prefer row or column access. This allows users to choose the best method of extracting data from the matrix. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3154ad89a70ee70e4f12784f2461fa2d" name="a3154ad89a70ee70e4f12784f2461fa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3154ad89a70ee70e4f12784f2461fa2d">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value_ <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of data to be returned by getters. </p>

</div>
</div>
<a id="a7575110444f4b58efcf0fb1a1060541c" name="a7575110444f4b58efcf0fb1a1060541c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7575110444f4b58efcf0fb1a1060541c">&#9670;&#160;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Index_ <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::index_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of index to be returned by the sparse getters. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a54fe7b4baf78069d35ff00357a1b6cc6" name="a54fe7b4baf78069d35ff00357a1b6cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fe7b4baf78069d35ff00357a1b6cc6">&#9670;&#160;</a></span>nrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index_ <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::nrow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of rows.</dd></dl>
<p>It is expected that the number of rows can be represented by a <code>std::size_t</code> without overflow, even if <code>Index_</code> is of a larger size. This is implied by the fact that <code><a class="el" href="classtatami_1_1MyopicDenseExtractor.html#a9f3ee9c959cdefdb45dcbcd607826a49">MyopicDenseExtractor::fetch()</a></code> and friends accept a pointer for their buffer arguments; the length of the array referenced by these pointers (possibly equal to the number of rows) must fit in a <code>std::size_t</code>. </p>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a3365d94d7ad16f89d780ba27deffa45a">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a3365d94d7ad16f89d780ba27deffa45a">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#a4b4ffa7d614555b1da63d8fc94ec0a48">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a84a6c62e17e13a2a4aa81eec7900d1d8">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a64f90b7152def0f1a53aadbac1901687">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a6669aa5ef922006a2c36b2a7d6770b80">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ae0be0f8b5edb78650b05215382292bb8">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a1f09481f1564fe050f515ab893ab3cb7">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a1f508fbef006cc90aae91ed73ae8a031">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a860753784bf729987e0ccb57867ebf9b">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#abd8575ed2028699594702d62bb1dfdfc">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ae861c999ade80dfaab4e00ea0a3c9f89">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#af2d9ab7126cf46752976525c656f01fd">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ab18c5c9611a0d989391b511d2430a1a4">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ab18c5c9611a0d989391b511d2430a1a4">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#aabeb724c641ae371cea7b2e0b65d75dd">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a9632369fd9488210695dbd05b13a8ab5">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a9632369fd9488210695dbd05b13a8ab5">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="a1f6fec43d5bae3f831841646bc02377b" name="a1f6fec43d5bae3f831841646bc02377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6fec43d5bae3f831841646bc02377b">&#9670;&#160;</a></span>ncol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index_ <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::ncol </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of columns.</dd></dl>
<p>It is expected that the number of columns can be represented by a <code>std::size_t</code> without overflow, even if <code>Index_</code> is of a larger size. This is implied by the fact that <code><a class="el" href="classtatami_1_1MyopicDenseExtractor.html#a9f3ee9c959cdefdb45dcbcd607826a49">MyopicDenseExtractor::fetch()</a></code> and friends accept a pointer for their buffer arguments; the length of the array referenced by these pointers (possibly equal to the number of rows) must fit in a <code>std::size_t</code>. </p>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ae7a25c967b851a667885a2052ad6a45f">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ae7a25c967b851a667885a2052ad6a45f">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#a84184cb5ad5ee58f0ab3cf28d541ebc6">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#aa78d8193587f7f867487bd94ecaa26ce">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#acb743be5663d4fb13624ba0502448bd8">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#aa83b0cdd9395331151d8292e786deeb7">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a560b1c163ab30ace7cfc9dd79618f8a6">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a397f04132c63c97c39afa68e2bc2f600">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#af5ac4154e1eb8da1412716adf512e3f8">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a4318f664cb5adcb4f49aafe577aaa0a5">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a15b1db881d24b4b01274ecc1f39de3dc">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a495080ac6d15551d6816adf85ab2d481">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a4d24d218fc51e88f366339e9af150a5a">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ae43ef7c94906bc7eb73f39dc720171f6">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ae43ef7c94906bc7eb73f39dc720171f6">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#abe7e6b1aac9a48060ad5b7eb37919967">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a427e1a6ab4a1eded1374b30c3d6f05ae">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a427e1a6ab4a1eded1374b30c3d6f05ae">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="ac57d65707ce22d8c175e43a82b8c6b90" name="ac57d65707ce22d8c175e43a82b8c6b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57d65707ce22d8c175e43a82b8c6b90">&#9670;&#160;</a></span>is_sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::is_sparse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Boolean indicating whether this matrix is sparse.</dd></dl>
<p>This can be used to choose between dense and sparse outputs. </p>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ada14aaaeb96bafe8d483ed2d3f91bb59">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ada14aaaeb96bafe8d483ed2d3f91bb59">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#a109155791ecacc6f0bab29226e0a8dbc">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#ae9063d46bc75ff346ed42a7ba9652d31">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a79b7ed57367550ed4c2ddbc4798464f8">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#aa2e8ede032453d49cbfbc98771a3fd6d">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ae9357b3d715e126b6c2eba973bdfaebf">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a77b5f60160bd1437e5ce142d8cdafab5">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a4ab61a3dc5828d5b71fa13d77888a6a7">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ad782463b6d4c5039119717b38f7f159d">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a48e6d664da3a63cc20cb1215f5165fd1">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a64df8253602c0e2ad716b154b079c8aa">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a8d45e81797aeb963601baf3f32a02240">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a4a362f61248baa1f4c13aaeafcd96dbb">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a4a362f61248baa1f4c13aaeafcd96dbb">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#af89f0e213125b0260a333430169225e4">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a9c14f99e0ef86e41742aec9d5c086996">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a9c14f99e0ef86e41742aec9d5c086996">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="aa72c81add2701b7e484a7855b0e62b12" name="aa72c81add2701b7e484a7855b0e62b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72c81add2701b7e484a7855b0e62b12">&#9670;&#160;</a></span>is_sparse_proportion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::is_sparse_proportion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Approximate proportion of the matrix that is sparse.</dd></dl>
<p>This is defined as the proportion of matrix elements that lie within sparse submatrices. It is intended for use in <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> representations that consist of combinations of multiple submatrices (e.g., <code><a class="el" href="classtatami_1_1DelayedBind.html" title="Delayed combining of a matrix.">DelayedBind</a></code>), allowing them to derive a suitable value for <code><a class="el" href="#ac57d65707ce22d8c175e43a82b8c6b90">is_sparse()</a></code> based on whether most of its submatrices are sparse. (A more granular approach would be to report the density of structural non-zero elements, but this may not be known by all representations at construction time.) </p>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a8cc56caec424be36706baaa824631e9c">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a8cc56caec424be36706baaa824631e9c">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#a4aa07cce9af27ac329a0fb18a946234c">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a5462b7bbf9bd084ccd09b0e418adb332">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a53a04770fdc42a2a906f677b325d7998">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#ab5b7952a43d2c1255032b2b671b3b040">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#aeeb4a2cb1df1630f725741bab7974535">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a4df587f4add88fd84abd461495b78f06">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a3eec91fb8f1b3d931afec04fdfa1d742">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a826a60e784ec3dfe2b794979d022db34">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a421427ed0f30a0e904133baa7d78ea2b">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ae879d7274b0196f18f82ccba86a178ad">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a231921372cd48daeeb8497d815f5388e">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a884c8899818f7a8ea6a150c3684048ef">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a884c8899818f7a8ea6a150c3684048ef">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#a81beb2a29b4ead2df95bcac12cbf327e">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a9190434e706cbb52a9765ff827735f6f">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a9190434e706cbb52a9765ff827735f6f">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="a69382d2a4e66cda1a9eb48dc25ab113a" name="a69382d2a4e66cda1a9eb48dc25ab113a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69382d2a4e66cda1a9eb48dc25ab113a">&#9670;&#160;</a></span>prefer_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::prefer_rows </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The preferred dimension for extracting values. If <code>true</code>, row-wise extraction is preferred; if <code>false</code>, column-wise extraction is preferred. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a45a108841635187e7428cbc6f1969a28">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a45a108841635187e7428cbc6f1969a28">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#af7bf04bc4dcb379ca9fc24fc8dd87669">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a79fdf2ed573a733464637b79c1f4f230">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#adeedfaa0423b0e7c6f12c3d524e0319d">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#acd15dc4d42f79dcf6e8f100f59b17a9b">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a5df9d7940178cca7db145fb5ab533051">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#aeb7911f1048e29196a24fa0da8093b1a">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a295013d786b741cea170af7cca27166a">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#af9085320f0969d1f0e5102588fb2acd9">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a12e84da197144398246f055b24726c61">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a8d386b8a0d05d6bcdbc1dd80c7d8118e">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a0c50d1aa36b78024625c7b4ad1e40251">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a47eade967a5c180ff4a8c8644e57947b">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a47eade967a5c180ff4a8c8644e57947b">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#a543e530d485d64b076dbcb82b20c5444">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#ab8415def9c366ffa6ec1713210b518b6">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#ab8415def9c366ffa6ec1713210b518b6">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="a2ddcc730155ca894df1c58b0a963d5e7" name="a2ddcc730155ca894df1c58b0a963d5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddcc730155ca894df1c58b0a963d5e7">&#9670;&#160;</a></span>prefer_rows_proportion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::prefer_rows_proportion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Approximate proportion of the matrix that prefers row-level access.</dd></dl>
<p>This is defined as the proportion of matrix elements that lie within submatrices that prefer row-level access. It is useful for determining the return value of <code><a class="el" href="#a69382d2a4e66cda1a9eb48dc25ab113a">prefer_rows()</a></code> in combined matrices consisting of both row- and column-preferred submatrices. In such cases, the net preference can be determined based on the combined size of the submatrices for each preference. (A more granular approach would be to report the iteration cost on each dimension, but this is difficult to estimate.) </p>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a51bc0d7358afec17953fca1d37eab439">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a51bc0d7358afec17953fca1d37eab439">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#a4c0222313e3dad71b001ae734ccd058a">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a0b44d5c7f3c815077ee78a2317733027">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#af6fe54f29461d429362f0b8fec0da84e">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a5bbd6fe49cfca5995289950abcf18856">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#aab2a16870e36e5fd5f5adcc7c986a5db">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a33461de6d39962ab1dd23dfd3d574d72">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a17bb58ece77b014f927894dd9a3e645f">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a49dd8093b1f87ac9d369cc7f9014224f">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a5d3b4e2f848ffd914b2f2615c86c651b">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#af218bfcac74f403cc9d5bd6be84cc7a5">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a6d92bc07c3ee9f09e45567d7b6fe39f3">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a44486a7d66661eada08c22a64547e937">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a44486a7d66661eada08c22a64547e937">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#a5feccd9585a8d0dc82b5974324f00e75">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a5bc5cb7ee33045f37312445007f487f0">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a5bc5cb7ee33045f37312445007f487f0">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="a68da21245203cf9349648c5452cdb2ca" name="a68da21245203cf9349648c5452cdb2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68da21245203cf9349648c5452cdb2ca">&#9670;&#160;</a></span>uses_oracle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::uses_oracle </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Row access if <code>true</code>, column access otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this matrix's <code>tatami::Extractor</code> classes make use of oracle predictions for row (if <code>row = true</code>) or column access (otherwise).</dd></dl>
<p>The output of this method indicates whether callers should construct an oracle for use in <code>ExtractorBase::set_oracle()</code>. If <code>false</code>, callers should not bother to pass an oracle as it will be ignored. </p>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6703b840e50ab473d95aaf324965ba8a">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6703b840e50ab473d95aaf324965ba8a">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#aa482d7ca177873f1c06ad7413a80b563">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a9af739894c981f020662c7ebd50c9c02">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a11efb3f8a15be935bf9d1f4650dcc0a1">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#aa033835a7c5700ec01b2ff0ba34994b4">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a17fa80702e54fb231bc0dd317063ec04">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a2a2136a612eeec1fe79474e9f2a3896b">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#aa5211a17c6fc95bbdc2b61bc97b41b35">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a5413d71a3e7d650ffa6e8918f484a54c">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a8df0bbd1d49c4a2d9db1a48aed03975c">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a9816844db5d1de41bef1bc0f956f8e6d">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a32b9bddadf8d65dc1c79477c6be20873">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a80c9e44e268abc55d9d8cfcb10d7ea63">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a80c9e44e268abc55d9d8cfcb10d7ea63">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#ad92e3a944a8f878aba133380ae000845">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#ac7d7676ce5f820dce27bfd7096439832">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#ac7d7676ce5f820dce27bfd7096439832">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="a0b6b1ae7819fad55cf7bf5587b7e5a4b" name="a0b6b1ae7819fad55cf7bf5587b7e5a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6b1ae7819fad55cf7bf5587b7e5a4b">&#9670;&#160;</a></span>dense() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an extractor that retrieves the full extent of the non-target dimension in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row (if <code>row = true</code>) or column (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#af87178f5c8b51c47d106a6e1e76bece6">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#af87178f5c8b51c47d106a6e1e76bece6">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#a9762b9ef9b02204a3d74e00aaf5b79a8">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#acc2d403f79052eb2bc6c2d68f58124ad">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a2ff86ea2ac242d782f0848a4000a3d17">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a3ce51b856f83daf7584aed808a7549fe">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a805e6ab3e655c3798714b00096e9c2b1">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a2a22f61ebd83664e917cfa807a615980">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a92174d5c3ee590000cc53716bfc1f9fc">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#af08f18b60edfe4ee8af900f47e152d43">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a87639f1e57f768a249602b762b9ec29b">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a1836b0830824878332839f6da5ddaed4">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a92d607748dcd0cf6dcb9abe57f40ca53">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a96eb7b7f9bd9271ef8dd341c66e5f1f9">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a96eb7b7f9bd9271ef8dd341c66e5f1f9">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, and <a class="el" href="classtatami_1_1ForcedDense.html#ab9fae07a1544ab20c2551cae56aecd43">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a51bb7a480d2fd0cc0337577ca98840dc" name="a51bb7a480d2fd0cc0337577ca98840dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bb7a480d2fd0cc0337577ca98840dc">&#9670;&#160;</a></span>dense() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an extractor that retrieves a contiguous block of the non-target dimension in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column (if <code>row = true</code>) or row (otherwise) at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns (if <code>row = true</code>) or rows (otherwise) in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row (if <code>row = true</code>) or column (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#af9733cce95fbeff4164e58bdc5e6b270">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#af9733cce95fbeff4164e58bdc5e6b270">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#ab510870c19a1a84ed5398803cf94f399">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#ae1e9aa82441fd6fed04c4a4a249e4713">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a64349fc202da7aad5cedc3e06b0c19aa">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a22012cc2c41a5bbfc3a5e8e998179581">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#aec3153bb9b09c3e4af05ddc50285b2ef">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a450626f78cee37f55ef9f9f7135f6aa6">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a3da232b8b7c1cd490d6f81d3d7269b1f">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a667ecbcdb2f86b4faee8e135b23557b1">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a790975d0c8d0364416f2b7398d159d62">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#aaa208cb29b27f0a8d13144fb27f116c5">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#aeefaafa28739efba01dcaf30ad4193a8">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ac7b3b773431cc0f5e976385742987678">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#ac7b3b773431cc0f5e976385742987678">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, and <a class="el" href="classtatami_1_1ForcedDense.html#a52d5ad3e0bc2bb4cd8c75ba72c626da8">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a06803687627cc35e5ef41a887f5e5fad" name="a06803687627cc35e5ef41a887f5e5fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06803687627cc35e5ef41a887f5e5fad">&#9670;&#160;</a></span>dense() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an extractor that retrieves an indexed subset of the non-target dimension in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices (if <code>row = true</code>) or row indices (otherwise). This should be non-NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row (if <code>row = true</code>) or column (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#aa30bd5da194307e73b6a541788a49c3b">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#aa30bd5da194307e73b6a541788a49c3b">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#aa2ea9061ec3f6c29f918be59615b9eac">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a645e00417be4a394271905361ae67159">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a6ddaab36a19a50431fea323f90fe1f6a">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a8795c6212cfa59e1f8d359240cf372cc">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ab6d686619fdc38da5099f78faf53dab9">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a2e75540cdb90ccb602120826f9110f6e">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a61b2e5a218951d624bb6b5b15b296ece">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ab49babe71d4df98febb78597652c2f89">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a9ee91c75df168504aa7a009843134b2c">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a8227b56b7e3c7bb2e3c9db674c6c6c8e">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a69b3ffb8caf5f4d05ca8b348c94cc2fe">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a81512832dd397d69cb2faa08a1b24586">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a81512832dd397d69cb2faa08a1b24586">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, and <a class="el" href="classtatami_1_1ForcedDense.html#a672ee65e2556523857f27d4c2c83149c">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a168f0e932b5503c9bfc5dbd42754a7a5" name="a168f0e932b5503c9bfc5dbd42754a7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168f0e932b5503c9bfc5dbd42754a7a5">&#9670;&#160;</a></span>dense_row() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves all columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a3d6505ab08f36ab2e2487f7598a8df4e" name="a3d6505ab08f36ab2e2487f7598a8df4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6505ab08f36ab2e2487f7598a8df4e">&#9670;&#160;</a></span>dense_row() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves a contiguous block of columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a4b6f4909657d2e44196a56c99ffafb5c" name="a4b6f4909657d2e44196a56c99ffafb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6f4909657d2e44196a56c99ffafb5c">&#9670;&#160;</a></span>dense_row() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves an indexed subset of columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a563d877fa76c04d1faa039ebab88038c" name="a563d877fa76c04d1faa039ebab88038c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563d877fa76c04d1faa039ebab88038c">&#9670;&#160;</a></span>dense_row() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves an indexed subset of columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a48300b3739f26bb10732c572ea9e5c57" name="a48300b3739f26bb10732c572ea9e5c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48300b3739f26bb10732c572ea9e5c57">&#9670;&#160;</a></span>dense_column() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves all rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a9daf387535987b84f7b44c68fb664d33" name="a9daf387535987b84f7b44c68fb664d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9daf387535987b84f7b44c68fb664d33">&#9670;&#160;</a></span>dense_column() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves a contiguous block of rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a8ce124d5abc915f47e0abdec500b84f3" name="a8ce124d5abc915f47e0abdec500b84f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce124d5abc915f47e0abdec500b84f3">&#9670;&#160;</a></span>dense_column() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves an indexed subset of rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ace58cae1956cbf7474aa7120e0d89cc9" name="ace58cae1956cbf7474aa7120e0d89cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace58cae1956cbf7474aa7120e0d89cc9">&#9670;&#160;</a></span>dense_column() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves an indexed subset of rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a4d572f319b614a7e74d426cac94194de" name="a4d572f319b614a7e74d426cac94194de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d572f319b614a7e74d426cac94194de">&#9670;&#160;</a></span>dense_row() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="aacb45e8a21e1792a316fa95064edb9c2" name="aacb45e8a21e1792a316fa95064edb9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb45e8a21e1792a316fa95064edb9c2">&#9670;&#160;</a></span>dense_row() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a371fa940bc33a019b1f6938c2b06201f" name="a371fa940bc33a019b1f6938c2b06201f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371fa940bc33a019b1f6938c2b06201f">&#9670;&#160;</a></span>dense_row() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. This should be non-NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a3f3692e08db0886e4e866e28942d46b0" name="a3f3692e08db0886e4e866e28942d46b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3692e08db0886e4e866e28942d46b0">&#9670;&#160;</a></span>dense_row() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="aa2dad77430f29f277f73028c7c2636e2" name="aa2dad77430f29f277f73028c7c2636e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2dad77430f29f277f73028c7c2636e2">&#9670;&#160;</a></span>dense_column() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a478f96c3a39b40a950dda3d115365c89" name="a478f96c3a39b40a950dda3d115365c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478f96c3a39b40a950dda3d115365c89">&#9670;&#160;</a></span>dense_column() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a9058c33bd860936d0a6fe4f03397f6b9" name="a9058c33bd860936d0a6fe4f03397f6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9058c33bd860936d0a6fe4f03397f6b9">&#9670;&#160;</a></span>dense_column() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should be non-NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Obejct for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a7b82bffd2c71c4301867e8a0ffcf37f3" name="a7b82bffd2c71c4301867e8a0ffcf37f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b82bffd2c71c4301867e8a0ffcf37f3">&#9670;&#160;</a></span>dense_column() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Obejct for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="af84772cc4e911a87948d45a1edcabbd0" name="af84772cc4e911a87948d45a1edcabbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84772cc4e911a87948d45a1edcabbd0">&#9670;&#160;</a></span>sparse() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an extractor that retrieves the full extent of the non-target dimension in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row (if <code>row = true</code>) or columns (otherwise) in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6fd9ff6d1468c07246cf062c8e9d0c50">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a6fd9ff6d1468c07246cf062c8e9d0c50">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#a0f9d139c416d13d7027b2ebbf39380a4">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#ae36a0829fd0d12efb1d8d2d8dfe9f457">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#ade942a244f8db7a82634c2631ba54f99">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ac51543fbf0d45cdf2aeae2b720169d3b">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a441d7c76e928c0e0a1d976dabaaa801d">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a18c45d6a10e94685b20a52a516a80682">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a74eccdb531e731223b2115fa79c5bd9c">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#af48e72efa57b60adaf08ab668d3add22">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ad14fd5ad0c13ece4cca9111373ebd02f">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#ae3e8d818aad7e6e656e1b5e04b402b94">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a666c6b7a4db0d5b0ec961807be5ddefc">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a666c6b7a4db0d5b0ec961807be5ddefc">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, and <a class="el" href="classtatami_1_1ForcedDense.html#ab8d800ba1d79526b01cef67300232750">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="af802c74c510eff3316ce0eea99c08810" name="af802c74c510eff3316ce0eea99c08810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af802c74c510eff3316ce0eea99c08810">&#9670;&#160;</a></span>sparse() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an extractor that retrieves a contiguous block of the non-target dimension in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column (if <code>row = true</code>) or row (otherwise) at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns (if <code>row = true</code>) or rows (otherwise) in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row (if <code>row = true</code>) or column (otherwise) in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a3a90a3fac283f8d2240ba1a3f486d9fa">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a3a90a3fac283f8d2240ba1a3f486d9fa">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#a221e595b61973b199f9e4de185cd8e13">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a5ee5bedb48d14fd1dc1aa3d3ddf5214f">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#aee8c5bfc02315fdc9413ad89f4976b80">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a852718d8ff5a309f9d295cbae90370c3">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#aa4e00eee6ae2f0ef1b7b62aaa8ff35f2">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#aabaddff3481106dddbd543f4c6111f24">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a579a52f3e832f2b3facf8545f7e617f6">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a514ba8d6cc1a005b392b395db9677bf6">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#afacebd202c39aa6cf93c62d0a9eea7dd">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a3446248df0cd6be60fbd22425b41adce">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a2b3ae6fadc79c417bcc4154feffb957e">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a2b3ae6fadc79c417bcc4154feffb957e">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, and <a class="el" href="classtatami_1_1ForcedDense.html#aa3cb4538cb4872cec3c653eea6372174">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a59d055aed809a2036c10c1fce92bd036" name="a59d055aed809a2036c10c1fce92bd036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d055aed809a2036c10c1fce92bd036">&#9670;&#160;</a></span>sparse() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an extractor that retrieves an indexed subset of the non-target dimension in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices (if <code>row = true</code>) or row indices (otherwise). This should be non-NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row (if <code>row = true</code>) or column (otherwise) in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a96938d40042c82ea564d4d2b1b8bac6d">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a96938d40042c82ea564d4d2b1b8bac6d">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#a1b0128f5b2970d2cfc17b02eeea5726d">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a43dedaac4cc9f3149908f1b4cf66c994">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a0ca9cd323202099ff27ffbefd4f1a4cf">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a49feb63ad48bb794087a4bc4d9a1ec11">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#aa9482e05d62e1da59d893e935ccbbcd8">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#adc6cd7ab1963921e312e5f606a5014ed">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ab876debc02879ed4192104f0f4aea8a7">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#ab72ee704a24ff415d03f0628afe947a9">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#ab7e72a14fa186db4a0f10e22b49bb4e5">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a035758287b15a36991b06d4ae08b1a21">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#aa2de91f4b3aaff378ac5826280d72a3a">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#aa2de91f4b3aaff378ac5826280d72a3a">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, and <a class="el" href="classtatami_1_1ForcedDense.html#a859dc577dbd11873b5812dea928e9a3d">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="afcb3651992dff44cdf8d560a527707f6" name="afcb3651992dff44cdf8d560a527707f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb3651992dff44cdf8d560a527707f6">&#9670;&#160;</a></span>sparse_row() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves all columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ada39dd5987e82eb0aa50c302ee3ed564" name="ada39dd5987e82eb0aa50c302ee3ed564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada39dd5987e82eb0aa50c302ee3ed564">&#9670;&#160;</a></span>sparse_row() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves a contiguous block of columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ac64a711a19ebc55da7b5fdc193db839c" name="ac64a711a19ebc55da7b5fdc193db839c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64a711a19ebc55da7b5fdc193db839c">&#9670;&#160;</a></span>sparse_row() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves an indexed subset of columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="afb26d2551fec7753001e8c274c9661de" name="afb26d2551fec7753001e8c274c9661de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb26d2551fec7753001e8c274c9661de">&#9670;&#160;</a></span>sparse_row() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a row-wise extractor that retrieves an indexed subset of columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="aed47eef4ab4a6563db02acc77e22e5eb" name="aed47eef4ab4a6563db02acc77e22e5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed47eef4ab4a6563db02acc77e22e5eb">&#9670;&#160;</a></span>sparse_column() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves all rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ad45028c0259b57630cdc23e4f3d08835" name="ad45028c0259b57630cdc23e4f3d08835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45028c0259b57630cdc23e4f3d08835">&#9670;&#160;</a></span>sparse_column() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves a contiguous block of rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a9f340c985ed28a230745d87c9cd6ac44" name="a9f340c985ed28a230745d87c9cd6ac44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f340c985ed28a230745d87c9cd6ac44">&#9670;&#160;</a></span>sparse_column() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves an indexed subset of rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a518b8f184afb562e8ef722c2feef0875" name="a518b8f184afb562e8ef722c2feef0875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518b8f184afb562e8ef722c2feef0875">&#9670;&#160;</a></span>sparse_column() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column-wise extractor that retrieves an indexed subset of rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="aedecd4c23762ff43f49cfb0d2c687056" name="aedecd4c23762ff43f49cfb0d2c687056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedecd4c23762ff43f49cfb0d2c687056">&#9670;&#160;</a></span>sparse_row() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ad2aecb2560e570ec8f6e3efb0eddf55d" name="ad2aecb2560e570ec8f6e3efb0eddf55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2aecb2560e570ec8f6e3efb0eddf55d">&#9670;&#160;</a></span>sparse_row() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="acbe0fed52aae518a420114727e1c98a1" name="acbe0fed52aae518a420114727e1c98a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe0fed52aae518a420114727e1c98a1">&#9670;&#160;</a></span>sparse_row() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. This should not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a3011f5e2ee8103fcc4c6488bfd228997" name="a3011f5e2ee8103fcc4c6488bfd228997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3011f5e2ee8103fcc4c6488bfd228997">&#9670;&#160;</a></span>sparse_row() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ab0efad968be5f4b9a36bb50beb8460f8" name="ab0efad968be5f4b9a36bb50beb8460f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0efad968be5f4b9a36bb50beb8460f8">&#9670;&#160;</a></span>sparse_column() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a51f592922949fc50786de3eb6f58d0be" name="a51f592922949fc50786de3eb6f58d0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f592922949fc50786de3eb6f58d0be">&#9670;&#160;</a></span>sparse_column() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="adfb6b4e90e3ab5cf0112e7cbd31f18f4" name="adfb6b4e90e3ab5cf0112e7cbd31f18f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb6b4e90e3ab5cf0112e7cbd31f18f4">&#9670;&#160;</a></span>sparse_column() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="aebbd197a7d1530397cff04660e78f28f" name="aebbd197a7d1530397cff04660e78f28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbd197a7d1530397cff04660e78f28f">&#9670;&#160;</a></span>sparse_column() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a6502fdebcaeea40490c1780ab6e92b19" name="a6502fdebcaeea40490c1780ab6e92b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6502fdebcaeea40490c1780ab6e92b19">&#9670;&#160;</a></span>dense() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware extractor that retrieves the full extent of the non-target dimension in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying predictions of the next requested row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row (if <code>row = true)</code> or columns (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ac4012f0a18d6901373885988e53de0fd">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#ac4012f0a18d6901373885988e53de0fd">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#a2d8dd93d46bfa72f86d3438b279b053e">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a006be0d69613197a1808f229d9035e1b">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#ab374f02f10e38234c6c40caaeb997217">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a7823faa7848b1fabe7cf381a718d8927">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a4d8126a072d762e9fcf1cf97159c5294">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#af120e36bec4dca4ec3e7c1e059b42854">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a8aa8d98ddd30849bc15368a2d728b399">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#afae19c322db77e87856c4ad42a54cdb7">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a9a8c98cec2a92521883a885f426952aa">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a5942506c6d3f0f782fbdb14d1626a83d">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a2f9380bab038b422d68fde0633954e1d">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#add05c0873cde2018594166f1ec797a66">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#add05c0873cde2018594166f1ec797a66">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#a261dfe07d33d275b38e5bf00769207cc">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#ab179019a74b0b7ae15a4422d5cbb8512">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#ab179019a74b0b7ae15a4422d5cbb8512">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="a48b24fe319289ca76f2b366a2ffe798d" name="a48b24fe319289ca76f2b366a2ffe798d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b24fe319289ca76f2b366a2ffe798d">&#9670;&#160;</a></span>dense() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware extractor that retrieves a contiguous block of the non-target dimension in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying predictions of the next requested row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column (if <code>row = true</code>) or row (otherwise) at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns (if <code>row = true</code>) or rows (otherwise) in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row (if <code>row = true</code>) or column (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a576f1ca185646807b21e327cb11b9802">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a576f1ca185646807b21e327cb11b9802">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#aa3f9a37d162fabc66187544e0b7b8373">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#aea7a24c6dcb952714868ed3640b5fd71">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#afc9afb637e9093a99c7762cf8e5a7d01">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#ab08def21b28eb76e7b956713b16fb52f">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#ab09a18a380570b5e039692b221c568dc">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a0de184e6686b0f5869bdc3ce506fa49a">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a8d8c0420f5b8e75f814caaeb24facaa6">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a09c8338b237aa6912e0508ce79128485">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a64c284c2b4bffbb4f502cc5265470761">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#af91b8dff052e26a2a8f560c7dd184d5f">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#ad3a73ccdc14cfffec841b6b298fca9b1">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a9d7e3e88f64da15d547206947930a5bd">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a9d7e3e88f64da15d547206947930a5bd">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#ae7d7d789f19bcedf0c6c205c1fd5f352">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a927624b2f520d71741fbeeb9225b057c">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a927624b2f520d71741fbeeb9225b057c">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="a4aecaa5038554d2c92c2ab7083497cb6" name="a4aecaa5038554d2c92c2ab7083497cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aecaa5038554d2c92c2ab7083497cb6">&#9670;&#160;</a></span>dense() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware extractor that retrieves an indexed subset of the non-target dimension in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying predictions of the next requested row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices (if <code>row = true</code>) or row indices (otherwise). This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row (if <code>row = true</code>) or column (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a61a45fd05930998cbe955d0158f41e7e">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a61a45fd05930998cbe955d0158f41e7e">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#ac017cd4c8ba6e77cd25477fa95c13d3d">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a22c37eaa1cbff552f9cf307711ecd60e">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBind.html#a121d4c98b9138ac176641de8b7c48540">tatami::DelayedBind&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a39073930eb471dc96e98c5a0c66addc8">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a9aa75bfd95a56ba4eda2c14115c676f5">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a77573ded69e92e687744e6bc7ae07d96">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#afb78cc507a2fe5ab8f1fc91aae26ed12">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#ac6ea294be3a0bdc3c743dca3a449175f">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a9c2d0d750097ccf193612c20674541ab">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a7543a9711d83ea75cd6317160b727590">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#aad12817b9ad1bec205baf50263b633e6">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a3524d4a0a7b950d65d402fd50629ecc0">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a3524d4a0a7b950d65d402fd50629ecc0">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#a788e88e726741ae9ba9398d90432274c">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a39c911d6d93fe5739a753a3141e6d12b">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a39c911d6d93fe5739a753a3141e6d12b">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="aa60952db300c69580a9eba01b5f787d6" name="aa60952db300c69580a9eba01b5f787d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60952db300c69580a9eba01b5f787d6">&#9670;&#160;</a></span>dense_row() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves all columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="acc57cd1f625bdc44af4946a0124f7464" name="acc57cd1f625bdc44af4946a0124f7464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc57cd1f625bdc44af4946a0124f7464">&#9670;&#160;</a></span>dense_row() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves a contiguous block of columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ab247d39db776da3e2143f4599f76920e" name="ab247d39db776da3e2143f4599f76920e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab247d39db776da3e2143f4599f76920e">&#9670;&#160;</a></span>dense_row() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves an indexed subset of columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ad8f53f2f7b2a2e5972a91a56065ba28b" name="ad8f53f2f7b2a2e5972a91a56065ba28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f53f2f7b2a2e5972a91a56065ba28b">&#9670;&#160;</a></span>dense_row() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves an indexed subset of columns in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a8ca1e41bc821f551d76175687fd2e6b5" name="a8ca1e41bc821f551d76175687fd2e6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca1e41bc821f551d76175687fd2e6b5">&#9670;&#160;</a></span>dense_column() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves all rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a2323a04228d638ec0340036acafa420f" name="a2323a04228d638ec0340036acafa420f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2323a04228d638ec0340036acafa420f">&#9670;&#160;</a></span>dense_column() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves a contiguous block of rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a8d717304d7cf4806c182ecd446de144d" name="a8d717304d7cf4806c182ecd446de144d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d717304d7cf4806c182ecd446de144d">&#9670;&#160;</a></span>dense_column() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves an indexed subset of rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a585337cdd3a90c5cf6cf2fdca2b43e84" name="a585337cdd3a90c5cf6cf2fdca2b43e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585337cdd3a90c5cf6cf2fdca2b43e84">&#9670;&#160;</a></span>dense_column() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves an indexed subset of rows in dense form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a9fb2b21aad79130762a8cb0c7069d3a3" name="a9fb2b21aad79130762a8cb0c7069d3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb2b21aad79130762a8cb0c7069d3a3">&#9670;&#160;</a></span>dense_row() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a2cecc240982c961455ede8d329cda207" name="a2cecc240982c961455ede8d329cda207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cecc240982c961455ede8d329cda207">&#9670;&#160;</a></span>dense_row() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a32275c6bf6553d6b1833abdce9165b5d" name="a32275c6bf6553d6b1833abdce9165b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32275c6bf6553d6b1833abdce9165b5d">&#9670;&#160;</a></span>dense_row() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a6ce58d2a5e7b244b49a97cabff56c94b" name="a6ce58d2a5e7b244b49a97cabff56c94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce58d2a5e7b244b49a97cabff56c94b">&#9670;&#160;</a></span>dense_row() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a4d572f319b614a7e74d426cac94194de">dense_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a068863a2b525300afb446aa249f67f6b" name="a068863a2b525300afb446aa249f67f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068863a2b525300afb446aa249f67f6b">&#9670;&#160;</a></span>dense_column() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a3a9d3994a74ebdf26894d92ad3625d8c" name="a3a9d3994a74ebdf26894d92ad3625d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9d3994a74ebdf26894d92ad3625d8c">&#9670;&#160;</a></span>dense_column() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a3d214b599712ab2f265b06d45d9e7047" name="a3d214b599712ab2f265b06d45d9e7047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d214b599712ab2f265b06d45d9e7047">&#9670;&#160;</a></span>dense_column() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a6421e936b7d10b2dee56c41c6591322e" name="a6421e936b7d10b2dee56c41c6591322e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6421e936b7d10b2dee56c41c6591322e">&#9670;&#160;</a></span>dense_column() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::dense_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aa2dad77430f29f277f73028c7c2636e2">dense_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a5605c18620abdab0f82015b959e9813a" name="a5605c18620abdab0f82015b959e9813a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5605c18620abdab0f82015b959e9813a">&#9670;&#160;</a></span>sparse() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware extractor that retrieves the full extent of the non-target dimension in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying predictions of the next requested row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row (if <code>row = true)</code> or columns (otherwise) in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a1e93f3c596fcab8807b20b8818c9ee05">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a1e93f3c596fcab8807b20b8818c9ee05">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#a870f80a58164f95776ae992c2f4b2014">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a1979758f822e331e1debd311edd7ac78">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a77818881db7c87e9a1f9772a6624d7ce">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a984c446f6c5a58128a30e5d13e64f61a">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#ac7a9648c22403d9b505ad34b4f32cc4c">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a05c59fb88a92b16f41984dec3dc97608">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#a697a75ec36f3ca871d37242e5ebdefb5">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a60d0ab0f4cc76d61190bfa02c6252858">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a8ac7aaeaa0fade4978719c6c25a41884">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a6d33ffe98441e4d04d70f52e49f115fc">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a62a8fe8c7610bfcc51687e61e0e7a4a0">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a62a8fe8c7610bfcc51687e61e0e7a4a0">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#a8db4976771ac39cedd50a55fe1fce265">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a0ee38f8591689b3dd787382f7234caf1">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a0ee38f8591689b3dd787382f7234caf1">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="aacfcf54358970874051e5cc700730707" name="aacfcf54358970874051e5cc700730707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfcf54358970874051e5cc700730707">&#9670;&#160;</a></span>sparse() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware extractor that retrieves a contiguous block of the non-target dimension in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying predictions of the next requested row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column (if <code>row = true</code>) or row (otherwise) at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns (if <code>row = true</code>) or rows (otherwise) in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row (if <code>row = true</code>) or column (otherwise) in dense form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a777b0c9055bfe87e5cbcf842b07762e5">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a777b0c9055bfe87e5cbcf842b07762e5">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#a6bda17724377a7e9ad0d221aa72ee593">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a4ce65de6965b619e5efd06bbec02b3cc">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a0127dd049f54f1251672105fdd646e40">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#a9d1de3f6079a61a923ed1689aa5df4be">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a5893399067e5cce519cdd2758b3f55c1">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#a1d6e021d8b380102ebab4f7f1f616797">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#addf2fffc5bc1921568e19a6f31c1820e">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#af255485c7e9bf137b613b1c29d6f7327">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a635d1f9ad60696b126faa6a1f276a619">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#aeb8e6a2b8e69ea8ca9fd1c05730dcccd">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#aa91c7e053ec10f2151a4854b2e680d8c">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#aa91c7e053ec10f2151a4854b2e680d8c">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#a8f3214f96a9f8ace80dd4d8c7aa7fac2">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a807e5bd3ebd1e2995f84354461bc0664">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a807e5bd3ebd1e2995f84354461bc0664">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="abe7557a27bbb09f8453a3e6848ad910e" name="abe7557a27bbb09f8453a3e6848ad910e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7557a27bbb09f8453a3e6848ad910e">&#9670;&#160;</a></span>sparse() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware extractor that retrieves an indexed subset of the non-target dimension in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying predictions of the next requested row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices (if <code>row = true</code>) or row indices (otherwise). This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row (if <code>row = true</code>) or column (otherwise) in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a1205fb73d187bcd1ae7b6a3606307806">tatami::CompressedSparseMatrix&lt; Value_, Index_, ValueStorage_, IndexStorage_, PointerStorage_ &gt;</a>, <a class="el" href="classtatami_1_1CompressedSparseMatrix.html#a1205fb73d187bcd1ae7b6a3606307806">tatami::CompressedSparseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt;, std::vector&lt; Index_ &gt;, std::vector&lt; std::size_t &gt; &gt;</a>, <a class="el" href="classtatami_1_1ConstantMatrix.html#aa2a1aa8eaa905723c9c59a9d9813daa2">tatami::ConstantMatrix&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html#a1c8a64ab65e1c5090ec021d557c30522">tatami::DelayedBinaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedCast.html#a2b73ae28df6098db004a78b639896ba8">tatami::DelayedCast&lt; ValueOut_, IndexOut_, ValueIn_, IndexIn_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubset.html#acd8e28ca34b3a4e7f86980f8d90eb410">tatami::DelayedSubset&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetBlock.html#a59d06483090b55e31b040c6e8407f418">tatami::DelayedSubsetBlock&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSorted.html#aebb7f8718866c2ace957d5886447c8c6">tatami::DelayedSubsetSorted&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html#af1259cb98d963994b35e03c589ea2cb4">tatami::DelayedSubsetSortedUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedSubsetUnique.html#a8e531f6ed4dd46031fb7ad530c9ba618">tatami::DelayedSubsetUnique&lt; Value_, Index_, SubsetStorage_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedTranspose.html#a6fe8ef27e3459a132dc53f76a88be4b7">tatami::DelayedTranspose&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html#a6b963da0f01ef7515e7d2a8836ad464a">tatami::DelayedUnaryIsometricOperation&lt; OutputValue_, InputValue_, Index_, Helper_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a02516af1a7b8e4953c001b2c173048a7">tatami::DenseMatrix&lt; Value_, Index_, Storage_ &gt;</a>, <a class="el" href="classtatami_1_1DenseMatrix.html#a02516af1a7b8e4953c001b2c173048a7">tatami::DenseMatrix&lt; Value_, Index_, std::vector&lt; Value_ &gt; &gt;</a>, <a class="el" href="classtatami_1_1ForcedDense.html#a997a50a188540b2e1f92a2905ce3e725">tatami::ForcedDense&lt; Value_, Index_ &gt;</a>, <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a6c63dc6dda894c284385f7ea2d4d239a">tatami::FragmentedSparseMatrix&lt; Value_, Index_, ValueVectorStorage_, IndexVectorStorage_ &gt;</a>, and <a class="el" href="classtatami_1_1FragmentedSparseMatrix.html#a6c63dc6dda894c284385f7ea2d4d239a">tatami::FragmentedSparseMatrix&lt; Value_, Index_, std::vector&lt; std::vector&lt; Value_ &gt; &gt;, std::vector&lt; std::vector&lt; Index_ &gt; &gt; &gt;</a>.</p>

</div>
</div>
<a id="a9914398b94a1a9f3082478d9646fc21d" name="a9914398b94a1a9f3082478d9646fc21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9914398b94a1a9f3082478d9646fc21d">&#9670;&#160;</a></span>sparse_row() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves all columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="af67262da7611609ba28f9ac1d9ed20e9" name="af67262da7611609ba28f9ac1d9ed20e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67262da7611609ba28f9ac1d9ed20e9">&#9670;&#160;</a></span>sparse_row() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves a contiguous block of columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="af86c164710f168484a0037169bf51622" name="af86c164710f168484a0037169bf51622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86c164710f168484a0037169bf51622">&#9670;&#160;</a></span>sparse_row() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves an indexed subset of columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a47155bacf33f5c269c8da4ce96d1adb8" name="a47155bacf33f5c269c8da4ce96d1adb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47155bacf33f5c269c8da4ce96d1adb8">&#9670;&#160;</a></span>sparse_row() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware row-wise extractor that retrieves an indexed subset of columns in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a25ce6f1c8ad4f4d2e8d62c8e005c7df8" name="a25ce6f1c8ad4f4d2e8d62c8e005c7df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ce6f1c8ad4f4d2e8d62c8e005c7df8">&#9670;&#160;</a></span>sparse_column() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves all rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a576f3bd09c075d59101e561c715c82e2" name="a576f3bd09c075d59101e561c715c82e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576f3bd09c075d59101e561c715c82e2">&#9670;&#160;</a></span>sparse_column() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves a contiguous block of rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a413c72fd73b8e156f3b2fb3f8ebd2497" name="a413c72fd73b8e156f3b2fb3f8ebd2497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413c72fd73b8e156f3b2fb3f8ebd2497">&#9670;&#160;</a></span>sparse_column() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves an indexed subset of rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. This should not be NULL. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="acfbdd5c72c285b22942ce2714874b810" name="acfbdd5c72c285b22942ce2714874b810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbdd5c72c285b22942ce2714874b810">&#9670;&#160;</a></span>sparse_column() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1Options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an oracle-aware column-wise extractor that retrieves an indexed subset of rows in sparse form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">opt</td><td><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for extraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ac69c3729445a087b33bfa9717b8e0bd1" name="ac69c3729445a087b33bfa9717b8e0bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69c3729445a087b33bfa9717b8e0bd1">&#9670;&#160;</a></span>sparse_row() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ae052d20e59e1cd0c58915f1165c42b44" name="ae052d20e59e1cd0c58915f1165c42b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae052d20e59e1cd0c58915f1165c42b44">&#9670;&#160;</a></span>sparse_row() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the column at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of columns in the block. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a3fc1dfadd943138f21cf3e9dd1f89147" name="a3fc1dfadd943138f21cf3e9dd1f89147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc1dfadd943138f21cf3e9dd1f89147">&#9670;&#160;</a></span>sparse_row() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a59f8dbf2064d74038813b5c0191a6542" name="a59f8dbf2064d74038813b5c0191a6542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f8dbf2064d74038813b5c0191a6542">&#9670;&#160;</a></span>sparse_row() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_row </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aedecd4c23762ff43f49cfb0d2c687056">sparse_row()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying row predictions. </td></tr>
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each row in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a8274ac6fb2345fcece74e6fdb35e05d4" name="a8274ac6fb2345fcece74e6fdb35e05d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8274ac6fb2345fcece74e6fdb35e05d4">&#9670;&#160;</a></span>sparse_column() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a9538dcc44c008dd203e719a855ac7fca" name="a9538dcc44c008dd203e719a855ac7fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9538dcc44c008dd203e719a855ac7fca">&#9670;&#160;</a></span>sparse_column() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>block_length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_start</td><td>Index of the row at the start of the block. </td></tr>
    <tr><td class="paramname">block_length</td><td>Number of rows in the block. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting a contiguous block from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="a917f575b5430e14e2ccda56a5b6903be" name="a917f575b5430e14e2ccda56a5b6903be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917f575b5430e14e2ccda56a5b6903be">&#9670;&#160;</a></span>sparse_column() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetatami.html#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices_ptr</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices_ptr</td><td>Pointer to a vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<a id="ad3c6514d93279e77fb8505d29c334217" name="ad3c6514d93279e77fb8505d29c334217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c6514d93279e77fb8505d29c334217">&#9670;&#160;</a></span>sparse_column() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt; Value_, Index_ &gt; &gt; <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt;::sparse_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt; Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ab0efad968be5f4b9a36bb50beb8460f8">sparse_column()</a></code> that uses the default options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of sorted and unique row indices. </td></tr>
    <tr><td class="paramname">oracle</td><td>An oracle supplying column predictions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object for extracting an indexed subset from each column in sparse form. This should not outlive the parent <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> from which it was created. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami/base/<a class="el" href="Matrix_8hpp_source.html">Matrix.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
