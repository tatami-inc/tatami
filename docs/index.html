<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: A C++ API for all sorts of matrices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">A C++ API for all sorts of matrices </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2github_2workspace_2README"></a></p>
<p><img src="https://github.com/tatami-inc/tatami/actions/workflows/run-tests.yaml/badge.svg" alt="Unit tests" style="pointer-events: none;" class="inline"/> <img src="https://github.com/tatami-inc/tatami/actions/workflows/doxygenate.yaml/badge.svg" alt="Documentation" style="pointer-events: none;" class="inline"/> <a href="https://codecov.io/gh/tatami-inc/tatami"><img src="https://codecov.io/gh/tatami-inc/tatami/branch/master/graph/badge.svg?token=Z189ORCLLR" alt="Codecov" style="pointer-events: none;" class="inline"/></a></p>
<h1>Overview</h1>
<p><b>tatami</b> is a spiritual successor to the <a href="https://github.com/tatami-inc/beachmat"><b>beachmat</b> C++ API</a> that provides read access to different matrix representations. Specifically, applications can use <b>tatami</b> to read rows and/or columns of a matrix without any knowledge of the specific matrix representation. This allows application developers to write a single piece of code that will work seamlessly with different inputs, even if the underlying representation varies at run-time. In particular, <b>tatami</b> is motivated by analyses of processed genomics data, where matrices are often interpreted as a collection of row- or column-wise vectors. Many applications involve looping over rows or columns to compute some statistic or summary - for example, testing for differential expression within each row of the matrix. <b>tatami</b> aims to optimize this access pattern across a variety of different matrix representations, depending on how the data is provided to the application.</p>
<h1>Quick start</h1>
<p><b>tatami</b> is a header-only library, so it can be easily used by just <code>#include</code>ing the relevant source files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tatami_8hpp.html">tatami/tatami.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> nrows = 10;</div>
<div class="line"><span class="keywordtype">int</span> ncols = 20;</div>
<div class="line">std::vector&lt;double&gt; vals(nrows * ncols);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// &#39;double&#39; is the data type, &#39;int&#39; is the row/column index type.</span></div>
<div class="line">std::shared_ptr&lt;tatami::Matrix&lt;double, int&gt; &gt; mat(</div>
<div class="line">    <span class="keyword">new</span> <a class="code hl_class" href="classtatami_1_1DenseMatrix.html">tatami::DenseMatrix</a>&lt;<span class="keywordtype">double</span>, <span class="keywordtype">int</span>, std::vector&lt;double&gt; &gt;(</div>
<div class="line">        nrows,</div>
<div class="line">        ncols,</div>
<div class="line">        vals,</div>
<div class="line">        <span class="comment">/* row_major = */</span> <span class="keyword">true</span></div>
<div class="line">    )</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the dimensions:</span></div>
<div class="line"><span class="keywordtype">int</span> NR = mat-&gt;nrow(), NC = mat-&gt;ncol();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extract the &#39;i&#39;-th column.</span></div>
<div class="line"><span class="keyword">auto</span> extractor = mat-&gt;dense_column();</div>
<div class="line">std::vector&lt;double&gt; buffer(NR);</div>
<div class="line"><span class="keyword">auto</span> ptr = extractor-&gt;fetch(i, buffer.data());</div>
<div class="line">ptr[0]; </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extract the [5, 12) rows of the &#39;i&#39;-th column.</span></div>
<div class="line"><span class="keyword">auto</span> sliced_extractor = mat-&gt;dense_column(5, 7)</div>
<div class="line"><span class="keyword">auto</span> sliced_ptr = sliced_extractor-&gt;fetch(i, buffer.data());</div>
<div class="ttc" id="aclasstatami_1_1DenseMatrix_html"><div class="ttname"><a href="classtatami_1_1DenseMatrix.html">tatami::DenseMatrix</a></div><div class="ttdoc">Dense matrix representation.</div><div class="ttdef"><b>Definition</b> DenseMatrix.hpp:172</div></div>
<div class="ttc" id="atatami_8hpp_html"><div class="ttname"><a href="tatami_8hpp.html">tatami.hpp</a></div><div class="ttdoc">Flexible representations of matrix data.</div></div>
</div><!-- fragment --><p>The key idea here is that, once <code>mat</code> is created, the application does not need to worry about the exact format of the matrix referenced by the pointer. Application developers can write code that works interchangeably with a variety of different matrix representations.</p>
<h1>Instructions</h1>
<h2>Creating a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code></h2>
<p>Users can create an instance of a concrete <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code> subclass by using one of the constructors or the equivalent <code>make_*</code> utility:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Class    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Dense matrix   </td><td class="markdownTableBodyNone"><code>DenseMatrix</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Compressed sparse matrix   </td><td class="markdownTableBodyNone"><code>CompressedSparseMatrix</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">List of lists sparse matrix   </td><td class="markdownTableBodyNone"><code>FragmentedSparseMatrix</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Delayed isometric unary operation   </td><td class="markdownTableBodyNone"><code>DelayedUnaryIsometricOperation</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Delayed isometric binary operation   </td><td class="markdownTableBodyNone"><code>DelayedBinaryIsometricOperation</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Delayed combination   </td><td class="markdownTableBodyNone"><code>DelayedBind</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Delayed subset   </td><td class="markdownTableBodyNone"><code>DelayedSubset</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Delayed transpose   </td><td class="markdownTableBodyNone"><code>DelayedTranspose</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Delayed cast   </td><td class="markdownTableBodyNone"><code>DelayedCast</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Delayed cast   </td><td class="markdownTableBodyNone"><code>DelayedCast</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Constant matrix   </td><td class="markdownTableBodyNone"><code>ConstantMatrix</code>   </td></tr>
</table>
<p>For example, to create a compressed sparse matrix from sparse triplet data, we could do:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="tatami_8hpp.html">tatami/tatami.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> NROW = 10, NCOL = 20;</div>
<div class="line">std::vector&lt;double&gt; x; <span class="comment">// vector of non-zero values.</span></div>
<div class="line">std::vector&lt;int&gt; i; <span class="comment">// row indices of length equal to &#39;x&#39;.</span></div>
<div class="line">std::vector&lt;int&gt; j; <span class="comment">// column indices of length equal to &#39;x&#39;.</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> indptrs = <a class="code hl_function" href="namespacetatami.html#abb624f8a5bc844d3e902cde63b84001f">tatami::compress_sparse_triplets</a>(NROW, NCOL, x, i, j, <span class="comment">/* csr = */</span> <span class="keyword">false</span>);</div>
<div class="line">std::shared_ptr&lt;tatami::Matrix&lt;double, int&gt; &gt; smat(</div>
<div class="line">    <span class="keyword">new</span> <a class="code hl_class" href="classtatami_1_1CompressedSparseMatrix.html">tatami::CompressedSparseMatrix</a>&lt;</div>
<div class="line">        <span class="keywordtype">double</span>, <span class="comment">// data type</span></div>
<div class="line">        <span class="keywordtype">int</span>, <span class="comment">// index type</span></div>
<div class="line">        std::vector&lt;double&gt;, <span class="comment">// type of &#39;x&#39;</span></div>
<div class="line">        std::vector&lt;int&gt;, <span class="comment">// type of the row indices &#39;i&#39;</span></div>
<div class="line">        std::vector&lt;size_t&gt; <span class="comment">// type of the pointers &#39;indptrs&#39;</span></div>
<div class="line">    &gt;(</div>
<div class="line">        NR, </div>
<div class="line">        NC, </div>
<div class="line">        std::move(x), </div>
<div class="line">        std::move(i), </div>
<div class="line">        std::move(indptrs),</div>
<div class="line">        <span class="comment">/* csr = */</span> <span class="keyword">false</span></div>
<div class="line">    )</div>
<div class="line">);</div>
<div class="ttc" id="aclasstatami_1_1CompressedSparseMatrix_html"><div class="ttname"><a href="classtatami_1_1CompressedSparseMatrix.html">tatami::CompressedSparseMatrix</a></div><div class="ttdoc">Compressed sparse matrix representation.</div><div class="ttdef"><b>Definition</b> CompressedSparseMatrix.hpp:581</div></div>
<div class="ttc" id="anamespacetatami_html_abb624f8a5bc844d3e902cde63b84001f"><div class="ttname"><a href="namespacetatami.html#abb624f8a5bc844d3e902cde63b84001f">tatami::compress_sparse_triplets</a></div><div class="ttdeci">std::vector&lt; Pointer_ &gt; compress_sparse_triplets(std::size_t num_primary, Values_ &amp;values, const PrimaryIndices_ &amp;primary_indices, SecondaryIndices_ &amp;secondary_indices)</div><div class="ttdef"><b>Definition</b> compress_sparse_triplets.hpp:123</div></div>
</div><!-- fragment --><p>We typically create a <code>shared_ptr</code> to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code> to leverage run-time polymorphism. This enables downstream applications to accept many different matrix representations by compiling against the <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code> interface. Alternatively, applications may use templating to achieve compile-time polymorphism on the different <b>tatami</b> subclasses, but this is rather restrictive without providing obvious performance benefits.</p>
<p>We use templating to define the type of values returned by the interface. This includes the type of the data (most typically <code>double</code>) as well as the type of row/column indices (default <code>int</code>, but one could imagine using, e.g., <code>size_t</code>). It is worth noting that the storage type does not need to be the same as the interface type. For example, developers could store a matrix of small counts as <code>uint16_t</code> while returning <code>double</code>s for compatibility with downstream mathematical code.</p>
<p>The delayed operations are ~stolen from~ inspired by those in the <a href="https://github.com/Bioconductor/DelayedArray"><b>DelayedArray</b></a> package. Isometric operations are particularly useful as they accommodate matrix-scalar/vector arithmetic and various mathematical operations. For example, we could apply a sparsity-breaking delayed operation to our sparse matrix <code>smat</code> without actually creating a dense matrix:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;tatami::Matrix&lt;double, int&gt; &gt; mat2(</div>
<div class="line">    <span class="keyword">new</span> <a class="code hl_class" href="classtatami_1_1DelayedUnaryIsometricOperation.html">tatami::DelayedUnaryIsometricOperation</a>&lt;</div>
<div class="line">        <span class="keywordtype">double</span>, <span class="comment">// type of the result of the operation </span></div>
<div class="line">        <span class="keywordtype">double</span>, <span class="comment">// type of the original matrix</span></div>
<div class="line">        <span class="keywordtype">int</span> <span class="comment">// row/column index type</span></div>
<div class="line">    &gt;(</div>
<div class="line">        smat, </div>
<div class="line">        std::make_shared&lt;</div>
<div class="line">            <a class="code hl_class" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">tatami::DelayedUnaryIsometricAddScalarHelper</a>&lt;</div>
<div class="line">                <span class="keywordtype">double</span>, <span class="comment">// type of the result of the operation</span></div>
<div class="line">                <span class="keywordtype">double</span>, <span class="comment">// type of the original matrix</span></div>
<div class="line">                <span class="keywordtype">int</span>, <span class="comment">// row/column index type</span></div>
<div class="line">                <span class="keywordtype">double</span> <span class="comment">// type of the scalar</span></div>
<div class="line">            &gt;</div>
<div class="line">        &gt;(2.0)</div>
<div class="line">    )</div>
<div class="line">);</div>
<div class="ttc" id="aclasstatami_1_1DelayedUnaryIsometricArithmeticScalarHelper_html"><div class="ttname"><a href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">tatami::DelayedUnaryIsometricArithmeticScalarHelper</a></div><div class="ttdoc">Helper for delayed unary isometric scalar arithmetic.</div><div class="ttdef"><b>Definition</b> arithmetic_helpers.hpp:93</div></div>
<div class="ttc" id="aclasstatami_1_1DelayedUnaryIsometricOperation_html"><div class="ttname"><a href="classtatami_1_1DelayedUnaryIsometricOperation.html">tatami::DelayedUnaryIsometricOperation</a></div><div class="ttdoc">Delayed isometric operation on a single matrix.</div><div class="ttdef"><b>Definition</b> DelayedUnaryIsometricOperation.hpp:674</div></div>
</div><!-- fragment --><p>Some libraries in the <a href="https://github.com/tatami-inc"><b>@tatami-inc</b></a> organization implement further extensions of <b>tatami</b>'s interface, e.g., for <a href="https://github.com/tatami-inc/tatami_hdf5">HDF5-backed matrices</a> and <a href="https://github.com/tatami-inc/tatami_r">R-based matrices</a>.</p>
<h2>Extracting matrix contents</h2>
<p>Given an abstract <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>, we create an <code>Extractor</code> instance to actually extract the matrix data. Each <code>Extractor</code> object can store intermediate data for re-use during iteration through the matrix, which is helpful for some matrix implementations that do not easily support random access. For example, to perform extract dense rows from our <code>mat</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> NR = mat-&gt;nrow();</div>
<div class="line"><span class="keywordtype">int</span> NC = mat-&gt;ncol();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> ext = mat-&gt;dense_row();</div>
<div class="line">std::vector&lt;double&gt; buffer(NC);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; NR; ++r) {</div>
<div class="line">    <span class="keyword">auto</span> current = ext-&gt;fetch(r, buffer.data());</div>
<div class="line">    <span class="comment">// Do something with the &#39;current&#39; pointer.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code><a class="el" href="classtatami_1_1MyopicDenseExtractor.html#a9f3ee9c959cdefdb45dcbcd607826a49">tatami::MyopicDenseExtractor::fetch()</a></code> method returns a pointer to the row's contents. In some matrix representations (e.g., <code>DenseMatrix</code>), the returned pointer directly refers to the matrix's internal data store. However, this is not the case in general so we need to allocate a buffer of appropriate length (<code>buffer</code>) in which the dense contents can be stored; if this buffer is used, the returned pointer refers to the start of the buffer.</p>
<p>Alternatively, we could extract sparse columns via <code><a class="el" href="classtatami_1_1MyopicSparseExtractor.html#ae545d22bfe3e3d90bc0ce50410fcfb9c">tatami::MyopicSparseExtractor::fetch()</a></code>, which returns a <code><a class="el" href="structtatami_1_1SparseRange.html" title="A range of a sparse vector.">tatami::SparseRange</a></code> containing pointers to arrays of (structurally non-zero) values and their row indices. This provides some opportunities for optimization in algorithms that only need to operate on non-zero values. The <code>fetch()</code> call requires buffers for both arrays - again, this may not be used for matrix subclasses with contiguous internal storage of the values/indices.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sext = mat-&gt;sparse_column();</div>
<div class="line">std::vector&lt;double&gt; vbuffer(NR);</div>
<div class="line">std::vector&lt;int&gt; ibuffer(NR);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; NC; ++c) {</div>
<div class="line">    <span class="keyword">auto</span> current = sext-&gt;fetch(c, vbuffer.data(), ibuffer.data());</div>
<div class="line">    current.number; <span class="comment">// Number of structural non-zeros</span></div>
<div class="line">    current.value; <span class="comment">// Pointer to the value array</span></div>
<div class="line">    current.index; <span class="comment">// Pointer to the index array</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In both the dense and sparse cases, we can restrict the values that are extracted by <code>fetch()</code>. This provides some opportunities for optimization by avoiding the unnecessary extraction of uninteresting data. To do so, we specify the start and length of a contiguous block of interest, or we supply a vector containing the indices of the elements of interest:</p>
<div class="fragment"><div class="line"><span class="comment">// Get rows [5, 17) from each column.</span></div>
<div class="line"><span class="keyword">auto</span> bext = mat-&gt;dense_column(5, 12); </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get these columns from each row.</span></div>
<div class="line"><span class="keyword">auto</span> iext = mat-&gt;sparse_row(std::vector&lt;int&gt;{ 1, 3, 5, 7 });</div>
</div><!-- fragment --><h2>Handling different access patterns</h2>
<p>In performance-critical sections, it may be desirable to customize the extraction based on properties of the matrix. This is supported with the following methods:</p>
<ul>
<li><code><a class="el" href="classtatami_1_1Matrix.html#ac57d65707ce22d8c175e43a82b8c6b90">tatami::Matrix::is_sparse()</a></code> indicates whether a matrix is sparse.</li>
<li><code><a class="el" href="classtatami_1_1Matrix.html#a69382d2a4e66cda1a9eb48dc25ab113a">tatami::Matrix::prefer_rows()</a></code> indicates whether a matrix is more efficiently accessed along its rows (e.g., row-major dense matrices).</li>
</ul>
<p>Users can then write dedicated code paths to take advantage of these properties. For example, we might use different algorithms for dense data, where we don't have to look up indices; and for sparse data, if we can avoid the uninteresting zero values. Similarly, if we want to compute a row-wise statistic, but the matrix is more efficiently accessed by column according to <code>prefer_rows()</code>, we could iterate on the columns and attempt to compute the statistic in a "running" manner (see <a href="https://github.com/tatami-inc/gallery/tree/master/src/colsums.cpp"><code>colsums.cpp</code></a> for an example). In the most complex cases, this leads to code like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (mat-&gt;is_sparse()) {</div>
<div class="line">    <span class="keywordflow">if</span> (mat-&gt;prefer_rows()) {</div>
<div class="line">        <span class="keyword">auto</span> sext = mat-&gt;sparse_row();</div>
<div class="line">        <span class="comment">// Do compute along sparse rows.</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keyword">auto</span> sext = mat-&gt;sparse_column();</div>
<div class="line">        <span class="comment">// Do compute along sparse columns.</span></div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">if</span> (mat-&gt;prefer_rows()) {</div>
<div class="line">        <span class="keyword">auto</span> sext = mat-&gt;dense_row();</div>
<div class="line">        <span class="comment">// Do compute along dense rows.</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keyword">auto</span> sext = mat-&gt;dense_column();</div>
<div class="line">        <span class="comment">// Do compute along dense columns.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Of course, this assumes that it is possible to provide sparse-specific optimizations as well as running calculations for the statistic of interest. In most cases, only a subset of the extraction patterns are actually feasible so special code paths would not be beneficial.</p>
<h2>Supporting parallelization</h2>
<p>The mutable nature of an <code>Extractor</code> instance means that the <code>fetch()</code> calls themselves are not <code>const</code>. This means that the same extractor cannot be safely re-used across different threads as each call to <code>fetch()</code> will modify the extractor's contents. Fortunately, the solution is simple - just create a separate <code>Extractor</code> (and the associated buffers) for each thread. With OpenMP, this looks like:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel num_threads(nthreads);</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> wrk = mat-&gt;dense_row();</div>
<div class="line">    std::vector&lt;double&gt; buffer(NC);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #pragma omp for</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; NR; ++r) {</div>
<div class="line">        <span class="keyword">auto</span> ptr = wrk-&gt;fetch(r, buffer.data());</div>
<div class="line">        <span class="comment">// Do something in each thread.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Users may also consider using the <code><a class="el" href="namespacetatami.html#a3ea65e5b93eb55c03b00aca301e0396f">tatami::parallelize()</a></code> function, which accepts a function with the range of jobs (in this case, rows) to be processed in each thread. This automatically falls back to the standard <code>&lt;thread&gt;</code> library if OpenMP is not available. Applications can also set the <code>TATAMI_CUSTOM_PARALLEL</code> macro to override the parallelization scheme in all <code><a class="el" href="namespacetatami.html#a3ea65e5b93eb55c03b00aca301e0396f">tatami::parallelize()</a></code> calls.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacetatami.html#a3ea65e5b93eb55c03b00aca301e0396f">tatami::parallelize</a>([&amp;](<span class="keywordtype">int</span> thread, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> length) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    <span class="keyword">auto</span> wrk = mat-&gt;dense_row();</div>
<div class="line">    std::vector&lt;double&gt; buffer(NC);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; length; ++r) {</div>
<div class="line">        <span class="keyword">auto</span> ptr = wrk-&gt;fetch(r + start, buffer.data());</div>
<div class="line">        <span class="comment">// Do something in each thread.</span></div>
<div class="line">    }</div>
<div class="line">}, NR, nthreads);</div>
<div class="ttc" id="anamespacetatami_html_a3ea65e5b93eb55c03b00aca301e0396f"><div class="ttname"><a href="namespacetatami.html#a3ea65e5b93eb55c03b00aca301e0396f">tatami::parallelize</a></div><div class="ttdeci">void parallelize(Function_ fun, const Index_ tasks, const int threads)</div><div class="ttdef"><b>Definition</b> parallelize.hpp:42</div></div>
</div><!-- fragment --><h2>Defining an oracle</h2>
<p>When constructing an <code>Extractor</code>, users can supply an <code>Oracle</code> that specifies the sequence of rows/columns to be accessed. Knowledge of the future access pattern enables optimizations in some <code>Matrix</code> implementations, e.g., file-backed matrices can reduce the number of disk reads by pre-fetching the right data for future accesses. The most obvious use case involves accessing consecutive rows/columns:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> o = std::make_shared&lt;tatami::ConsecutiveOracle&lt;int&gt; &gt;(0, NR));</div>
<div class="line"><span class="keyword">auto</span> wrk = mat-&gt;dense_row(o);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; NR; ++r) {</div>
<div class="line">    <span class="comment">// No need to specify the index to fetch, as &#39;wrk&#39; already knows the</span></div>
<div class="line">    <span class="comment">// sequence of indices as prediced by the oracle.</span></div>
<div class="line">    <span class="keyword">auto</span> ptr = wrk-&gt;fetch(buffer.data());</div>
<div class="line">}</div>
</div><!-- fragment --><p>In fact, this use case is so common that we can just use the <code><a class="el" href="namespacetatami.html#ae5cfcdf9fa34c6d0cd6b672472d407b3">tatami::consecutive_extractor()</a></code> wrapper to construct the oracle and pass it to <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. This will return a <code><a class="el" href="classtatami_1_1OracularDenseExtractor.html" title="Extract an element of the target dimension in dense form with an oracle.">tatami::OracularDenseExtractor</a></code> instance that contains the oracle's predictions.</p>
<div class="fragment"><div class="line"><span class="comment">// Same as &#39;wrk&#39; above.</span></div>
<div class="line"><span class="keyword">auto</span> cwrk = <a class="code hl_function" href="namespacetatami.html#ae5cfcdf9fa34c6d0cd6b672472d407b3">tatami::consecutive_extractor&lt;false&gt;</a>(mat.get(), row, 0, NR);</div>
<div class="ttc" id="anamespacetatami_html_ae5cfcdf9fa34c6d0cd6b672472d407b3"><div class="ttname"><a href="namespacetatami.html#ae5cfcdf9fa34c6d0cd6b672472d407b3">tatami::consecutive_extractor</a></div><div class="ttdeci">auto consecutive_extractor(const Matrix&lt; Value_, Index_ &gt; &amp;matrix, const bool row, const Index_ iter_start, const Index_ iter_length, Args_ &amp;&amp;... args)</div><div class="ttdef"><b>Definition</b> consecutive_extractor.hpp:35</div></div>
</div><!-- fragment --><p>Alternatively, we can use the <code>FixedOracle</code> class with an array of row/column indices that are known ahead of time. Advanced users can also define their own <code>Oracle</code> subclasses to generate predictions on the fly.</p>
<h1>Comments on other operations</h1>
<p>As previously mentioned, <b>tatami</b> is primarily designed to pull out rows or columns of a matrix. Some support is provided for computing basic statistics via the <a href="https://github.com/tatami-inc/tatami_stats"><b>tatami_stats</b></a> library, in the same vein as the <a href="https://github.com/HenrikBengtsson/matrixStats"><b>matrixStats</b></a> R package. Matrix multiplication is similarly implemented via the <a href="https://github.com/tatami-inc/tatami_mult"><b>tatami_mult</b></a> library.</p>
<p><b>tatami</b> does not currently support more sophisticated matrix operations like decompositions. If these are required, we suggest copying data from <b>tatami</b> into other frameworks like <a href="https://eigen.tuxfamily.org/"><b>Eigen</b></a>, effectively trading the diversity of representations for a more comprehensive suite of operations. For example, we often use <b>tatami</b> to represent the large input datasets in a custom memory-efficient format; process it into a much smaller submatrix, e.g., by selecting features of interest in a genome-scale analysis; and then copy the data into a <code>Eigen::MatrixXd</code> or <code>Eigen::SparseMatrix</code> for the desired operations. In practice, many standard decompositions do not scale well for large matrices, so our applications end up using approximate methods like <a href="https://github.com/LTLA/CppIrlba"><b>ILRBA</b></a> that only require a multiplication operator.</p>
<p><b>tatami</b> does not directly support modification of the matrix contents. Instead, "modifications" are performed by adding delayed operations on top of an immutable matrix. This avoids difficult bugs where the hypothetical modification of matrix contents via one <code>shared_ptr</code> affects all references to the same matrix across the application. Delayed operations are also more appropriate for matrices referring to read-only data sources, e.g., remote stores or files. That said, if delayed operations are undesirable, we can use functions like <code><a class="el" href="namespacetatami.html#ac5f5ff476ecb172e59c3535cedb966cd">tatami::convert_to_dense()</a></code> to realize our modifications into a new matrix instance.</p>
<h1>Building projects</h1>
<h2>CMake with <code>FetchContent</code></h2>
<p>If you're using CMake, you just need to add something like this to your <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  tatami</div>
<div class="line">  GIT_REPOSITORY https://github.com/tatami-inc/tatami</div>
<div class="line">  GIT_TAG master # or any version of interest </div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(tatami)</div>
</div><!-- fragment --><p>Then you can link to <b>tatami</b> to make the headers available during compilation:</p>
<div class="fragment"><div class="line"># For executables:</div>
<div class="line">target_link_libraries(myexe tatami)</div>
<div class="line"> </div>
<div class="line"># For libaries</div>
<div class="line">target_link_libraries(mylib INTERFACE tatami)</div>
</div><!-- fragment --><p>By default, this will use <code>FetchContent</code> to fetch all external dependencies. Applications are advised to pin the versions of these dependencies themselves - see <a href="extern/CMakeLists.txt"><code>extern/CMakeLists.txt</code></a> for suggested (minimum) versions. If you want to install them manually, use <code>-DTATAMI_FETCH_EXTERN=OFF</code>.</p>
<h2>CMake with <code>find_package()</code></h2>
<p>You can install the library by cloning a suitable version of this repository and running the following commands:</p>
<div class="fragment"><div class="line">mkdir build &amp;&amp; cd build</div>
<div class="line">cmake .. -DTATAMI_TESTS=OFF</div>
<div class="line">cmake --build . --target install</div>
</div><!-- fragment --><p>Then you can use <code>find_package()</code> as usual:</p>
<div class="fragment"><div class="line">find_package(tatami_tatami CONFIG REQUIRED)</div>
<div class="line">target_link_libraries(mylib INTERFACE tatami::tatami)</div>
</div><!-- fragment --><p>Again, this will use <code>FetchContent</code> to fetch all external dependencies, so see advice above.</p>
<h2>Manual</h2>
<p>If you're not using CMake, the simple approach is to just copy the files the <code>include/</code> subdirectory - either directly or with Git submodules - and include their path during compilation with, e.g., GCC's <code>-I</code>. This also requires the external dependencies listed in <a href="extern/CMakeLists.txt"><code>extern/CMakeLists.txt</code></a>.</p>
<h1>Links</h1>
<p>Check out the <a href="https://tatami-inc.github.io/tatami">reference documentation</a> for more details on each function and class.</p>
<p>The <a href="https://github.com/tatami-inc/gallery">gallery</a> contains worked examples for common operations based on row/column traversals.</p>
<p>The <a href="https://github.com/tatami-inc/tatami_stats"><b>tatami_stats</b></a> repository computes some common statistics on <b>tatami</b> matrices.</p>
<p>The <a href="https://github.com/tatami-inc/tatami_hdf5"><b>tatami_hdf5</b></a> repository contains <b>tatami</b> bindings for HDF5-backed matrices.</p>
<p>The <a href="https://github.com/tatami-inc/tatami_r"><b>tatami_r</b></a> repository contains <b>tatami</b> bindings for matrix-like objects in R.</p>
<p>The <a href="https://github.com/tatami-inc/beachmat"><b>beachmat</b></a> package vendors the <b>tatami</b> headers for easy use by other R packages. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
