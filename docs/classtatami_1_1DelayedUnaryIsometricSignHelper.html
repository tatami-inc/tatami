<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami::DelayedUnaryIsometricSignHelper&lt; OutputValue_, InputValue_, Index_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami.html">tatami</a></li><li class="navelem"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">DelayedUnaryIsometricSignHelper</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtatami_1_1DelayedUnaryIsometricSignHelper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami::DelayedUnaryIsometricSignHelper&lt; OutputValue_, InputValue_, Index_ &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Helper for delayed calculation of the sign of each matrix entry.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="math__helpers_8hpp_source.html">math_helpers.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tatami::DelayedUnaryIsometricSignHelper&lt; OutputValue_, InputValue_, Index_ &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtatami_1_1DelayedUnaryIsometricSignHelper__inherit__graph.png" border="0" usemap="#atatami_1_1DelayedUnaryIsometricSignHelper_3_01OutputValue___00_01InputValue___00_01Index___01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atatami_1_1DelayedUnaryIsometricSignHelper_3_01OutputValue___00_01InputValue___00_01Index___01_4_inherit__map" id="atatami_1_1DelayedUnaryIsometricSignHelper_3_01OutputValue___00_01InputValue___00_01Index___01_4_inherit__map">
<area shape="rect" title="Helper for delayed calculation of the sign of each matrix entry." alt="" coords="252,5,449,61"/>
<area shape="rect" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html" title="Helper operation interface for DelayedUnaryIsometricOperation." alt="" coords="5,5,204,61"/>
<area shape="poly" title=" " alt="" coords="219,30,251,30,251,36,219,36"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for tatami::DelayedUnaryIsometricSignHelper&lt; OutputValue_, InputValue_, Index_ &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtatami_1_1DelayedUnaryIsometricSignHelper__coll__graph.png" border="0" usemap="#atatami_1_1DelayedUnaryIsometricSignHelper_3_01OutputValue___00_01InputValue___00_01Index___01_4_coll__map" alt="Collaboration graph"/></div>
<map name="atatami_1_1DelayedUnaryIsometricSignHelper_3_01OutputValue___00_01InputValue___00_01Index___01_4_coll__map" id="atatami_1_1DelayedUnaryIsometricSignHelper_3_01OutputValue___00_01InputValue___00_01Index___01_4_coll__map">
<area shape="rect" title="Helper for delayed calculation of the sign of each matrix entry." alt="" coords="252,5,449,61"/>
<area shape="rect" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html" title="Helper operation interface for DelayedUnaryIsometricOperation." alt="" coords="5,5,204,61"/>
<area shape="poly" title=" " alt="" coords="219,30,251,30,251,36,219,36"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b848d25bdd9f6e38de20da8b411e9e8" id="r_a3b848d25bdd9f6e38de20da8b411e9e8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Index_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b848d25bdd9f6e38de20da8b411e9e8">nrow</a> () const</td></tr>
<tr class="separator:a3b848d25bdd9f6e38de20da8b411e9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52937e8aabfe40d313dcbdb838c989b" id="r_af52937e8aabfe40d313dcbdb838c989b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Index_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af52937e8aabfe40d313dcbdb838c989b">ncol</a> () const</td></tr>
<tr class="separator:af52937e8aabfe40d313dcbdb838c989b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586dd02bb4689442de635be903478d82" id="r_a586dd02bb4689442de635be903478d82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a586dd02bb4689442de635be903478d82">zero_depends_on_row</a> () const</td></tr>
<tr class="separator:a586dd02bb4689442de635be903478d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65f02750d3d1ba58bf4cb77eeb23ff4" id="r_af65f02750d3d1ba58bf4cb77eeb23ff4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af65f02750d3d1ba58bf4cb77eeb23ff4">zero_depends_on_column</a> () const</td></tr>
<tr class="separator:af65f02750d3d1ba58bf4cb77eeb23ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7350d0fd19495ef1a92ab85a7d150c" id="r_abf7350d0fd19495ef1a92ab85a7d150c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf7350d0fd19495ef1a92ab85a7d150c">non_zero_depends_on_row</a> () const</td></tr>
<tr class="separator:abf7350d0fd19495ef1a92ab85a7d150c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a7bb348a11725dd08ce9e5421ab8e8" id="r_ab7a7bb348a11725dd08ce9e5421ab8e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7a7bb348a11725dd08ce9e5421ab8e8">non_zero_depends_on_column</a> () const</td></tr>
<tr class="separator:ab7a7bb348a11725dd08ce9e5421ab8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cae46ec87aa7116cd2a874e45f0f93e" id="r_a3cae46ec87aa7116cd2a874e45f0f93e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cae46ec87aa7116cd2a874e45f0f93e">dense</a> (bool, Index_, Index_, Index_ length, const InputValue_ *input, OutputValue_ *output) const</td></tr>
<tr class="separator:a3cae46ec87aa7116cd2a874e45f0f93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e7873a511684a5a3fcad49746a32d5" id="r_af5e7873a511684a5a3fcad49746a32d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5e7873a511684a5a3fcad49746a32d5">dense</a> (bool, Index_, const std::vector&lt; Index_ &gt; &amp;indices, const InputValue_ *input, OutputValue_ *output) const</td></tr>
<tr class="separator:af5e7873a511684a5a3fcad49746a32d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43198c78116330f1d3864dcf329acd0e" id="r_a43198c78116330f1d3864dcf329acd0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43198c78116330f1d3864dcf329acd0e">is_sparse</a> () const</td></tr>
<tr class="separator:a43198c78116330f1d3864dcf329acd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759be13aaba969132b79b40ae437e2a2" id="r_a759be13aaba969132b79b40ae437e2a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a759be13aaba969132b79b40ae437e2a2">sparse</a> (bool, Index_, Index_ number, const InputValue_ *input, const Index_ *, OutputValue_ *output) const</td></tr>
<tr class="separator:a759be13aaba969132b79b40ae437e2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a22877389b3998a81fc1a582f7c2408" id="r_a3a22877389b3998a81fc1a582f7c2408"><td class="memItemLeft" align="right" valign="top">OutputValue_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a22877389b3998a81fc1a582f7c2408">fill</a> (bool, Index_) const</td></tr>
<tr class="separator:a3a22877389b3998a81fc1a582f7c2408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtatami_1_1DelayedUnaryIsometricOperationHelper"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classtatami_1_1DelayedUnaryIsometricOperationHelper')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html">tatami::DelayedUnaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</a></td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename OutputValue_, typename InputValue_, typename Index_&gt;<br />
class tatami::DelayedUnaryIsometricSignHelper&lt; OutputValue_, InputValue_, Index_ &gt;</div><p>Helper for delayed calculation of the sign of each matrix entry. </p>
<p>This class takes the sign of each element of a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code>, returning -1, 0 or 1 for negative, zero or positive values, respectively. It should be used as the <code>Operation_</code> in the <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code> class.</p>
<p>This operation will report NaNs in the input as NaNs in the output if supported by the <code>OutputValue_</code> type, otherwise they are set to 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the value of the input matrix. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3b848d25bdd9f6e38de20da8b411e9e8" name="a3b848d25bdd9f6e38de20da8b411e9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b848d25bdd9f6e38de20da8b411e9e8">&#9670;&#160;</a></span>nrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Index_ &gt; <a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">tatami::DelayedUnaryIsometricSignHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::nrow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Expected number of rows in the matrix to which this operation is to be applied (i.e., the underlying matrix in the <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code> constructor). If no value is returned, the matrix may have any number of rows. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html#a8910d2540bc887faecd67c71aaff0d9f">tatami::DelayedUnaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="af52937e8aabfe40d313dcbdb838c989b" name="af52937e8aabfe40d313dcbdb838c989b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52937e8aabfe40d313dcbdb838c989b">&#9670;&#160;</a></span>ncol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Index_ &gt; <a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">tatami::DelayedUnaryIsometricSignHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::ncol </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Expected number of columns in the matrix to which this operation is to be applied (i.e., the underlying matrix in the <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code> constructor). If no value is returned, the matrix may have any number of columns. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html#a5226816099e70c60e003360fb8534efd">tatami::DelayedUnaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a586dd02bb4689442de635be903478d82" name="a586dd02bb4689442de635be903478d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586dd02bb4689442de635be903478d82">&#9670;&#160;</a></span>zero_depends_on_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">tatami::DelayedUnaryIsometricSignHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::zero_depends_on_row </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the operation will convert a structural zero to a non-zero value, in a manner that depends on the identity of the column in which the structural zero occurs.</dd></dl>
<p>This method is only called when <code><a class="el" href="#a43198c78116330f1d3864dcf329acd0e">is_sparse()</a></code> returns false. It is not necessary to explicitly return <code>false</code> here for sparsity-preserving operations, as <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code> will automatically recognize such operations as being row-independent. </p>

<p>Implements <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html#af76ea67625d1bda2238a931678da1b37">tatami::DelayedUnaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="af65f02750d3d1ba58bf4cb77eeb23ff4" name="af65f02750d3d1ba58bf4cb77eeb23ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65f02750d3d1ba58bf4cb77eeb23ff4">&#9670;&#160;</a></span>zero_depends_on_column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">tatami::DelayedUnaryIsometricSignHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::zero_depends_on_column </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the operation will convert a structural zero to a non-zero value, in a manner that depends on the identity of the column in which the structural zero occurs.</dd></dl>
<p>This method is only called when <code><a class="el" href="#a43198c78116330f1d3864dcf329acd0e">is_sparse()</a></code> returns false. It is not necessary to explicitly return <code>false</code> here for sparsity-preserving operations, as <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code> will automatically recognize such operations as being row-independent. </p>

<p>Implements <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html#a5bfefbca29262790c0524333b591dbd5">tatami::DelayedUnaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="abf7350d0fd19495ef1a92ab85a7d150c" name="abf7350d0fd19495ef1a92ab85a7d150c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7350d0fd19495ef1a92ab85a7d150c">&#9670;&#160;</a></span>non_zero_depends_on_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">tatami::DelayedUnaryIsometricSignHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::non_zero_depends_on_row </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the result of the operation on a non-zero operand depends on the identity of the row containing the operand. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html#a06e8b4eed53f15fdfad871c143663f96">tatami::DelayedUnaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="ab7a7bb348a11725dd08ce9e5421ab8e8" name="ab7a7bb348a11725dd08ce9e5421ab8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a7bb348a11725dd08ce9e5421ab8e8">&#9670;&#160;</a></span>non_zero_depends_on_column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">tatami::DelayedUnaryIsometricSignHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::non_zero_depends_on_column </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the result of the operation on a non-zero operand depends on the identity of the column containing the operand. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html#af4e8ae40f835a624e778598fbd59769d">tatami::DelayedUnaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a3cae46ec87aa7116cd2a874e45f0f93e" name="a3cae46ec87aa7116cd2a874e45f0f93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cae46ec87aa7116cd2a874e45f0f93e">&#9670;&#160;</a></span>dense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">tatami::DelayedUnaryIsometricSignHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::dense </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputValue_ *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputValue_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method accepts a contiguous block of an element of the target dimension from the underlying matrix (<code>input</code>), applies the operation to each value, and stores the result in another array of different type (<code>output</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether the rows are the target dimension. If true, <code>buffer</code> contains row <code>i</code>, otherwise it contains column <code>i</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). This argument should be ignored if the operation does not depend on the row/column (i.e., when all of <code><a class="el" href="#a586dd02bb4689442de635be903478d82">zero_depends_on_row()</a></code> and friends return false), in which case an arbitrary placeholder may be supplied. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>Start of the contiguous block of columns (if <code>row = true</code>) or rows (otherwise) extracted from <code>i</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>Length of the contiguous block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing a contiguous block of a row/column extracted from the matrix. This has <code>length</code> addressable elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array to store the results of the operation applied to elements of <code>input</code>. This has <code>length</code> addressable elements. If <code>InputValue_ == OutputValue_</code>, this is guaranteed to be the same as <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html#a67469fa0530bc86b737eb5d69d5cb2dd">tatami::DelayedUnaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="af5e7873a511684a5a3fcad49746a32d5" name="af5e7873a511684a5a3fcad49746a32d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e7873a511684a5a3fcad49746a32d5">&#9670;&#160;</a></span>dense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">tatami::DelayedUnaryIsometricSignHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::dense </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputValue_ *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputValue_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method accepts an indexed subset of an element of the target dimension from the underlying matrix (<code>input</code>), applies the operation to each value, and stores the result in another array of different type (<code>output</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether the rows are the target dimension. If true, <code>buffer</code> contains row <code>i</code>, otherwise it contains column <code>i</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). This argument should be ignored if the operation does not depend on the row/column (i.e., when all of <code><a class="el" href="#a586dd02bb4689442de635be903478d82">zero_depends_on_row()</a></code> and friends return false), in which case an arbitrary placeholder may be supplied. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">indices</td><td>Sorted and unique indices of columns (if <code>row = true</code>) or rows (otherwise) extracted from <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing an indexed subset of a row/column extracted from the matrix. This has <code>length</code> addressable elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array to store the results of the operation applied to elements of <code>input</code>. This has <code>length</code> addressable elements. If <code>InputValue_ == OutputValue_</code>, this is guaranteed to be the same as <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html#a7dad19db3c553c550bca9f381626a386">tatami::DelayedUnaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a43198c78116330f1d3864dcf329acd0e" name="a43198c78116330f1d3864dcf329acd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43198c78116330f1d3864dcf329acd0e">&#9670;&#160;</a></span>is_sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">tatami::DelayedUnaryIsometricSignHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::is_sparse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Does this operation preserve sparsity? This may return false. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html#a58cb635f41b38778363361b240b681c8">tatami::DelayedUnaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a759be13aaba969132b79b40ae437e2a2" name="a759be13aaba969132b79b40ae437e2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759be13aaba969132b79b40ae437e2a2">&#9670;&#160;</a></span>sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">tatami::DelayedUnaryIsometricSignHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputValue_ *</td>          <td class="paramname"><span class="paramname"><em>input_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index_ *</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputValue_ *</td>          <td class="paramname"><span class="paramname"><em>output_value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is expected to iterate over <code>input_value</code>, apply the operation to each value, and store the result in <code>output_value</code>. We assume that the operation only needs to be applied to the structural non-zeros; structural zeros are either ignored for sparsity-preserving operations, or the result of the operation on zeros will be populated by <code><a class="el" href="#a3a22877389b3998a81fc1a582f7c2408">fill()</a></code>.</p>
<p>If <code><a class="el" href="#abf7350d0fd19495ef1a92ab85a7d150c">non_zero_depends_on_row()</a> &amp;&amp; !row</code> or <code><a class="el" href="#ab7a7bb348a11725dd08ce9e5421ab8e8">non_zero_depends_on_column()</a> &amp;&amp; row</code>, <code>index</code> is guaranteed to be non-NULL. Otherwise, it may be NULL and should be ignored. Even if non-NULL, indices are not guaranteed to be sorted.</p>
<p>Implementations of this method do not necessarily need to have the same template arguments as shown here. It will be called without any explicit template arguments so anything can be used as long as type deduction works.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether the rows are the target dimension. If true, <code>buffer</code> contains row <code>i</code>, otherwise it contains column <code>i</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). This argument should be ignored if the operation does not depend on the row/column (i.e., when all of <code><a class="el" href="#a586dd02bb4689442de635be903478d82">zero_depends_on_row()</a></code> and friends return false), in which case an arbitrary placeholder may be supplied. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of non-zero elements for row/column <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_value</td><td>Pointer to an array of values of the structural non-zero elements from the row/column of the matrix. This is guaranteed to have <code>num</code> addressable elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Pointer to an array of column (if <code>row = true</code>) or row indices (otherwise) of the non-zero elements. Alternatively NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_value</td><td>Pointer to an array in which to store the result of the operation on each element of <code>input_value</code>. This is guaranteed to have <code>num</code> addressable elements. If <code>InputValue_ == OutputValue_</code>, this is guaranteed to be the same as <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html#a682767d6decb6584b3bd7d2700a162e7">tatami::DelayedUnaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a3a22877389b3998a81fc1a582f7c2408" name="a3a22877389b3998a81fc1a582f7c2408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a22877389b3998a81fc1a582f7c2408">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputValue_ <a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">tatami::DelayedUnaryIsometricSignHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether <code>i</code> refers to the row or column index. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row (if <code>row = true</code>) or column (otherwise) containing the zeros. This argument should be ignored if the operation does not depend on the row/column (i.e., when all of <code><a class="el" href="#a586dd02bb4689442de635be903478d82">zero_depends_on_row()</a></code> and friends return false), in which case an arbitrary placeholder may be supplied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation being applied on zeros from the <code>i</code>-th row/column of the matrix. </dd></dl>

<p>Implements <a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html#a545f431c53f329988d8e495e90851888">tatami::DelayedUnaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami/isometric/unary/<a class="el" href="math__helpers_8hpp_source.html">math_helpers.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
