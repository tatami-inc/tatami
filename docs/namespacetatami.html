<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tatami Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Flexible representations for matrix data.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1ArrayView.html">ArrayView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View into a pre-allocated array.  <a href="classtatami_1_1ArrayView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1BlockSparsifiedWrapper.html">BlockSparsifiedWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a block dense extractor in the sparse interface.  <a href="classtatami_1_1BlockSparsifiedWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1CompressedSparseColumnMatrix.html">CompressedSparseColumnMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse column matrix.  <a href="classtatami_1_1CompressedSparseColumnMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1CompressedSparseContents.html">CompressedSparseContents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse contents.  <a href="structtatami_1_1CompressedSparseContents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse matrix representation.  <a href="classtatami_1_1CompressedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1CompressedSparseMatrixOptions.html">CompressedSparseMatrixOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for the <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">CompressedSparseMatrix</a></code>.  <a href="structtatami_1_1CompressedSparseMatrixOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1CompressedSparseRowMatrix.html">CompressedSparseRowMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse row matrix.  <a href="classtatami_1_1CompressedSparseRowMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1ConsecutiveOracle.html">ConsecutiveOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses along a consecutive sequence.  <a href="classtatami_1_1ConsecutiveOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1ConstantMatrix.html">ConstantMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a> containing a constant value.  <a href="classtatami_1_1ConstantMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1ConvertToCompressedSparseOptions.html">ConvertToCompressedSparseOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#a2eaf90f62fd2ccfcd1c35ef291f7f489">convert_to_compressed_sparse()</a></code>.  <a href="structtatami_1_1ConvertToCompressedSparseOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1ConvertToDenseOptions.html">ConvertToDenseOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#ad06cf62ba0b58e240aed427379c2ac38">convert_to_dense()</a></code>.  <a href="structtatami_1_1ConvertToDenseOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1ConvertToFragmentedSparseOptions.html">ConvertToFragmentedSparseOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#add29754647077a82209dfe6ba78cd2b5">convert_to_fragmented_sparse()</a></code>.  <a href="structtatami_1_1ConvertToFragmentedSparseOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1CountCompressedSparseNonZerosOptions.html">CountCompressedSparseNonZerosOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#ac004bfb30ee5623bec14d3783c2cc21e">count_compressed_sparse_non_zeros()</a></code>.  <a href="structtatami_1_1CountCompressedSparseNonZerosOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed binary isometric arithmetic.  <a href="classtatami_1_1DelayedBinaryIsometricArithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryIsometricBoolean.html">DelayedBinaryIsometricBoolean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed binary isometric boolean operations.  <a href="structtatami_1_1DelayedBinaryIsometricBoolean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed binary isometric comparison.  <a href="structtatami_1_1DelayedBinaryIsometricCompare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBinaryIsometricMockAdvanced.html">DelayedBinaryIsometricMockAdvanced</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced mock operation for <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>.  <a href="classtatami_1_1DelayedBinaryIsometricMockAdvanced.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBinaryIsometricMockBasic.html">DelayedBinaryIsometricMockBasic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic mock operation for <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>.  <a href="classtatami_1_1DelayedBinaryIsometricMockBasic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html">DelayedBinaryIsometricOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed isometric operations on two matrices.  <a href="classtatami_1_1DelayedBinaryIsometricOperation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBind.html">DelayedBind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed combining of a matrix.  <a href="classtatami_1_1DelayedBind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedCast.html">DelayedCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> to a different interface type.  <a href="classtatami_1_1DelayedCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubset.html">DelayedSubset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with general indices.  <a href="classtatami_1_1DelayedSubset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetBlock.html">DelayedSubsetBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting to a contiguous block.  <a href="classtatami_1_1DelayedSubsetBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetSorted.html">DelayedSubsetSorted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with sorted indices.  <a href="classtatami_1_1DelayedSubsetSorted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html">DelayedSubsetSortedUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with sorted, unique indices.  <a href="classtatami_1_1DelayedSubsetSortedUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetUnique.html">DelayedSubsetUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with unique indices.  <a href="classtatami_1_1DelayedSubsetUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedTranspose.html">DelayedTranspose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed transposition of a matrix.  <a href="classtatami_1_1DelayedTranspose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAbs.html">DelayedUnaryIsometricAbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the absolute value of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAbs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAcos.html">DelayedUnaryIsometricAcos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the inverse cosine of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAcos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAcosh.html">DelayedUnaryIsometricAcosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the inverse hyperbolic cosine of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAcosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed unary isometric scalar arithmetic.  <a href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed unary isometric vector arithmetic.  <a href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAsin.html">DelayedUnaryIsometricAsin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the inverse sine of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAsin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAsinh.html">DelayedUnaryIsometricAsinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the inverse hyperbolic sine of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAsinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAtan.html">DelayedUnaryIsometricAtan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the inverse tangent of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAtan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAtanh.html">DelayedUnaryIsometricAtanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the inverse hyperbolic tangent of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAtanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanCast.html">DelayedUnaryIsometricBooleanCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed unary isometric boolean cast.  <a href="classtatami_1_1DelayedUnaryIsometricBooleanCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanNot.html">DelayedUnaryIsometricBooleanNot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed unary isometric boolean NOT operation.  <a href="classtatami_1_1DelayedUnaryIsometricBooleanNot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalar.html">DelayedUnaryIsometricBooleanScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed unary isometric scalar boolean operation.  <a href="classtatami_1_1DelayedUnaryIsometricBooleanScalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html">DelayedUnaryIsometricBooleanVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed unary isometric vector boolean operations.  <a href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCeiling.html">DelayedUnaryIsometricCeiling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the ceiling of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricCeiling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed scalar comparison.  <a href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed vector comparisons.  <a href="classtatami_1_1DelayedUnaryIsometricCompareVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCos.html">DelayedUnaryIsometricCos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the cosine of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricCos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCosh.html">DelayedUnaryIsometricCosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the hyperbolic cosine of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricCosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricExp.html">DelayedUnaryIsometricExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a matrix entry as an exponent.  <a href="classtatami_1_1DelayedUnaryIsometricExp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricExpm1.html">DelayedUnaryIsometricExpm1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a matrix entry as an exponent minus 1.  <a href="classtatami_1_1DelayedUnaryIsometricExpm1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricFloor.html">DelayedUnaryIsometricFloor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the floor of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricFloor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricGamma.html">DelayedUnaryIsometricGamma</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the gamma function to a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricGamma.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricLgamma.html">DelayedUnaryIsometricLgamma</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the log-gamma function to a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricLgamma.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricLog.html">DelayedUnaryIsometricLog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricLog.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricLog1p.html">DelayedUnaryIsometricLog1p</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm of a matrix entry plus 1.  <a href="classtatami_1_1DelayedUnaryIsometricLog1p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html">DelayedUnaryIsometricMockAdvanced</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced mock operation for <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>.  <a href="classtatami_1_1DelayedUnaryIsometricMockAdvanced.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricMockBasic.html">DelayedUnaryIsometricMockBasic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic mock operation for a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>.  <a href="classtatami_1_1DelayedUnaryIsometricMockBasic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html">DelayedUnaryIsometricOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed isometric operation on a single matrix.  <a href="classtatami_1_1DelayedUnaryIsometricOperation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricRound.html">DelayedUnaryIsometricRound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a matrix entry to the nearest integer.  <a href="classtatami_1_1DelayedUnaryIsometricRound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSign.html">DelayedUnaryIsometricSign</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the sign of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricSign.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSin.html">DelayedUnaryIsometricSin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the sine of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricSin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSinh.html">DelayedUnaryIsometricSinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the hyperbolic sine of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricSinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompare.html">DelayedUnaryIsometricSpecialCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed special value comparison.  <a href="classtatami_1_1DelayedUnaryIsometricSpecialCompare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstitute.html">DelayedUnaryIsometricSpecialSubstitute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed special value substitution.  <a href="classtatami_1_1DelayedUnaryIsometricSpecialSubstitute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSqrt.html">DelayedUnaryIsometricSqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the square root of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricSqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed scalar substitution.  <a href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed vector comparisons.  <a href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricTan.html">DelayedUnaryIsometricTan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the tangent of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricTan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricTanh.html">DelayedUnaryIsometricTanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the hyperbolic tangent of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricTanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricTrunc.html">DelayedUnaryIsometricTrunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer truncation of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricTrunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DenseColumnMatrix.html">DenseColumnMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense column-major matrix.  <a href="classtatami_1_1DenseColumnMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense matrix representation.  <a href="classtatami_1_1DenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DenseRowMatrix.html">DenseRowMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense row-major matrix.  <a href="classtatami_1_1DenseRowMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FillCompressedSparseContentsOptions.html">FillCompressedSparseContentsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#aaadd3c0f36b8cbde2d360a8babba163f">fill_compressed_sparse_contents()</a></code>.  <a href="structtatami_1_1FillCompressedSparseContentsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FixedVectorOracle.html">FixedVectorOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses from a vector containing a fixed sequence.  <a href="classtatami_1_1FixedVectorOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FixedViewOracle.html">FixedViewOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses from a view on a fixed sequence.  <a href="classtatami_1_1FixedViewOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FragmentedSparseColumnMatrix.html">FragmentedSparseColumnMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmented sparse column matrix.  <a href="classtatami_1_1FragmentedSparseColumnMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FragmentedSparseContents.html">FragmentedSparseContents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmented sparse contents.  <a href="structtatami_1_1FragmentedSparseContents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FragmentedSparseMatrix.html">FragmentedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmented sparse matrix representation.  <a href="classtatami_1_1FragmentedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FragmentedSparseMatrixOptions.html">FragmentedSparseMatrixOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code>FragmentedSparseMatrix()</code>.  <a href="structtatami_1_1FragmentedSparseMatrixOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FragmentedSparseRowMatrix.html">FragmentedSparseRowMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmented sparse row matrix.  <a href="classtatami_1_1FragmentedSparseRowMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FullSparsifiedWrapper.html">FullSparsifiedWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a full dense extractor in the sparse interface.  <a href="classtatami_1_1FullSparsifiedWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1has__data.html">has_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the <code>data()</code> method.  <a href="structtatami_1_1has__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1has__data_3_01T_00_01V_00_01decltype_07_07void_08_01std_1_1declval_3_01V_01_4_07_08_8data_07_08_00_010_08_4.html">has_data&lt; T, V, decltype((void) std::declval&lt; V &gt;().data(), 0)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the <code>data()</code> method.  <a href="structtatami_1_1has__data_3_01T_00_01V_00_01decltype_07_07void_08_01std_1_1declval_3_01V_01_4_07_08_8data_07_08_00_010_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1IndexSparsifiedWrapper.html">IndexSparsifiedWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an indexed dense extractor in the sparse interface.  <a href="classtatami_1_1IndexSparsifiedWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual class for a matrix.  <a href="classtatami_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an element of the target dimension in dense form without an oracle.  <a href="classtatami_1_1MyopicDenseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an element of the target dimension in sparse form without an oracle.  <a href="classtatami_1_1MyopicSparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for accessing data from a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> instance.  <a href="structtatami_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Oracle.html">Oracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future access requests on the target dimension.  <a href="classtatami_1_1Oracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an element of the target dimension in dense form with an oracle.  <a href="classtatami_1_1OracularDenseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an element of the target dimension in sparse form with an oracle.  <a href="classtatami_1_1OracularSparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1PseudoOracularDenseExtractor.html">PseudoOracularDenseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mimic the <code><a class="el" href="classtatami_1_1OracularDenseExtractor.html" title="Extract an element of the target dimension in dense form with an oracle.">OracularDenseExtractor</a></code> interface.  <a href="structtatami_1_1PseudoOracularDenseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1PseudoOracularSparseExtractor.html">PseudoOracularSparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mimic the <code><a class="el" href="classtatami_1_1OracularSparseExtractor.html" title="Extract an element of the target dimension in sparse form with an oracle.">OracularSparseExtractor</a></code> interface.  <a href="structtatami_1_1PseudoOracularSparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1RetrieveCompressedSparseContentsOptions.html">RetrieveCompressedSparseContentsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#a05dc21541e6db5a8896049a0647c4230">retrieve_compressed_sparse_contents()</a></code>.  <a href="structtatami_1_1RetrieveCompressedSparseContentsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1RetrieveFragmentedSparseContentsOptions.html">RetrieveFragmentedSparseContentsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#a5c71daf9bdb1ea8d3e16f35c5b15facc">retrieve_fragmented_sparse_contents()</a></code>.  <a href="structtatami_1_1RetrieveFragmentedSparseContentsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1SomeNumericArray.html">SomeNumericArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of some numeric type, determined at runtime.  <a href="classtatami_1_1SomeNumericArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of a sparse vector.  <a href="structtatami_1_1SparseRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a92f2deb44e0a3cb1c569a379c6facbf0" id="r_a92f2deb44e0a3cb1c569a379c6facbf0"><td class="memTemplParams" colspan="2">template&lt;bool oracle_, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a92f2deb44e0a3cb1c569a379c6facbf0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92f2deb44e0a3cb1c569a379c6facbf0">DenseExtractor</a> = typename std::conditional&lt;oracle_, <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt;Value_, Index_&gt;, <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt;Value_, Index_&gt; &gt;::type</td></tr>
<tr class="separator:a92f2deb44e0a3cb1c569a379c6facbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213ab58ba31e5b5cee3b66ab54d86055" id="r_a213ab58ba31e5b5cee3b66ab54d86055"><td class="memTemplParams" colspan="2">template&lt;bool oracle_, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a213ab58ba31e5b5cee3b66ab54d86055"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a213ab58ba31e5b5cee3b66ab54d86055">SparseExtractor</a> = typename std::conditional&lt;oracle_, <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt;Value_, Index_&gt;, <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt;Value_, Index_&gt; &gt;::type</td></tr>
<tr class="separator:a213ab58ba31e5b5cee3b66ab54d86055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9c70ebcfa94bba3fea89202868f22f" id="r_a1a9c70ebcfa94bba3fea89202868f22f"><td class="memTemplParams" colspan="2">template&lt;typename Index_ &gt; </td></tr>
<tr class="memitem:a1a9c70ebcfa94bba3fea89202868f22f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a> = std::shared_ptr&lt;const std::vector&lt;Index_&gt; &gt;</td></tr>
<tr class="separator:a1a9c70ebcfa94bba3fea89202868f22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0438743ada096f37f307404851849ff" id="r_ae0438743ada096f37f307404851849ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0438743ada096f37f307404851849ff">NumericMatrix</a> = <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt;double, int&gt;</td></tr>
<tr class="separator:ae0438743ada096f37f307404851849ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f5bea1c12d21f81732d6abd0665554" id="r_a83f5bea1c12d21f81732d6abd0665554"><td class="memTemplParams" colspan="2">template&lt;class Array_ &gt; </td></tr>
<tr class="memitem:a83f5bea1c12d21f81732d6abd0665554"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a83f5bea1c12d21f81732d6abd0665554">ElementType</a> = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(std::declval&lt;Array_&gt;()[0])&gt;::type&gt;::type</td></tr>
<tr class="separator:a83f5bea1c12d21f81732d6abd0665554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812af1bfb04773bf28da8549c3e6e5ee" id="r_a812af1bfb04773bf28da8549c3e6e5ee"><td class="memTemplParams" colspan="2">template&lt;bool oracle_, typename Index_ &gt; </td></tr>
<tr class="memitem:a812af1bfb04773bf28da8549c3e6e5ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a812af1bfb04773bf28da8549c3e6e5ee">MaybeOracle</a> = typename std::conditional&lt;oracle_, std::shared_ptr&lt;const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt;Index_&gt; &gt;, bool&gt;::type</td></tr>
<tr class="separator:a812af1bfb04773bf28da8549c3e6e5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0a2ecaf58e2b69bb4a808e814aeb16a1" id="r_a0a2ecaf58e2b69bb4a808e814aeb16a1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> : char { <b>FULL</b>
, <b>BLOCK</b>
, <b>INDEX</b>
 }</td></tr>
<tr class="separator:a0a2ecaf58e2b69bb4a808e814aeb16a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9050a4b119e027638175c38cc9bbede8" id="r_a9050a4b119e027638175c38cc9bbede8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9050a4b119e027638175c38cc9bbede8">ArithmeticOperation</a> : char { <br />
&#160;&#160;<b>ADD</b>
, <b>SUBTRACT</b>
, <b>MULTIPLY</b>
, <b>DIVIDE</b>
, <br />
&#160;&#160;<b>POWER</b>
, <b>MODULO</b>
, <b>INTEGER_DIVIDE</b>
<br />
 }</td></tr>
<tr class="separator:a9050a4b119e027638175c38cc9bbede8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5eea599200bfb6bc42f184118be28a" id="r_a4e5eea599200bfb6bc42f184118be28a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e5eea599200bfb6bc42f184118be28a">BooleanOperation</a> : char { <b>AND</b>
, <b>OR</b>
, <b>XOR</b>
, <b>EQUAL</b>
 }</td></tr>
<tr class="separator:a4e5eea599200bfb6bc42f184118be28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89475b46f681dd39b9926ced507240cc" id="r_a89475b46f681dd39b9926ced507240cc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89475b46f681dd39b9926ced507240cc">CompareOperation</a> : char { <br />
&#160;&#160;<b>EQUAL</b>
, <b>GREATER_THAN</b>
, <b>LESS_THAN</b>
, <b>GREATER_THAN_OR_EQUAL</b>
, <br />
&#160;&#160;<b>LESS_THAN_OR_EQUAL</b>
, <b>NOT_EQUAL</b>
<br />
 }</td></tr>
<tr class="separator:a89475b46f681dd39b9926ced507240cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef624db40413dabc3fea554fc936d39" id="r_a4ef624db40413dabc3fea554fc936d39"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ef624db40413dabc3fea554fc936d39">SpecialCompareOperation</a> : char { <b>ISNAN</b>
, <b>ISINF</b>
, <b>ISFINITE</b>
 }</td></tr>
<tr class="separator:a4ef624db40413dabc3fea554fc936d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4e0b21d1826723cc5ea81d889a73e5" id="r_a6c4e0b21d1826723cc5ea81d889a73e5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c4e0b21d1826723cc5ea81d889a73e5">SomeNumericType</a> { <br />
&#160;&#160;<b>I8</b>
, <b>U8</b>
, <b>I16</b>
, <b>U16</b>
, <br />
&#160;&#160;<b>I32</b>
, <b>U32</b>
, <b>I64</b>
, <b>U64</b>
, <br />
&#160;&#160;<b>F32</b>
, <b>F64</b>
<br />
 }</td></tr>
<tr class="separator:a6c4e0b21d1826723cc5ea81d889a73e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad06cf62ba0b58e240aed427379c2ac38" id="r_ad06cf62ba0b58e240aed427379c2ac38"><td class="memTemplParams" colspan="2">template&lt;typename StoredValue_ , typename InputValue_ , typename InputIndex_ &gt; </td></tr>
<tr class="memitem:ad06cf62ba0b58e240aed427379c2ac38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad06cf62ba0b58e240aed427379c2ac38">convert_to_dense</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, bool row_major, StoredValue_ *store, const <a class="el" href="structtatami_1_1ConvertToDenseOptions.html">ConvertToDenseOptions</a> &amp;options)</td></tr>
<tr class="separator:ad06cf62ba0b58e240aed427379c2ac38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18e5d06e9adc78acdf0924e7e3d8fbd" id="r_ad18e5d06e9adc78acdf0924e7e3d8fbd"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, typename InputValue_ , typename InputIndex_ &gt; </td></tr>
<tr class="memitem:ad18e5d06e9adc78acdf0924e7e3d8fbd"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad18e5d06e9adc78acdf0924e7e3d8fbd">convert_to_dense</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, bool row_major, const <a class="el" href="structtatami_1_1ConvertToDenseOptions.html">ConvertToDenseOptions</a> &amp;options)</td></tr>
<tr class="separator:ad18e5d06e9adc78acdf0924e7e3d8fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c1d1f96ea3a59d9f6106b17873d494" id="r_a07c1d1f96ea3a59d9f6106b17873d494"><td class="memTemplParams" colspan="2">template&lt;typename Input_ , typename Output_ &gt; </td></tr>
<tr class="memitem:a07c1d1f96ea3a59d9f6106b17873d494"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07c1d1f96ea3a59d9f6106b17873d494">transpose</a> (const Input_ *input, size_t nrow, size_t ncol, size_t input_stride, Output_ *output, size_t output_stride)</td></tr>
<tr class="separator:a07c1d1f96ea3a59d9f6106b17873d494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86be7b06c9d13b25f9ff04eed87430a7" id="r_a86be7b06c9d13b25f9ff04eed87430a7"><td class="memTemplParams" colspan="2">template&lt;typename Input_ , typename Output_ &gt; </td></tr>
<tr class="memitem:a86be7b06c9d13b25f9ff04eed87430a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86be7b06c9d13b25f9ff04eed87430a7">transpose</a> (const Input_ *input, size_t nrow, size_t ncol, Output_ *output)</td></tr>
<tr class="separator:a86be7b06c9d13b25f9ff04eed87430a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389ebbcd018702d2922b795c08721e78" id="r_a389ebbcd018702d2922b795c08721e78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::ADD &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a389ebbcd018702d2922b795c08721e78">make_DelayedBinaryIsometricAdd</a> ()</td></tr>
<tr class="separator:a389ebbcd018702d2922b795c08721e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3647a1ae34a5e8a47b28631da1032fc9" id="r_a3647a1ae34a5e8a47b28631da1032fc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::SUBTRACT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3647a1ae34a5e8a47b28631da1032fc9">make_DelayedBinaryIsometricSubtract</a> ()</td></tr>
<tr class="separator:a3647a1ae34a5e8a47b28631da1032fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01370b082642ae6c745ff9bb1600a87f" id="r_a01370b082642ae6c745ff9bb1600a87f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::MULTIPLY &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01370b082642ae6c745ff9bb1600a87f">make_DelayedBinaryIsometricMultiply</a> ()</td></tr>
<tr class="separator:a01370b082642ae6c745ff9bb1600a87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d4e17808d85624398f7f25ee36e635" id="r_a42d4e17808d85624398f7f25ee36e635"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::DIVIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42d4e17808d85624398f7f25ee36e635">make_DelayedBinaryIsometricDivide</a> ()</td></tr>
<tr class="separator:a42d4e17808d85624398f7f25ee36e635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed3cf4520b14ba2e85cf4afb32a1fdc" id="r_a1ed3cf4520b14ba2e85cf4afb32a1fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::POWER &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ed3cf4520b14ba2e85cf4afb32a1fdc">make_DelayedBinaryIsometricPower</a> ()</td></tr>
<tr class="separator:a1ed3cf4520b14ba2e85cf4afb32a1fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f8a13127f659c6362d53aa51ed33d8" id="r_a20f8a13127f659c6362d53aa51ed33d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::MODULO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20f8a13127f659c6362d53aa51ed33d8">make_DelayedBinaryIsometricModulo</a> ()</td></tr>
<tr class="separator:a20f8a13127f659c6362d53aa51ed33d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63d9c1ef029246b216b8a5af33b84ca" id="r_ae63d9c1ef029246b216b8a5af33b84ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::INTEGER_DIVIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae63d9c1ef029246b216b8a5af33b84ca">make_DelayedBinaryIsometricIntegerDivide</a> ()</td></tr>
<tr class="separator:ae63d9c1ef029246b216b8a5af33b84ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e1b122c59a6aca0b21574915b4b1e9" id="r_ae8e1b122c59a6aca0b21574915b4b1e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryIsometricBoolean.html">DelayedBinaryIsometricBoolean</a>&lt; BooleanOperation::EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8e1b122c59a6aca0b21574915b4b1e9">make_DelayedBinaryIsometricBooleanEqual</a> ()</td></tr>
<tr class="separator:ae8e1b122c59a6aca0b21574915b4b1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cbe03c715d9da7a0f1698a1f13b3b3" id="r_a57cbe03c715d9da7a0f1698a1f13b3b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryIsometricBoolean.html">DelayedBinaryIsometricBoolean</a>&lt; BooleanOperation::AND &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57cbe03c715d9da7a0f1698a1f13b3b3">make_DelayedBinaryIsometricBooleanAnd</a> ()</td></tr>
<tr class="separator:a57cbe03c715d9da7a0f1698a1f13b3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e16348dab1840e17a24cb06c1dcf2f3" id="r_a6e16348dab1840e17a24cb06c1dcf2f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryIsometricBoolean.html">DelayedBinaryIsometricBoolean</a>&lt; BooleanOperation::OR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e16348dab1840e17a24cb06c1dcf2f3">make_DelayedBinaryIsometricBooleanOr</a> ()</td></tr>
<tr class="separator:a6e16348dab1840e17a24cb06c1dcf2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fe42dacf113b2da94054a4f299ff56" id="r_aa8fe42dacf113b2da94054a4f299ff56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryIsometricBoolean.html">DelayedBinaryIsometricBoolean</a>&lt; BooleanOperation::XOR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8fe42dacf113b2da94054a4f299ff56">make_DelayedBinaryIsometricBooleanXor</a> ()</td></tr>
<tr class="separator:aa8fe42dacf113b2da94054a4f299ff56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ec8327dccb9be90b71dae9e41b18e0" id="r_af9ec8327dccb9be90b71dae9e41b18e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a>&lt; CompareOperation::EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9ec8327dccb9be90b71dae9e41b18e0">make_DelayedBinaryIsometricEqual</a> ()</td></tr>
<tr class="separator:af9ec8327dccb9be90b71dae9e41b18e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597a537c6e5a4bfa351e467a84d1da81" id="r_a597a537c6e5a4bfa351e467a84d1da81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a>&lt; CompareOperation::GREATER_THAN &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a597a537c6e5a4bfa351e467a84d1da81">make_DelayedBinaryIsometricGreaterThan</a> ()</td></tr>
<tr class="separator:a597a537c6e5a4bfa351e467a84d1da81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc3de58c455cfacd1c119b702995f34" id="r_a3cc3de58c455cfacd1c119b702995f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a>&lt; CompareOperation::LESS_THAN &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cc3de58c455cfacd1c119b702995f34">make_DelayedBinaryIsometricLessThan</a> ()</td></tr>
<tr class="separator:a3cc3de58c455cfacd1c119b702995f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfd223eeb93f13826a8e06b73b474b2" id="r_adcfd223eeb93f13826a8e06b73b474b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a>&lt; CompareOperation::GREATER_THAN_OR_EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcfd223eeb93f13826a8e06b73b474b2">make_DelayedBinaryIsometricGreaterThanOrEqual</a> ()</td></tr>
<tr class="separator:adcfd223eeb93f13826a8e06b73b474b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8d86c223bd5cb4f9d3b98485215bcc" id="r_a6b8d86c223bd5cb4f9d3b98485215bcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a>&lt; CompareOperation::LESS_THAN_OR_EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b8d86c223bd5cb4f9d3b98485215bcc">make_DelayedBinaryIsometricLessThanOrEqual</a> ()</td></tr>
<tr class="separator:a6b8d86c223bd5cb4f9d3b98485215bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b63c28c67d2ec406da35b7db6900879" id="r_a9b63c28c67d2ec406da35b7db6900879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a>&lt; CompareOperation::NOT_EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b63c28c67d2ec406da35b7db6900879">make_DelayedBinaryIsometricNotEqual</a> ()</td></tr>
<tr class="separator:a9b63c28c67d2ec406da35b7db6900879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75250f5b086a69c2d9f0edc7bc0b26b" id="r_ad75250f5b086a69c2d9f0edc7bc0b26b"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_  = double, typename InputValue_ , typename Index_ , class Operation_ &gt; </td></tr>
<tr class="memitem:ad75250f5b086a69c2d9f0edc7bc0b26b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; OutputValue_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad75250f5b086a69c2d9f0edc7bc0b26b">make_DelayedBinaryIsometricOperation</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, Index_ &gt; &gt; left, std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, Index_ &gt; &gt; right, Operation_ op)</td></tr>
<tr class="separator:ad75250f5b086a69c2d9f0edc7bc0b26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01457d379debb3db2613ecb9df8316f" id="r_ad01457d379debb3db2613ecb9df8316f"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double, typename Scalar_ &gt; </td></tr>
<tr class="memitem:ad01457d379debb3db2613ecb9df8316f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::ADD, true, InputValue_, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad01457d379debb3db2613ecb9df8316f">make_DelayedUnaryIsometricAddScalar</a> (Scalar_ scalar)</td></tr>
<tr class="separator:ad01457d379debb3db2613ecb9df8316f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07d7933d0c241538874bd1111f25b0c" id="r_af07d7933d0c241538874bd1111f25b0c"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename InputValue_  = double, typename Scalar_ &gt; </td></tr>
<tr class="memitem:af07d7933d0c241538874bd1111f25b0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::SUBTRACT, right_, InputValue_, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af07d7933d0c241538874bd1111f25b0c">make_DelayedUnaryIsometricSubtractScalar</a> (Scalar_ scalar)</td></tr>
<tr class="separator:af07d7933d0c241538874bd1111f25b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a41952679942c301ca014e88f24d4a" id="r_ac3a41952679942c301ca014e88f24d4a"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double, typename Scalar_ &gt; </td></tr>
<tr class="memitem:ac3a41952679942c301ca014e88f24d4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::MULTIPLY, true, InputValue_, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3a41952679942c301ca014e88f24d4a">make_DelayedUnaryIsometricMultiplyScalar</a> (Scalar_ scalar)</td></tr>
<tr class="separator:ac3a41952679942c301ca014e88f24d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ee0c65c8185ba2da929a7166cf3afe" id="r_a79ee0c65c8185ba2da929a7166cf3afe"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename InputValue_  = double, typename Scalar_ &gt; </td></tr>
<tr class="memitem:a79ee0c65c8185ba2da929a7166cf3afe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::DIVIDE, right_, InputValue_, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a79ee0c65c8185ba2da929a7166cf3afe">make_DelayedUnaryIsometricDivideScalar</a> (Scalar_ scalar)</td></tr>
<tr class="separator:a79ee0c65c8185ba2da929a7166cf3afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6add530e6659ffd8347c41a00145754" id="r_ac6add530e6659ffd8347c41a00145754"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename InputValue_  = double, typename Scalar_ &gt; </td></tr>
<tr class="memitem:ac6add530e6659ffd8347c41a00145754"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::POWER, right_, InputValue_, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6add530e6659ffd8347c41a00145754">make_DelayedUnaryIsometricPowerScalar</a> (Scalar_ scalar)</td></tr>
<tr class="separator:ac6add530e6659ffd8347c41a00145754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923fa6598ca3c15de1ad22770d7e57e9" id="r_a923fa6598ca3c15de1ad22770d7e57e9"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename InputValue_  = double, typename Scalar_ &gt; </td></tr>
<tr class="memitem:a923fa6598ca3c15de1ad22770d7e57e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::MODULO, right_, InputValue_, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a923fa6598ca3c15de1ad22770d7e57e9">make_DelayedUnaryIsometricModuloScalar</a> (Scalar_ scalar)</td></tr>
<tr class="separator:a923fa6598ca3c15de1ad22770d7e57e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ede92a92f04bc3cba00e757a7c76a3" id="r_a93ede92a92f04bc3cba00e757a7c76a3"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename InputValue_  = double, typename Scalar_ &gt; </td></tr>
<tr class="memitem:a93ede92a92f04bc3cba00e757a7c76a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::INTEGER_DIVIDE, right_, InputValue_, Scalar_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a93ede92a92f04bc3cba00e757a7c76a3">make_DelayedUnaryIsometricIntegerDivideScalar</a> (Scalar_ scalar)</td></tr>
<tr class="separator:a93ede92a92f04bc3cba00e757a7c76a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ba0e047f78f1f6736e99af01175d08" id="r_a89ba0e047f78f1f6736e99af01175d08"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:a89ba0e047f78f1f6736e99af01175d08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::ADD, true, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a89ba0e047f78f1f6736e99af01175d08">make_DelayedUnaryIsometricAddVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:a89ba0e047f78f1f6736e99af01175d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04a89253591265e5dfdeb736d7736e4" id="r_ae04a89253591265e5dfdeb736d7736e4"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:ae04a89253591265e5dfdeb736d7736e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::SUBTRACT, right_, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae04a89253591265e5dfdeb736d7736e4">make_DelayedUnaryIsometricSubtractVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:ae04a89253591265e5dfdeb736d7736e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f10fab490951d8ea9a6cff5e9dfea5" id="r_ad5f10fab490951d8ea9a6cff5e9dfea5"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:ad5f10fab490951d8ea9a6cff5e9dfea5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::MULTIPLY, true, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad5f10fab490951d8ea9a6cff5e9dfea5">make_DelayedUnaryIsometricMultiplyVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:ad5f10fab490951d8ea9a6cff5e9dfea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a652f625832bc7f2830eddc7369634a" id="r_a4a652f625832bc7f2830eddc7369634a"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:a4a652f625832bc7f2830eddc7369634a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::DIVIDE, right_, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4a652f625832bc7f2830eddc7369634a">make_DelayedUnaryIsometricDivideVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:a4a652f625832bc7f2830eddc7369634a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734eccb6121b6d018c431651d54ad146" id="r_a734eccb6121b6d018c431651d54ad146"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:a734eccb6121b6d018c431651d54ad146"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::POWER, right_, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a734eccb6121b6d018c431651d54ad146">make_DelayedUnaryIsometricPowerVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:a734eccb6121b6d018c431651d54ad146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c9d8feef1eaeebeff4c4e3d1f4af8f" id="r_ac0c9d8feef1eaeebeff4c4e3d1f4af8f"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:ac0c9d8feef1eaeebeff4c4e3d1f4af8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::MODULO, right_, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0c9d8feef1eaeebeff4c4e3d1f4af8f">make_DelayedUnaryIsometricModuloVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:ac0c9d8feef1eaeebeff4c4e3d1f4af8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a6e8445a71606ce80e6741a36e6fd8" id="r_ac5a6e8445a71606ce80e6741a36e6fd8"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:ac5a6e8445a71606ce80e6741a36e6fd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::INTEGER_DIVIDE, right_, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5a6e8445a71606ce80e6741a36e6fd8">make_DelayedUnaryIsometricIntegerDivideVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:ac5a6e8445a71606ce80e6741a36e6fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903e5ae4540777aeacfb0178ac4f8aac" id="r_a903e5ae4540777aeacfb0178ac4f8aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanNot.html">DelayedUnaryIsometricBooleanNot</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a903e5ae4540777aeacfb0178ac4f8aac">make_DelayedUnaryIsometricBooleanNot</a> ()</td></tr>
<tr class="separator:a903e5ae4540777aeacfb0178ac4f8aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cb992320bf02b04abc364bda96236b" id="r_a33cb992320bf02b04abc364bda96236b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalar.html">DelayedUnaryIsometricBooleanScalar</a>&lt; BooleanOperation::AND &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33cb992320bf02b04abc364bda96236b">make_DelayedUnaryIsometricBooleanAndScalar</a> (bool scalar)</td></tr>
<tr class="separator:a33cb992320bf02b04abc364bda96236b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5217ab83500651fbadd29960a12717e4" id="r_a5217ab83500651fbadd29960a12717e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalar.html">DelayedUnaryIsometricBooleanScalar</a>&lt; BooleanOperation::OR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5217ab83500651fbadd29960a12717e4">make_DelayedUnaryIsometricBooleanOrScalar</a> (bool scalar)</td></tr>
<tr class="separator:a5217ab83500651fbadd29960a12717e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1d71458318c276b9eb517085468291" id="r_aad1d71458318c276b9eb517085468291"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalar.html">DelayedUnaryIsometricBooleanScalar</a>&lt; BooleanOperation::XOR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad1d71458318c276b9eb517085468291">make_DelayedUnaryIsometricBooleanXorScalar</a> (bool scalar)</td></tr>
<tr class="separator:aad1d71458318c276b9eb517085468291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9531a951864544d30e69962792ff4eb8" id="r_a9531a951864544d30e69962792ff4eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalar.html">DelayedUnaryIsometricBooleanScalar</a>&lt; BooleanOperation::EQUAL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9531a951864544d30e69962792ff4eb8">make_DelayedUnaryIsometricBooleanEqualScalar</a> (bool scalar)</td></tr>
<tr class="separator:a9531a951864544d30e69962792ff4eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16dd5595a8c717671ffaa1874a82183" id="r_ab16dd5595a8c717671ffaa1874a82183"><td class="memTemplParams" colspan="2">template&lt;typename Vector_ &gt; </td></tr>
<tr class="memitem:ab16dd5595a8c717671ffaa1874a82183"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html">DelayedUnaryIsometricBooleanVector</a>&lt; BooleanOperation::AND, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab16dd5595a8c717671ffaa1874a82183">make_DelayedUnaryIsometricBooleanAndVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:ab16dd5595a8c717671ffaa1874a82183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38349aa7f5b0d127039fb4a0e875fc88" id="r_a38349aa7f5b0d127039fb4a0e875fc88"><td class="memTemplParams" colspan="2">template&lt;typename Vector_ &gt; </td></tr>
<tr class="memitem:a38349aa7f5b0d127039fb4a0e875fc88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html">DelayedUnaryIsometricBooleanVector</a>&lt; BooleanOperation::OR, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38349aa7f5b0d127039fb4a0e875fc88">make_DelayedUnaryIsometricBooleanOrVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:a38349aa7f5b0d127039fb4a0e875fc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792a5d736087c619ede48c38edecd4e3" id="r_a792a5d736087c619ede48c38edecd4e3"><td class="memTemplParams" colspan="2">template&lt;typename Vector_ &gt; </td></tr>
<tr class="memitem:a792a5d736087c619ede48c38edecd4e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html">DelayedUnaryIsometricBooleanVector</a>&lt; BooleanOperation::XOR, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a792a5d736087c619ede48c38edecd4e3">make_DelayedUnaryIsometricBooleanXorVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:a792a5d736087c619ede48c38edecd4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c548b744fc5df8cbf4b4dfde2c8f3c" id="r_a70c548b744fc5df8cbf4b4dfde2c8f3c"><td class="memTemplParams" colspan="2">template&lt;typename Vector_ &gt; </td></tr>
<tr class="memitem:a70c548b744fc5df8cbf4b4dfde2c8f3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html">DelayedUnaryIsometricBooleanVector</a>&lt; BooleanOperation::EQUAL, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70c548b744fc5df8cbf4b4dfde2c8f3c">make_DelayedUnaryIsometricBooleanEqualVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:a70c548b744fc5df8cbf4b4dfde2c8f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74741489b477f1a69d53a3c18c78a7b" id="r_aa74741489b477f1a69d53a3c18c78a7b"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double&gt; </td></tr>
<tr class="memitem:aa74741489b477f1a69d53a3c18c78a7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a>&lt; CompareOperation::EQUAL, InputValue_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa74741489b477f1a69d53a3c18c78a7b">make_DelayedUnaryIsometricEqualScalar</a> (InputValue_ scalar)</td></tr>
<tr class="separator:aa74741489b477f1a69d53a3c18c78a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983e14506dc8cf04295e92004c6b5c45" id="r_a983e14506dc8cf04295e92004c6b5c45"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double&gt; </td></tr>
<tr class="memitem:a983e14506dc8cf04295e92004c6b5c45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a>&lt; CompareOperation::GREATER_THAN, InputValue_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a983e14506dc8cf04295e92004c6b5c45">make_DelayedUnaryIsometricGreaterThanScalar</a> (InputValue_ scalar)</td></tr>
<tr class="separator:a983e14506dc8cf04295e92004c6b5c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ab6ad85c62223b39cdc3de21bef2e5" id="r_a12ab6ad85c62223b39cdc3de21bef2e5"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double&gt; </td></tr>
<tr class="memitem:a12ab6ad85c62223b39cdc3de21bef2e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a>&lt; CompareOperation::LESS_THAN, InputValue_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12ab6ad85c62223b39cdc3de21bef2e5">make_DelayedUnaryIsometricLessThanScalar</a> (InputValue_ scalar)</td></tr>
<tr class="separator:a12ab6ad85c62223b39cdc3de21bef2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7d7094d9684b053a203c5d00cdbf25" id="r_a7e7d7094d9684b053a203c5d00cdbf25"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double&gt; </td></tr>
<tr class="memitem:a7e7d7094d9684b053a203c5d00cdbf25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a>&lt; CompareOperation::GREATER_THAN_OR_EQUAL, InputValue_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7e7d7094d9684b053a203c5d00cdbf25">make_DelayedUnaryIsometricGreaterThanOrEqualScalar</a> (InputValue_ scalar)</td></tr>
<tr class="separator:a7e7d7094d9684b053a203c5d00cdbf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae674f4bc700c58d7a70f4e883e424198" id="r_ae674f4bc700c58d7a70f4e883e424198"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double&gt; </td></tr>
<tr class="memitem:ae674f4bc700c58d7a70f4e883e424198"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a>&lt; CompareOperation::LESS_THAN_OR_EQUAL, InputValue_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae674f4bc700c58d7a70f4e883e424198">make_DelayedUnaryIsometricLessThanOrEqualScalar</a> (InputValue_ scalar)</td></tr>
<tr class="separator:ae674f4bc700c58d7a70f4e883e424198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc5bc6de16e4bdd33a7e776f0df0dcc" id="r_a4fc5bc6de16e4bdd33a7e776f0df0dcc"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double&gt; </td></tr>
<tr class="memitem:a4fc5bc6de16e4bdd33a7e776f0df0dcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a>&lt; CompareOperation::NOT_EQUAL, InputValue_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4fc5bc6de16e4bdd33a7e776f0df0dcc">make_DelayedUnaryIsometricNotEqualScalar</a> (InputValue_ scalar)</td></tr>
<tr class="separator:a4fc5bc6de16e4bdd33a7e776f0df0dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cc635c8a64c607d3059ee2928f27bc" id="r_a74cc635c8a64c607d3059ee2928f27bc"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:a74cc635c8a64c607d3059ee2928f27bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a>&lt; CompareOperation::EQUAL, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74cc635c8a64c607d3059ee2928f27bc">make_DelayedUnaryIsometricEqualVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:a74cc635c8a64c607d3059ee2928f27bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa23e61b494d984a071aaff63b52b378" id="r_afa23e61b494d984a071aaff63b52b378"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:afa23e61b494d984a071aaff63b52b378"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a>&lt; CompareOperation::GREATER_THAN, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afa23e61b494d984a071aaff63b52b378">make_DelayedUnaryIsometricGreaterThanVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:afa23e61b494d984a071aaff63b52b378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3b9e1efdea505210a867916331e9f3" id="r_a2c3b9e1efdea505210a867916331e9f3"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:a2c3b9e1efdea505210a867916331e9f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a>&lt; CompareOperation::LESS_THAN, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2c3b9e1efdea505210a867916331e9f3">make_DelayedUnaryIsometricLessThanVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:a2c3b9e1efdea505210a867916331e9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ec71c086f23e2e15166fb55154686b" id="r_ae6ec71c086f23e2e15166fb55154686b"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:ae6ec71c086f23e2e15166fb55154686b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a>&lt; CompareOperation::GREATER_THAN_OR_EQUAL, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae6ec71c086f23e2e15166fb55154686b">make_DelayedUnaryIsometricGreaterThanOrEqualVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:ae6ec71c086f23e2e15166fb55154686b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad592a6164ae40e0ff6555ce0eeaac63a" id="r_ad592a6164ae40e0ff6555ce0eeaac63a"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:ad592a6164ae40e0ff6555ce0eeaac63a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a>&lt; CompareOperation::LESS_THAN_OR_EQUAL, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad592a6164ae40e0ff6555ce0eeaac63a">make_DelayedUnaryIsometricLessThanOrEqualVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:ad592a6164ae40e0ff6555ce0eeaac63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b643d84e2e356a6dfe472c2f374537a" id="r_a2b643d84e2e356a6dfe472c2f374537a"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_  = double, typename Vector_ &gt; </td></tr>
<tr class="memitem:a2b643d84e2e356a6dfe472c2f374537a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a>&lt; CompareOperation::NOT_EQUAL, InputValue_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b643d84e2e356a6dfe472c2f374537a">make_DelayedUnaryIsometricNotEqualVector</a> (Vector_ vector, bool by_row)</td></tr>
<tr class="separator:a2b643d84e2e356a6dfe472c2f374537a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6637de329390c622128024fc2f6d35b7" id="r_a6637de329390c622128024fc2f6d35b7"><td class="memTemplParams" colspan="2">template&lt;bool pass_ = true, typename InputValue_  = double&gt; </td></tr>
<tr class="memitem:a6637de329390c622128024fc2f6d35b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompare.html">DelayedUnaryIsometricSpecialCompare</a>&lt; SpecialCompareOperation::ISNAN, pass_, InputValue_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6637de329390c622128024fc2f6d35b7">make_DelayedUnaryIsometricIsnan</a> ()</td></tr>
<tr class="separator:a6637de329390c622128024fc2f6d35b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7b274bc022093c27942ca569ec3630" id="r_a2e7b274bc022093c27942ca569ec3630"><td class="memTemplParams" colspan="2">template&lt;bool pass_ = true, typename InputValue_  = double&gt; </td></tr>
<tr class="memitem:a2e7b274bc022093c27942ca569ec3630"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompare.html">DelayedUnaryIsometricSpecialCompare</a>&lt; SpecialCompareOperation::ISINF, pass_, InputValue_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e7b274bc022093c27942ca569ec3630">make_DelayedUnaryIsometricIsinf</a> ()</td></tr>
<tr class="separator:a2e7b274bc022093c27942ca569ec3630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349d487e245d6082d5131d2f84b74071" id="r_a349d487e245d6082d5131d2f84b74071"><td class="memTemplParams" colspan="2">template&lt;bool pass_ = true, typename InputValue_  = double&gt; </td></tr>
<tr class="memitem:a349d487e245d6082d5131d2f84b74071"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompare.html">DelayedUnaryIsometricSpecialCompare</a>&lt; SpecialCompareOperation::ISFINITE, pass_, InputValue_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a349d487e245d6082d5131d2f84b74071">make_DelayedUnaryIsometricIsfinite</a> ()</td></tr>
<tr class="separator:a349d487e245d6082d5131d2f84b74071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f23962ec258c833d2c28a8d19e12807" id="r_a6f23962ec258c833d2c28a8d19e12807"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_  = double, typename InputValue_ , typename Index_ , class Operation_ &gt; </td></tr>
<tr class="memitem:a6f23962ec258c833d2c28a8d19e12807"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; OutputValue_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6f23962ec258c833d2c28a8d19e12807">make_DelayedUnaryIsometricOperation</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, Index_ &gt; &gt; matrix, Operation_ operation)</td></tr>
<tr class="separator:a6f23962ec258c833d2c28a8d19e12807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4611e96f639b004ffaa1c17c435070" id="r_a2f4611e96f639b004ffaa1c17c435070"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double&gt; </td></tr>
<tr class="memitem:a2f4611e96f639b004ffaa1c17c435070"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a>&lt; CompareOperation::EQUAL, Value_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2f4611e96f639b004ffaa1c17c435070">make_DelayedUnaryIsometricSubstituteEqualScalar</a> (Value_ compared, Value_ substitute)</td></tr>
<tr class="separator:a2f4611e96f639b004ffaa1c17c435070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef464e027eeb29e2f82963520c26b0b" id="r_a3ef464e027eeb29e2f82963520c26b0b"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double&gt; </td></tr>
<tr class="memitem:a3ef464e027eeb29e2f82963520c26b0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a>&lt; CompareOperation::GREATER_THAN, Value_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ef464e027eeb29e2f82963520c26b0b">make_DelayedUnaryIsometricSubstituteGreaterThanScalar</a> (Value_ compared, Value_ substitute)</td></tr>
<tr class="separator:a3ef464e027eeb29e2f82963520c26b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d5b011082a2a524f8e9611d07f87a7" id="r_a00d5b011082a2a524f8e9611d07f87a7"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double&gt; </td></tr>
<tr class="memitem:a00d5b011082a2a524f8e9611d07f87a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a>&lt; CompareOperation::LESS_THAN, Value_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00d5b011082a2a524f8e9611d07f87a7">make_DelayedUnaryIsometricSubstituteLessThanScalar</a> (Value_ compared, Value_ substitute)</td></tr>
<tr class="separator:a00d5b011082a2a524f8e9611d07f87a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10a97c1ec31e3a60d68da0a3f544603" id="r_ac10a97c1ec31e3a60d68da0a3f544603"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double&gt; </td></tr>
<tr class="memitem:ac10a97c1ec31e3a60d68da0a3f544603"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a>&lt; CompareOperation::GREATER_THAN_OR_EQUAL, Value_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac10a97c1ec31e3a60d68da0a3f544603">make_DelayedUnaryIsometricSubstituteGreaterThanOrEqualScalar</a> (Value_ compared, Value_ substitute)</td></tr>
<tr class="separator:ac10a97c1ec31e3a60d68da0a3f544603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bb7e872341073b579ab59f99870f23" id="r_ab9bb7e872341073b579ab59f99870f23"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double&gt; </td></tr>
<tr class="memitem:ab9bb7e872341073b579ab59f99870f23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a>&lt; CompareOperation::LESS_THAN_OR_EQUAL, Value_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab9bb7e872341073b579ab59f99870f23">make_DelayedUnaryIsometricSubstituteLessThanOrEqualScalar</a> (Value_ compared, Value_ substitute)</td></tr>
<tr class="separator:ab9bb7e872341073b579ab59f99870f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9f40dd430934d2693a21d09954b103" id="r_a4b9f40dd430934d2693a21d09954b103"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double&gt; </td></tr>
<tr class="memitem:a4b9f40dd430934d2693a21d09954b103"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a>&lt; CompareOperation::NOT_EQUAL, Value_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b9f40dd430934d2693a21d09954b103">make_DelayedUnaryIsometricSubstituteNotEqualScalar</a> (Value_ compared, Value_ substitute)</td></tr>
<tr class="separator:a4b9f40dd430934d2693a21d09954b103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cd5051271fda51be03670848e17bf4" id="r_a90cd5051271fda51be03670848e17bf4"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double, typename Vector_  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a90cd5051271fda51be03670848e17bf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a>&lt; CompareOperation::EQUAL, Value_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a90cd5051271fda51be03670848e17bf4">make_DelayedUnaryIsometricSubstituteEqualVector</a> (Vector_ compared, Vector_ substitute, bool by_row)</td></tr>
<tr class="separator:a90cd5051271fda51be03670848e17bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60163836a688ca8b662affec5f3ac92b" id="r_a60163836a688ca8b662affec5f3ac92b"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double, typename Vector_  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a60163836a688ca8b662affec5f3ac92b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a>&lt; CompareOperation::GREATER_THAN, Value_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60163836a688ca8b662affec5f3ac92b">make_DelayedUnaryIsometricSubstituteGreaterThanVector</a> (Vector_ compared, Vector_ substitute, bool by_row)</td></tr>
<tr class="separator:a60163836a688ca8b662affec5f3ac92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a478db711543357f581bbe2d241421f" id="r_a0a478db711543357f581bbe2d241421f"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double, typename Vector_  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a0a478db711543357f581bbe2d241421f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a>&lt; CompareOperation::LESS_THAN, Value_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a478db711543357f581bbe2d241421f">make_DelayedUnaryIsometricSubstituteLessThanVector</a> (Vector_ compared, Vector_ substitute, bool by_row)</td></tr>
<tr class="separator:a0a478db711543357f581bbe2d241421f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf046b4ba48222d084a4a1cd84b560c7" id="r_adf046b4ba48222d084a4a1cd84b560c7"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double, typename Vector_  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:adf046b4ba48222d084a4a1cd84b560c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a>&lt; CompareOperation::GREATER_THAN_OR_EQUAL, Value_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf046b4ba48222d084a4a1cd84b560c7">make_DelayedUnaryIsometricSubstituteGreaterThanOrEqualVector</a> (Vector_ compared, Vector_ substitute, bool by_row)</td></tr>
<tr class="separator:adf046b4ba48222d084a4a1cd84b560c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f450e1cbcd4fbd7427dc5d15392cc4" id="r_a11f450e1cbcd4fbd7427dc5d15392cc4"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double, typename Vector_  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:a11f450e1cbcd4fbd7427dc5d15392cc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a>&lt; CompareOperation::LESS_THAN_OR_EQUAL, Value_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a11f450e1cbcd4fbd7427dc5d15392cc4">make_DelayedUnaryIsometricSubstituteLessThanOrEqualVector</a> (Vector_ compared, Vector_ substitute, bool by_row)</td></tr>
<tr class="separator:a11f450e1cbcd4fbd7427dc5d15392cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65490ea8c0ee4d29af2d51d10ba23ca" id="r_ad65490ea8c0ee4d29af2d51d10ba23ca"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double, typename Vector_  = std::vector&lt;Value_&gt;&gt; </td></tr>
<tr class="memitem:ad65490ea8c0ee4d29af2d51d10ba23ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a>&lt; CompareOperation::NOT_EQUAL, Value_, Vector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad65490ea8c0ee4d29af2d51d10ba23ca">make_DelayedUnaryIsometricSubstituteNotEqualVector</a> (Vector_ compared, Vector_ substitute, bool by_row)</td></tr>
<tr class="separator:ad65490ea8c0ee4d29af2d51d10ba23ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ceae1b11636c213088c6d923fad313" id="r_a42ceae1b11636c213088c6d923fad313"><td class="memTemplParams" colspan="2">template&lt;bool pass_ = true, typename Value_  = double&gt; </td></tr>
<tr class="memitem:a42ceae1b11636c213088c6d923fad313"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstitute.html">DelayedUnaryIsometricSpecialSubstitute</a>&lt; SpecialCompareOperation::ISNAN, pass_, Value_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a42ceae1b11636c213088c6d923fad313">make_DelayedUnaryIsometricSubstituteIsnan</a> (Value_ substitute)</td></tr>
<tr class="separator:a42ceae1b11636c213088c6d923fad313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5ab6b324705fb16662933815c589c9" id="r_a9d5ab6b324705fb16662933815c589c9"><td class="memTemplParams" colspan="2">template&lt;bool pass_ = true, typename Value_  = double&gt; </td></tr>
<tr class="memitem:a9d5ab6b324705fb16662933815c589c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstitute.html">DelayedUnaryIsometricSpecialSubstitute</a>&lt; SpecialCompareOperation::ISINF, pass_, Value_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d5ab6b324705fb16662933815c589c9">make_DelayedUnaryIsometricSubstituteIsinf</a> (Value_ substitute)</td></tr>
<tr class="separator:a9d5ab6b324705fb16662933815c589c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a1194718021bcd4b97a6c420ffbdfa" id="r_a87a1194718021bcd4b97a6c420ffbdfa"><td class="memTemplParams" colspan="2">template&lt;bool pass_ = true, typename Value_  = double&gt; </td></tr>
<tr class="memitem:a87a1194718021bcd4b97a6c420ffbdfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstitute.html">DelayedUnaryIsometricSpecialSubstitute</a>&lt; SpecialCompareOperation::ISFINITE, pass_, Value_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a87a1194718021bcd4b97a6c420ffbdfa">make_DelayedUnaryIsometricSubstituteIsfinite</a> (Value_ substitute)</td></tr>
<tr class="separator:a87a1194718021bcd4b97a6c420ffbdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c8b88eeaa5fcbb1e5d47d020eb98ea" id="r_ab4c8b88eeaa5fcbb1e5d47d020eb98ea"><td class="memTemplParams" colspan="2">template&lt;typename ValueOut_ , typename IndexOut_ , typename ValueIn_ , typename IndexIn_ &gt; </td></tr>
<tr class="memitem:ab4c8b88eeaa5fcbb1e5d47d020eb98ea"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; ValueOut_, IndexOut_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4c8b88eeaa5fcbb1e5d47d020eb98ea">make_DelayedCast</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; ValueIn_, IndexIn_ &gt; &gt; p)</td></tr>
<tr class="separator:ab4c8b88eeaa5fcbb1e5d47d020eb98ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2756af73514cbf89b42f5abd7997cc" id="r_a3b2756af73514cbf89b42f5abd7997cc"><td class="memTemplParams" colspan="2">template&lt;class Values_ , class RowIndices_ , class ColumnIndices_ &gt; </td></tr>
<tr class="memitem:a3b2756af73514cbf89b42f5abd7997cc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b2756af73514cbf89b42f5abd7997cc">compress_sparse_triplets</a> (size_t nrow, size_t ncol, Values_ &amp;values, RowIndices_ &amp;row_indices, ColumnIndices_ &amp;column_indices, bool csr)</td></tr>
<tr class="separator:a3b2756af73514cbf89b42f5abd7997cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac004bfb30ee5623bec14d3783c2cc21e" id="r_ac004bfb30ee5623bec14d3783c2cc21e"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Count_ &gt; </td></tr>
<tr class="memitem:ac004bfb30ee5623bec14d3783c2cc21e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac004bfb30ee5623bec14d3783c2cc21e">count_compressed_sparse_non_zeros</a> (const <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, bool row, Count_ *output, const <a class="el" href="structtatami_1_1CountCompressedSparseNonZerosOptions.html">CountCompressedSparseNonZerosOptions</a> &amp;options)</td></tr>
<tr class="separator:ac004bfb30ee5623bec14d3783c2cc21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadd3c0f36b8cbde2d360a8babba163f" id="r_aaadd3c0f36b8cbde2d360a8babba163f"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_ , typename InputIndex_ , typename Pointer_ , typename StoredValue_ , typename StoredIndex_ &gt; </td></tr>
<tr class="memitem:aaadd3c0f36b8cbde2d360a8babba163f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaadd3c0f36b8cbde2d360a8babba163f">fill_compressed_sparse_contents</a> (const <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, bool row, const Pointer_ *pointers, StoredValue_ *output_value, StoredIndex_ *output_index, const <a class="el" href="structtatami_1_1FillCompressedSparseContentsOptions.html">FillCompressedSparseContentsOptions</a> &amp;options)</td></tr>
<tr class="separator:aaadd3c0f36b8cbde2d360a8babba163f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dc21541e6db5a8896049a0647c4230" id="r_a05dc21541e6db5a8896049a0647c4230"><td class="memTemplParams" colspan="2">template&lt;typename StoredValue_ , typename StoredIndex_ , typename StoredPointer_  = size_t, typename InputValue_ , typename InputIndex_ &gt; </td></tr>
<tr class="memitem:a05dc21541e6db5a8896049a0647c4230"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1CompressedSparseContents.html">CompressedSparseContents</a>&lt; StoredValue_, StoredIndex_, StoredPointer_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05dc21541e6db5a8896049a0647c4230">retrieve_compressed_sparse_contents</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, bool row, const <a class="el" href="structtatami_1_1RetrieveCompressedSparseContentsOptions.html">RetrieveCompressedSparseContentsOptions</a> &amp;options)</td></tr>
<tr class="separator:a05dc21541e6db5a8896049a0647c4230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaf90f62fd2ccfcd1c35ef291f7f489" id="r_a2eaf90f62fd2ccfcd1c35ef291f7f489"><td class="memTemplParams" colspan="2">template&lt;typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, typename StoredIndex_  = Index_, typename InputValue_ , typename InputIndex_ &gt; </td></tr>
<tr class="memitem:a2eaf90f62fd2ccfcd1c35ef291f7f489"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2eaf90f62fd2ccfcd1c35ef291f7f489">convert_to_compressed_sparse</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, bool row, const <a class="el" href="structtatami_1_1ConvertToCompressedSparseOptions.html">ConvertToCompressedSparseOptions</a> &amp;options)</td></tr>
<tr class="separator:a2eaf90f62fd2ccfcd1c35ef291f7f489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c71daf9bdb1ea8d3e16f35c5b15facc" id="r_a5c71daf9bdb1ea8d3e16f35c5b15facc"><td class="memTemplParams" colspan="2">template&lt;typename StoredValue_ , typename StoredIndex_ , typename InputValue_ , typename InputIndex_ &gt; </td></tr>
<tr class="memitem:a5c71daf9bdb1ea8d3e16f35c5b15facc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1FragmentedSparseContents.html">FragmentedSparseContents</a>&lt; StoredValue_, StoredIndex_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c71daf9bdb1ea8d3e16f35c5b15facc">retrieve_fragmented_sparse_contents</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, bool row, const <a class="el" href="structtatami_1_1RetrieveFragmentedSparseContentsOptions.html">RetrieveFragmentedSparseContentsOptions</a> &amp;options)</td></tr>
<tr class="separator:a5c71daf9bdb1ea8d3e16f35c5b15facc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add29754647077a82209dfe6ba78cd2b5" id="r_add29754647077a82209dfe6ba78cd2b5"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename StoredValue_  = Value_, typename StoredIndex_  = Index_, typename InputValue_ , typename InputIndex_ &gt; </td></tr>
<tr class="memitem:add29754647077a82209dfe6ba78cd2b5"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add29754647077a82209dfe6ba78cd2b5">convert_to_fragmented_sparse</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, bool row, const <a class="el" href="structtatami_1_1ConvertToFragmentedSparseOptions.html">ConvertToFragmentedSparseOptions</a> &amp;options)</td></tr>
<tr class="separator:add29754647077a82209dfe6ba78cd2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50326a317ed80de39a1a872e098b2b2" id="r_ad50326a317ed80de39a1a872e098b2b2"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ad50326a317ed80de39a1a872e098b2b2"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad50326a317ed80de39a1a872e098b2b2">make_DelayedSubsetBlock</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; matrix, Index_ subset_start, Index_ subset_length, bool by_row)</td></tr>
<tr class="separator:ad50326a317ed80de39a1a872e098b2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fad1d2a2553899a7860521d6284f50" id="r_a77fad1d2a2553899a7860521d6284f50"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class SubsetStorage_ &gt; </td></tr>
<tr class="memitem:a77fad1d2a2553899a7860521d6284f50"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77fad1d2a2553899a7860521d6284f50">make_DelayedSubset</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; matrix, SubsetStorage_ subset, bool by_row)</td></tr>
<tr class="separator:a77fad1d2a2553899a7860521d6284f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb635e5ca22b18c04980c08643f2875" id="r_aedb635e5ca22b18c04980c08643f2875"><td class="memTemplParams" colspan="2">template&lt;bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </td></tr>
<tr class="memitem:aedb635e5ca22b18c04980c08643f2875"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aedb635e5ca22b18c04980c08643f2875">consecutive_extractor</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, bool row, Index_ iter_start, Index_ iter_length, Args_ &amp;&amp;... args)</td></tr>
<tr class="separator:aedb635e5ca22b18c04980c08643f2875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52a806e3f13a68741a9e1f77dccab14" id="r_ab52a806e3f13a68741a9e1f77dccab14"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Size_ &gt; </td></tr>
<tr class="memitem:ab52a806e3f13a68741a9e1f77dccab14"><td class="memTemplItemLeft" align="right" valign="top">Value_ *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab52a806e3f13a68741a9e1f77dccab14">copy_n</a> (const Value_ *input, Size_ n, Value_ *output)</td></tr>
<tr class="separator:ab52a806e3f13a68741a9e1f77dccab14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1514cda61f96e93a9cbc656f742a044" id="r_ac1514cda61f96e93a9cbc656f742a044"><td class="memTemplParams" colspan="2">template&lt;bool sparse_, bool oracle_, typename Value_ , typename Index_ , typename ... Args_&gt; </td></tr>
<tr class="memitem:ac1514cda61f96e93a9cbc656f742a044"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac1514cda61f96e93a9cbc656f742a044">new_extractor</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, bool row, <a class="el" href="#a812af1bfb04773bf28da8549c3e6e5ee">MaybeOracle</a>&lt; oracle_, Index_ &gt; oracle, Args_ &amp;&amp;... args)</td></tr>
<tr class="separator:ac1514cda61f96e93a9cbc656f742a044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a08e0387bc00e8045a0364d6e35d120" id="r_a5a08e0387bc00e8045a0364d6e35d120"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = true, class Function_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a5a08e0387bc00e8045a0364d6e35d120"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a08e0387bc00e8045a0364d6e35d120">parallelize</a> (Function_ fun, Index_ tasks, int threads)</td></tr>
<tr class="separator:a5a08e0387bc00e8045a0364d6e35d120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01c93a616eb99f6a17861a8b19f7ee0" id="r_af01c93a616eb99f6a17861a8b19f7ee0"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , class Function_ &gt; </td></tr>
<tr class="memitem:af01c93a616eb99f6a17861a8b19f7ee0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af01c93a616eb99f6a17861a8b19f7ee0">process_consecutive_indices</a> (const Index_ *indices, Index_ length, Function_ fun)</td></tr>
<tr class="separator:af01c93a616eb99f6a17861a8b19f7ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab008bae4e33a408de29e9fc49d0f902c" id="r_ab008bae4e33a408de29e9fc49d0f902c"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ab008bae4e33a408de29e9fc49d0f902c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab008bae4e33a408de29e9fc49d0f902c">wrap_shared_ptr</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *ptr)</td></tr>
<tr class="separator:ab008bae4e33a408de29e9fc49d0f902c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Flexible representations for matrix data. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a92f2deb44e0a3cb1c569a379c6facbf0" name="a92f2deb44e0a3cb1c569a379c6facbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f2deb44e0a3cb1c569a379c6facbf0">&#9670;&#160;</a></span>DenseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool oracle_, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a92f2deb44e0a3cb1c569a379c6facbf0">tatami::DenseExtractor</a> = typename std::conditional&lt;oracle_, <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt;Value_, Index_&gt;, <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt;Value_, Index_&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oracle_</td><td>Whether to use an oracle-aware interface. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Type alias that switches between <code><a class="el" href="classtatami_1_1OracularDenseExtractor.html" title="Extract an element of the target dimension in dense form with an oracle.">OracularDenseExtractor</a></code> and <code><a class="el" href="classtatami_1_1MyopicDenseExtractor.html" title="Extract an element of the target dimension in dense form without an oracle.">MyopicDenseExtractor</a></code> depending on <code>oracle_</code>. Intended for templated class definitions, where setting <code>oracle_</code> can define subclasses for both interfaces. </p>

</div>
</div>
<a id="a213ab58ba31e5b5cee3b66ab54d86055" name="a213ab58ba31e5b5cee3b66ab54d86055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213ab58ba31e5b5cee3b66ab54d86055">&#9670;&#160;</a></span>SparseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool oracle_, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a213ab58ba31e5b5cee3b66ab54d86055">tatami::SparseExtractor</a> = typename std::conditional&lt;oracle_, <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt;Value_, Index_&gt;, <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt;Value_, Index_&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oracle_</td><td>Whether to use an oracle-aware interface. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Type alias that switches between <code><a class="el" href="classtatami_1_1OracularSparseExtractor.html" title="Extract an element of the target dimension in sparse form with an oracle.">OracularSparseExtractor</a></code> and <code><a class="el" href="classtatami_1_1MyopicSparseExtractor.html" title="Extract an element of the target dimension in sparse form without an oracle.">MyopicSparseExtractor</a></code> depending on <code>oracle_</code>. Intended for templated class definitions, where setting <code>oracle_</code> can define subclasses for both interfaces. </p>

</div>
</div>
<a id="a1a9c70ebcfa94bba3fea89202868f22f" name="a1a9c70ebcfa94bba3fea89202868f22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9c70ebcfa94bba3fea89202868f22f">&#9670;&#160;</a></span>VectorPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1a9c70ebcfa94bba3fea89202868f22f">tatami::VectorPtr</a> = std::shared_ptr&lt;const std::vector&lt;Index_&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Pointer to a vector, typically containing unique and sorted indices. We use a shared pointer so that we can cheaply re-use the same sequence of indices for multiple <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> objects. </p>

</div>
</div>
<a id="ae0438743ada096f37f307404851849ff" name="ae0438743ada096f37f307404851849ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0438743ada096f37f307404851849ff">&#9670;&#160;</a></span>NumericMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae0438743ada096f37f307404851849ff">tatami::NumericMatrix</a> = <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt;double, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenient shorthand for the most common use case of double-precision matrices. </p>

</div>
</div>
<a id="a83f5bea1c12d21f81732d6abd0665554" name="a83f5bea1c12d21f81732d6abd0665554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f5bea1c12d21f81732d6abd0665554">&#9670;&#160;</a></span>ElementType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Array_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a83f5bea1c12d21f81732d6abd0665554">tatami::ElementType</a> = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(std::declval&lt;Array_&gt;()[0])&gt;::type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array_</td><td>Some array of values that are accessed with <code>[</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Extract the type of array elements, after stripping away references and <code>const</code>-ness. </p>

</div>
</div>
<a id="a812af1bfb04773bf28da8549c3e6e5ee" name="a812af1bfb04773bf28da8549c3e6e5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812af1bfb04773bf28da8549c3e6e5ee">&#9670;&#160;</a></span>MaybeOracle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool oracle_, typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a812af1bfb04773bf28da8549c3e6e5ee">tatami::MaybeOracle</a> = typename std::conditional&lt;oracle_, std::shared_ptr&lt;const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt;Index_&gt; &gt;, bool&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oracle_</td><td>Whether an oracle should be supplied. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Maybe an <code><a class="el" href="classtatami_1_1Oracle.html" title="Predict future access requests on the target dimension.">Oracle</a></code>, maybe a placeholder boolean, depending on <code>oracle_</code>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0a2ecaf58e2b69bb4a808e814aeb16a1" name="a0a2ecaf58e2b69bb4a808e814aeb16a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2ecaf58e2b69bb4a808e814aeb16a1">&#9670;&#160;</a></span>DimensionSelectionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a0a2ecaf58e2b69bb4a808e814aeb16a1">tatami::DimensionSelectionType</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Selection of dimension elements:</p>
<ul>
<li><code>FULL</code>: selects the full extent of the dimension, i.e., all elements.</li>
<li><code>BLOCK</code>: selects a contiguous block of elements in the dimension.</li>
<li><code>INDEX</code>: selects a sorted and unique array of indices of dimension elements.</li>
</ul>
<p>This corresponds to the various overloads of <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> methods (e.g., <code><a class="el" href="classtatami_1_1Matrix.html#a168f0e932b5503c9bfc5dbd42754a7a5">Matrix::dense_row()</a></code>), each of which extracts a different selection of elements from the non-target dimension. </p>

</div>
</div>
<a id="a9050a4b119e027638175c38cc9bbede8" name="a9050a4b119e027638175c38cc9bbede8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9050a4b119e027638175c38cc9bbede8">&#9670;&#160;</a></span>ArithmeticOperation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a9050a4b119e027638175c38cc9bbede8">tatami::ArithmeticOperation</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of arithmetic operation.</p>
<p>The <code>INTEGER_DIVIDE</code> refers to a floored division, which differs from truncation for negative quotients. This choice is based on R's <code>%/%</code>, which in turn is based on a recommendation by Donald Knuth.</p>
<p>Similarly, <code>x MODULO y</code> is defined as <code>x - floor(x / y)</code>, based on the same floored division. Note that this differs from the built-in <code>%</code> operator, which performs truncation. </p>

</div>
</div>
<a id="a4e5eea599200bfb6bc42f184118be28a" name="a4e5eea599200bfb6bc42f184118be28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5eea599200bfb6bc42f184118be28a">&#9670;&#160;</a></span>BooleanOperation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a4e5eea599200bfb6bc42f184118be28a">tatami::BooleanOperation</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of boolean operation. </p>

</div>
</div>
<a id="a89475b46f681dd39b9926ced507240cc" name="a89475b46f681dd39b9926ced507240cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89475b46f681dd39b9926ced507240cc">&#9670;&#160;</a></span>CompareOperation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a89475b46f681dd39b9926ced507240cc">tatami::CompareOperation</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of comparison operation. </p>

</div>
</div>
<a id="a4ef624db40413dabc3fea554fc936d39" name="a4ef624db40413dabc3fea554fc936d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef624db40413dabc3fea554fc936d39">&#9670;&#160;</a></span>SpecialCompareOperation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a4ef624db40413dabc3fea554fc936d39">tatami::SpecialCompareOperation</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of comparison operation for special IEEE values. </p>

</div>
</div>
<a id="a6c4e0b21d1826723cc5ea81d889a73e5" name="a6c4e0b21d1826723cc5ea81d889a73e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4e0b21d1826723cc5ea81d889a73e5">&#9670;&#160;</a></span>SomeNumericType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a6c4e0b21d1826723cc5ea81d889a73e5">tatami::SomeNumericType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Types supported in <code><a class="el" href="classtatami_1_1SomeNumericArray.html" title="Array of some numeric type, determined at runtime.">SomeNumericArray</a></code>. The letters indicate whether it is an integer (I), unsigned integer (U) or a float, while the numbers specify the number of bits for the type. So, for example, <code>U16</code> is an unsigned 16-bit integer, while <code>F64</code> is a <code>double</code>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad06cf62ba0b58e240aed427379c2ac38" name="ad06cf62ba0b58e240aed427379c2ac38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06cf62ba0b58e240aed427379c2ac38">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StoredValue_ , typename InputValue_ , typename InputIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row_major</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoredValue_ *</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1ConvertToDenseOptions.html">ConvertToDenseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for the indices in the input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row_major</td><td>Whether to store the output as a row-major matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">store</td><td>Pointer to an array of length equal to the product of the dimensions of <code>matrix</code>. On output, this is filled with values from <code>matrix</code> in row- or column-major format depending on <code>row_major</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad18e5d06e9adc78acdf0924e7e3d8fbd" name="ad18e5d06e9adc78acdf0924e7e3d8fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18e5d06e9adc78acdf0924e7e3d8fbd">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, typename InputValue_ , typename InputIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row_major</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1ConvertToDenseOptions.html">ConvertToDenseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for the indices in the input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">row_major</td><td>Whether to return a row-major matrix. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> with the same dimensions and type as the matrix referenced by <code>matrix</code>. If <code>row_major = true</code>, the matrix is row-major, otherwise it is column-major. </dd></dl>

</div>
</div>
<a id="a07c1d1f96ea3a59d9f6106b17873d494" name="a07c1d1f96ea3a59d9f6106b17873d494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c1d1f96ea3a59d9f6106b17873d494">&#9670;&#160;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input_ , typename Output_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::transpose </td>
          <td>(</td>
          <td class="paramtype">const Input_ *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>ncol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>input_stride</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>output_stride</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_</td><td>Input type. </td></tr>
    <tr><td class="paramname">Output_</td><td>Output type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing a row-major matrix with <code>nrow</code> rows and <code>ncol</code> columns. Elements within each row should be contiguous but consecutive rows can be separated by a constant stride, see <code>input_stride</code>. The array should have at least <code>(nrow - 1) * input_stride + ncol</code> addressable elements. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nrow</td><td>Number of rows in the matrix stored at <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ncol</td><td>Number of columns in the matrix stored at <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">input_stride</td><td>Distance between corresponding entries on consecutive rows of the <code>input</code> matrix. This should be greater than or equal to <code>ncol</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array in which to store the transpose of the matrix in <code>input</code>. On output, this stores a row-major matrix with <code>ncol</code> rows and <code>nrow</code> columns. Elements within each row should be contiguous but consecutive rows can be separated by a constant stride, see <code>output_stride</code>. The array should have at least <code>(ncol - 1) * output_stride + nrow</code> addressable elements. It is assumed that <code>output</code> does not alias <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">output_stride</td><td>Distance between corresponding entries on consecutive rows of the <code>output</code> matrix. This should be greater than or equal to <code>nrow</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is intended for developers of <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> subclasses who need to do some transposition, e.g., for dense chunks during caching. The <code>*_stride</code> arguments allow <code>input</code> and <code>output</code> to refer to submatrices of larger arrays.</p>
<p>The argument descriptions refer to row-major matrices only for the sake of convenience. This function is equally applicable to column-major matrices, just replace all instances of "row" with "column" and vice versa. </p>

</div>
</div>
<a id="a86be7b06c9d13b25f9ff04eed87430a7" name="a86be7b06c9d13b25f9ff04eed87430a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86be7b06c9d13b25f9ff04eed87430a7">&#9670;&#160;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input_ , typename Output_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::transpose </td>
          <td>(</td>
          <td class="paramtype">const Input_ *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>ncol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_</td><td>Input type. </td></tr>
    <tr><td class="paramname">Output_</td><td>Output type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing a row-major matrix with <code>nrow</code> rows and <code>ncol</code> columns. The array should have at least <code>nrow * ncol</code> addressable elements, and all elements should be stored contiguously in the array. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nrow</td><td>Number of rows in the matrix stored at <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ncol</td><td>Number of columns in the matrix stored at <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length <code>nrow * ncol</code>. On output, this will hold the transpose of the matrix represented by <code>input</code>, i.e., a row-major matrix with <code>ncol</code> rows and <code>nrow</code> columns. It is assumed that <code>output</code> does not alias <code>input</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is intended for developers of <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> subclasses who need to do some transposition, e.g., for dense chunks during caching. Users should instead construct a <code><a class="el" href="classtatami_1_1DelayedTranspose.html" title="Delayed transposition of a matrix.">DelayedTranspose</a></code> object to perform a memory-efficient delayed transposition, or use <code><a class="el" href="#ad06cf62ba0b58e240aed427379c2ac38">convert_to_dense()</a></code> to convert their dense data into the desired storage layout.</p>
<p>The argument descriptions refer to row-major matrices only for the sake of convenience. This function is equally applicable to column-major matrices, just replace all instances of "row" with "column" and vice versa. </p>

</div>
</div>
<a id="a389ebbcd018702d2922b795c08721e78" name="a389ebbcd018702d2922b795c08721e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389ebbcd018702d2922b795c08721e78">&#9670;&#160;</a></span>make_DelayedBinaryIsometricAdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::ADD &gt; tatami::make_DelayedBinaryIsometricAdd </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary addition, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a3647a1ae34a5e8a47b28631da1032fc9" name="a3647a1ae34a5e8a47b28631da1032fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3647a1ae34a5e8a47b28631da1032fc9">&#9670;&#160;</a></span>make_DelayedBinaryIsometricSubtract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::SUBTRACT &gt; tatami::make_DelayedBinaryIsometricSubtract </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary subtraction, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a01370b082642ae6c745ff9bb1600a87f" name="a01370b082642ae6c745ff9bb1600a87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01370b082642ae6c745ff9bb1600a87f">&#9670;&#160;</a></span>make_DelayedBinaryIsometricMultiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::MULTIPLY &gt; tatami::make_DelayedBinaryIsometricMultiply </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary multiplication, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a42d4e17808d85624398f7f25ee36e635" name="a42d4e17808d85624398f7f25ee36e635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d4e17808d85624398f7f25ee36e635">&#9670;&#160;</a></span>make_DelayedBinaryIsometricDivide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::DIVIDE &gt; tatami::make_DelayedBinaryIsometricDivide </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary division, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a1ed3cf4520b14ba2e85cf4afb32a1fdc" name="a1ed3cf4520b14ba2e85cf4afb32a1fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed3cf4520b14ba2e85cf4afb32a1fdc">&#9670;&#160;</a></span>make_DelayedBinaryIsometricPower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::POWER &gt; tatami::make_DelayedBinaryIsometricPower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary power, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a20f8a13127f659c6362d53aa51ed33d8" name="a20f8a13127f659c6362d53aa51ed33d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f8a13127f659c6362d53aa51ed33d8">&#9670;&#160;</a></span>make_DelayedBinaryIsometricModulo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::MODULO &gt; tatami::make_DelayedBinaryIsometricModulo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary modulo. </dd></dl>

</div>
</div>
<a id="ae63d9c1ef029246b216b8a5af33b84ca" name="ae63d9c1ef029246b216b8a5af33b84ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63d9c1ef029246b216b8a5af33b84ca">&#9670;&#160;</a></span>make_DelayedBinaryIsometricIntegerDivide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmetic.html">DelayedBinaryIsometricArithmetic</a>&lt; ArithmeticOperation::INTEGER_DIVIDE &gt; tatami::make_DelayedBinaryIsometricIntegerDivide </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed binary integer division. </dd></dl>

</div>
</div>
<a id="ae8e1b122c59a6aca0b21574915b4b1e9" name="ae8e1b122c59a6aca0b21574915b4b1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e1b122c59a6aca0b21574915b4b1e9">&#9670;&#160;</a></span>make_DelayedBinaryIsometricBooleanEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryIsometricBoolean.html">DelayedBinaryIsometricBoolean</a>&lt; BooleanOperation::EQUAL &gt; tatami::make_DelayedBinaryIsometricBooleanEqual </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary boolean equivalence operation, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a57cbe03c715d9da7a0f1698a1f13b3b3" name="a57cbe03c715d9da7a0f1698a1f13b3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cbe03c715d9da7a0f1698a1f13b3b3">&#9670;&#160;</a></span>make_DelayedBinaryIsometricBooleanAnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryIsometricBoolean.html">DelayedBinaryIsometricBoolean</a>&lt; BooleanOperation::AND &gt; tatami::make_DelayedBinaryIsometricBooleanAnd </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary AND comparison, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a6e16348dab1840e17a24cb06c1dcf2f3" name="a6e16348dab1840e17a24cb06c1dcf2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e16348dab1840e17a24cb06c1dcf2f3">&#9670;&#160;</a></span>make_DelayedBinaryIsometricBooleanOr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryIsometricBoolean.html">DelayedBinaryIsometricBoolean</a>&lt; BooleanOperation::OR &gt; tatami::make_DelayedBinaryIsometricBooleanOr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary OR comparison, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="aa8fe42dacf113b2da94054a4f299ff56" name="aa8fe42dacf113b2da94054a4f299ff56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8fe42dacf113b2da94054a4f299ff56">&#9670;&#160;</a></span>make_DelayedBinaryIsometricBooleanXor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryIsometricBoolean.html">DelayedBinaryIsometricBoolean</a>&lt; BooleanOperation::XOR &gt; tatami::make_DelayedBinaryIsometricBooleanXor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary XOR comparison, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="af9ec8327dccb9be90b71dae9e41b18e0" name="af9ec8327dccb9be90b71dae9e41b18e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ec8327dccb9be90b71dae9e41b18e0">&#9670;&#160;</a></span>make_DelayedBinaryIsometricEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a>&lt; CompareOperation::EQUAL &gt; tatami::make_DelayedBinaryIsometricEqual </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary equality comparison, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a597a537c6e5a4bfa351e467a84d1da81" name="a597a537c6e5a4bfa351e467a84d1da81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597a537c6e5a4bfa351e467a84d1da81">&#9670;&#160;</a></span>make_DelayedBinaryIsometricGreaterThan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a>&lt; CompareOperation::GREATER_THAN &gt; tatami::make_DelayedBinaryIsometricGreaterThan </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary greater-than comparison, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a3cc3de58c455cfacd1c119b702995f34" name="a3cc3de58c455cfacd1c119b702995f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc3de58c455cfacd1c119b702995f34">&#9670;&#160;</a></span>make_DelayedBinaryIsometricLessThan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a>&lt; CompareOperation::LESS_THAN &gt; tatami::make_DelayedBinaryIsometricLessThan </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary less-than comparison, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="adcfd223eeb93f13826a8e06b73b474b2" name="adcfd223eeb93f13826a8e06b73b474b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfd223eeb93f13826a8e06b73b474b2">&#9670;&#160;</a></span>make_DelayedBinaryIsometricGreaterThanOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a>&lt; CompareOperation::GREATER_THAN_OR_EQUAL &gt; tatami::make_DelayedBinaryIsometricGreaterThanOrEqual </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary greater-than-or-equal comparison, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a6b8d86c223bd5cb4f9d3b98485215bcc" name="a6b8d86c223bd5cb4f9d3b98485215bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8d86c223bd5cb4f9d3b98485215bcc">&#9670;&#160;</a></span>make_DelayedBinaryIsometricLessThanOrEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a>&lt; CompareOperation::LESS_THAN_OR_EQUAL &gt; tatami::make_DelayedBinaryIsometricLessThanOrEqual </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary less-than-or-equal comparison, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a9b63c28c67d2ec406da35b7db6900879" name="a9b63c28c67d2ec406da35b7db6900879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b63c28c67d2ec406da35b7db6900879">&#9670;&#160;</a></span>make_DelayedBinaryIsometricNotEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompare.html">DelayedBinaryIsometricCompare</a>&lt; CompareOperation::NOT_EQUAL &gt; tatami::make_DelayedBinaryIsometricNotEqual </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed binary non-equality comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ad75250f5b086a69c2d9f0edc7bc0b26b" name="ad75250f5b086a69c2d9f0edc7bc0b26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75250f5b086a69c2d9f0edc7bc0b26b">&#9670;&#160;</a></span>make_DelayedBinaryIsometricOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_  = double, typename InputValue_ , typename Index_ , class Operation_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; OutputValue_, Index_ &gt; &gt; tatami::make_DelayedBinaryIsometricOperation </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation_</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the value of the input matrices. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value. </td></tr>
    <tr><td class="paramname">Operation_</td><td>Helper class defining the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">right</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">op</td><td>Instance of the operation helper class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of a <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code> clas. </dd></dl>

</div>
</div>
<a id="ad01457d379debb3db2613ecb9df8316f" name="ad01457d379debb3db2613ecb9df8316f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01457d379debb3db2613ecb9df8316f">&#9670;&#160;</a></span>make_DelayedUnaryIsometricAddScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double, typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::ADD, true, InputValue_, Scalar_ &gt; tatami::make_DelayedUnaryIsometricAddScalar </td>
          <td>(</td>
          <td class="paramtype">Scalar_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar addition, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="af07d7933d0c241538874bd1111f25b0c" name="af07d7933d0c241538874bd1111f25b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07d7933d0c241538874bd1111f25b0c">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubtractScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename InputValue_  = double, typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::SUBTRACT, right_, InputValue_, Scalar_ &gt; tatami::make_DelayedUnaryIsometricSubtractScalar </td>
          <td>(</td>
          <td class="paramtype">Scalar_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the subtraction. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar subtraction, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ac3a41952679942c301ca014e88f24d4a" name="ac3a41952679942c301ca014e88f24d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a41952679942c301ca014e88f24d4a">&#9670;&#160;</a></span>make_DelayedUnaryIsometricMultiplyScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double, typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::MULTIPLY, true, InputValue_, Scalar_ &gt; tatami::make_DelayedUnaryIsometricMultiplyScalar </td>
          <td>(</td>
          <td class="paramtype">Scalar_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar multiplication, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a79ee0c65c8185ba2da929a7166cf3afe" name="a79ee0c65c8185ba2da929a7166cf3afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ee0c65c8185ba2da929a7166cf3afe">&#9670;&#160;</a></span>make_DelayedUnaryIsometricDivideScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename InputValue_  = double, typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::DIVIDE, right_, InputValue_, Scalar_ &gt; tatami::make_DelayedUnaryIsometricDivideScalar </td>
          <td>(</td>
          <td class="paramtype">Scalar_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the division. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be divided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar division, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ac6add530e6659ffd8347c41a00145754" name="ac6add530e6659ffd8347c41a00145754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6add530e6659ffd8347c41a00145754">&#9670;&#160;</a></span>make_DelayedUnaryIsometricPowerScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename InputValue_  = double, typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::POWER, right_, InputValue_, Scalar_ &gt; tatami::make_DelayedUnaryIsometricPowerScalar </td>
          <td>(</td>
          <td class="paramtype">Scalar_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the power transformation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be power transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar power transformation, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a923fa6598ca3c15de1ad22770d7e57e9" name="a923fa6598ca3c15de1ad22770d7e57e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923fa6598ca3c15de1ad22770d7e57e9">&#9670;&#160;</a></span>make_DelayedUnaryIsometricModuloScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename InputValue_  = double, typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::MODULO, right_, InputValue_, Scalar_ &gt; tatami::make_DelayedUnaryIsometricModuloScalar </td>
          <td>(</td>
          <td class="paramtype">Scalar_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the modulus. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be modulo transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar modulus, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a93ede92a92f04bc3cba00e757a7c76a3" name="a93ede92a92f04bc3cba00e757a7c76a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ede92a92f04bc3cba00e757a7c76a3">&#9670;&#160;</a></span>make_DelayedUnaryIsometricIntegerDivideScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename InputValue_  = double, typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalar.html">DelayedUnaryIsometricArithmeticScalar</a>&lt; ArithmeticOperation::INTEGER_DIVIDE, right_, InputValue_, Scalar_ &gt; tatami::make_DelayedUnaryIsometricIntegerDivideScalar </td>
          <td>(</td>
          <td class="paramtype">Scalar_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the integer division. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be integer divided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed scalar integer division, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a89ba0e047f78f1f6736e99af01175d08" name="a89ba0e047f78f1f6736e99af01175d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ba0e047f78f1f6736e99af01175d08">&#9670;&#160;</a></span>make_DelayedUnaryIsometricAddVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::ADD, true, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricAddVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector to be added to the rows/columns. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html" title="Delayed unary isometric vector arithmetic.">DelayedUnaryIsometricArithmeticVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector addition, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ae04a89253591265e5dfdeb736d7736e4" name="ae04a89253591265e5dfdeb736d7736e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04a89253591265e5dfdeb736d7736e4">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubtractVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::SUBTRACT, right_, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricSubtractVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the subtraction. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector to subtract from (or be subtracted by) the rows/columns. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html" title="Delayed unary isometric vector arithmetic.">DelayedUnaryIsometricArithmeticVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector subtraction, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ad5f10fab490951d8ea9a6cff5e9dfea5" name="ad5f10fab490951d8ea9a6cff5e9dfea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f10fab490951d8ea9a6cff5e9dfea5">&#9670;&#160;</a></span>make_DelayedUnaryIsometricMultiplyVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::MULTIPLY, true, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricMultiplyVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector to multiply the rows/columns. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html" title="Delayed unary isometric vector arithmetic.">DelayedUnaryIsometricArithmeticVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector multiplication, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a4a652f625832bc7f2830eddc7369634a" name="a4a652f625832bc7f2830eddc7369634a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a652f625832bc7f2830eddc7369634a">&#9670;&#160;</a></span>make_DelayedUnaryIsometricDivideVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::DIVIDE, right_, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricDivideVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the division. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector to divide (or be divided by) the rows/columns. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html" title="Delayed unary isometric vector arithmetic.">DelayedUnaryIsometricArithmeticVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector division, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a734eccb6121b6d018c431651d54ad146" name="a734eccb6121b6d018c431651d54ad146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734eccb6121b6d018c431651d54ad146">&#9670;&#160;</a></span>make_DelayedUnaryIsometricPowerVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::POWER, right_, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricPowerVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the power transformation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector to use in the power transformation of the rows/columns. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html" title="Delayed unary isometric vector arithmetic.">DelayedUnaryIsometricArithmeticVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector power transformation, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ac0c9d8feef1eaeebeff4c4e3d1f4af8f" name="ac0c9d8feef1eaeebeff4c4e3d1f4af8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c9d8feef1eaeebeff4c4e3d1f4af8f">&#9670;&#160;</a></span>make_DelayedUnaryIsometricModuloVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::MODULO, right_, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricModuloVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the modulus. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector to use in the modulus of the rows/columns. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html" title="Delayed unary isometric vector arithmetic.">DelayedUnaryIsometricArithmeticVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector modulus, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ac5a6e8445a71606ce80e6741a36e6fd8" name="ac5a6e8445a71606ce80e6741a36e6fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a6e8445a71606ce80e6741a36e6fd8">&#9670;&#160;</a></span>make_DelayedUnaryIsometricIntegerDivideVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html">DelayedUnaryIsometricArithmeticVector</a>&lt; ArithmeticOperation::INTEGER_DIVIDE, right_, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricIntegerDivideVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side of the integer division. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector to integer divide (or be integer divided by) the rows/columns. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVector.html" title="Delayed unary isometric vector arithmetic.">DelayedUnaryIsometricArithmeticVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for delayed vector division, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a903e5ae4540777aeacfb0178ac4f8aac" name="a903e5ae4540777aeacfb0178ac4f8aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903e5ae4540777aeacfb0178ac4f8aac">&#9670;&#160;</a></span>make_DelayedUnaryIsometricBooleanNot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanNot.html">DelayedUnaryIsometricBooleanNot</a> tatami::make_DelayedUnaryIsometricBooleanNot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed NOT operation, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a33cb992320bf02b04abc364bda96236b" name="a33cb992320bf02b04abc364bda96236b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33cb992320bf02b04abc364bda96236b">&#9670;&#160;</a></span>make_DelayedUnaryIsometricBooleanAndScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalar.html">DelayedUnaryIsometricBooleanScalar</a>&lt; BooleanOperation::AND &gt; tatami::make_DelayedUnaryIsometricBooleanAndScalar </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed AND operation with a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a5217ab83500651fbadd29960a12717e4" name="a5217ab83500651fbadd29960a12717e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5217ab83500651fbadd29960a12717e4">&#9670;&#160;</a></span>make_DelayedUnaryIsometricBooleanOrScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalar.html">DelayedUnaryIsometricBooleanScalar</a>&lt; BooleanOperation::OR &gt; tatami::make_DelayedUnaryIsometricBooleanOrScalar </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed OR operation with a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="aad1d71458318c276b9eb517085468291" name="aad1d71458318c276b9eb517085468291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1d71458318c276b9eb517085468291">&#9670;&#160;</a></span>make_DelayedUnaryIsometricBooleanXorScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalar.html">DelayedUnaryIsometricBooleanScalar</a>&lt; BooleanOperation::XOR &gt; tatami::make_DelayedUnaryIsometricBooleanXorScalar </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed XOR operation with a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a9531a951864544d30e69962792ff4eb8" name="a9531a951864544d30e69962792ff4eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9531a951864544d30e69962792ff4eb8">&#9670;&#160;</a></span>make_DelayedUnaryIsometricBooleanEqualScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalar.html">DelayedUnaryIsometricBooleanScalar</a>&lt; BooleanOperation::EQUAL &gt; tatami::make_DelayedUnaryIsometricBooleanEqualScalar </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be used in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed boolean equality operation with a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ab16dd5595a8c717671ffaa1874a82183" name="ab16dd5595a8c717671ffaa1874a82183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16dd5595a8c717671ffaa1874a82183">&#9670;&#160;</a></span>make_DelayedUnaryIsometricBooleanAndVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html">DelayedUnaryIsometricBooleanVector</a>&lt; BooleanOperation::AND, Vector_ &gt; tatami::make_DelayedUnaryIsometricBooleanAndVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector of values to be used in the operation. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html" title="Delayed unary isometric vector boolean operations.">DelayedUnaryIsometricBooleanVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed AND operation with a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a38349aa7f5b0d127039fb4a0e875fc88" name="a38349aa7f5b0d127039fb4a0e875fc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38349aa7f5b0d127039fb4a0e875fc88">&#9670;&#160;</a></span>make_DelayedUnaryIsometricBooleanOrVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html">DelayedUnaryIsometricBooleanVector</a>&lt; BooleanOperation::OR, Vector_ &gt; tatami::make_DelayedUnaryIsometricBooleanOrVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector of values to be used in the operation. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html" title="Delayed unary isometric vector boolean operations.">DelayedUnaryIsometricBooleanVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed OR operation with a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a792a5d736087c619ede48c38edecd4e3" name="a792a5d736087c619ede48c38edecd4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792a5d736087c619ede48c38edecd4e3">&#9670;&#160;</a></span>make_DelayedUnaryIsometricBooleanXorVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html">DelayedUnaryIsometricBooleanVector</a>&lt; BooleanOperation::XOR, Vector_ &gt; tatami::make_DelayedUnaryIsometricBooleanXorVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector of values to be used in the operation. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html" title="Delayed unary isometric vector boolean operations.">DelayedUnaryIsometricBooleanVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed XOR operation with a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a70c548b744fc5df8cbf4b4dfde2c8f3c" name="a70c548b744fc5df8cbf4b4dfde2c8f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c548b744fc5df8cbf4b4dfde2c8f3c">&#9670;&#160;</a></span>make_DelayedUnaryIsometricBooleanEqualVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html">DelayedUnaryIsometricBooleanVector</a>&lt; BooleanOperation::EQUAL, Vector_ &gt; tatami::make_DelayedUnaryIsometricBooleanEqualVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector of values to be used in the operation. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVector.html" title="Delayed unary isometric vector boolean operations.">DelayedUnaryIsometricBooleanVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed boolean equality operation with a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="aa74741489b477f1a69d53a3c18c78a7b" name="aa74741489b477f1a69d53a3c18c78a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74741489b477f1a69d53a3c18c78a7b">&#9670;&#160;</a></span>make_DelayedUnaryIsometricEqualScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a>&lt; CompareOperation::EQUAL, InputValue_ &gt; tatami::make_DelayedUnaryIsometricEqualScalar </td>
          <td>(</td>
          <td class="paramtype">InputValue_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed equality comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a983e14506dc8cf04295e92004c6b5c45" name="a983e14506dc8cf04295e92004c6b5c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983e14506dc8cf04295e92004c6b5c45">&#9670;&#160;</a></span>make_DelayedUnaryIsometricGreaterThanScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a>&lt; CompareOperation::GREATER_THAN, InputValue_ &gt; tatami::make_DelayedUnaryIsometricGreaterThanScalar </td>
          <td>(</td>
          <td class="paramtype">InputValue_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a12ab6ad85c62223b39cdc3de21bef2e5" name="a12ab6ad85c62223b39cdc3de21bef2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ab6ad85c62223b39cdc3de21bef2e5">&#9670;&#160;</a></span>make_DelayedUnaryIsometricLessThanScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a>&lt; CompareOperation::LESS_THAN, InputValue_ &gt; tatami::make_DelayedUnaryIsometricLessThanScalar </td>
          <td>(</td>
          <td class="paramtype">InputValue_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a7e7d7094d9684b053a203c5d00cdbf25" name="a7e7d7094d9684b053a203c5d00cdbf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7d7094d9684b053a203c5d00cdbf25">&#9670;&#160;</a></span>make_DelayedUnaryIsometricGreaterThanOrEqualScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a>&lt; CompareOperation::GREATER_THAN_OR_EQUAL, InputValue_ &gt; tatami::make_DelayedUnaryIsometricGreaterThanOrEqualScalar </td>
          <td>(</td>
          <td class="paramtype">InputValue_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than-or-equal comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ae674f4bc700c58d7a70f4e883e424198" name="ae674f4bc700c58d7a70f4e883e424198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae674f4bc700c58d7a70f4e883e424198">&#9670;&#160;</a></span>make_DelayedUnaryIsometricLessThanOrEqualScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a>&lt; CompareOperation::LESS_THAN_OR_EQUAL, InputValue_ &gt; tatami::make_DelayedUnaryIsometricLessThanOrEqualScalar </td>
          <td>(</td>
          <td class="paramtype">InputValue_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than-or-equal comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a4fc5bc6de16e4bdd33a7e776f0df0dcc" name="a4fc5bc6de16e4bdd33a7e776f0df0dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc5bc6de16e4bdd33a7e776f0df0dcc">&#9670;&#160;</a></span>make_DelayedUnaryIsometricNotEqualScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalar.html">DelayedUnaryIsometricCompareScalar</a>&lt; CompareOperation::NOT_EQUAL, InputValue_ &gt; tatami::make_DelayedUnaryIsometricNotEqualScalar </td>
          <td>(</td>
          <td class="paramtype">InputValue_</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>Scalar value to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed non-equality comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a74cc635c8a64c607d3059ee2928f27bc" name="a74cc635c8a64c607d3059ee2928f27bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cc635c8a64c607d3059ee2928f27bc">&#9670;&#160;</a></span>make_DelayedUnaryIsometricEqualVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a>&lt; CompareOperation::EQUAL, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricEqualVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector of values to be compared. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html" title="Delayed vector comparisons.">DelayedUnaryIsometricCompareVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed equality comparison to a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="afa23e61b494d984a071aaff63b52b378" name="afa23e61b494d984a071aaff63b52b378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa23e61b494d984a071aaff63b52b378">&#9670;&#160;</a></span>make_DelayedUnaryIsometricGreaterThanVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a>&lt; CompareOperation::GREATER_THAN, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricGreaterThanVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector of values to be compared. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html" title="Delayed vector comparisons.">DelayedUnaryIsometricCompareVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than comparison to a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a2c3b9e1efdea505210a867916331e9f3" name="a2c3b9e1efdea505210a867916331e9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3b9e1efdea505210a867916331e9f3">&#9670;&#160;</a></span>make_DelayedUnaryIsometricLessThanVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a>&lt; CompareOperation::LESS_THAN, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricLessThanVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector of values to be compared. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html" title="Delayed vector comparisons.">DelayedUnaryIsometricCompareVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than comparison to a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ae6ec71c086f23e2e15166fb55154686b" name="ae6ec71c086f23e2e15166fb55154686b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ec71c086f23e2e15166fb55154686b">&#9670;&#160;</a></span>make_DelayedUnaryIsometricGreaterThanOrEqualVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a>&lt; CompareOperation::GREATER_THAN_OR_EQUAL, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricGreaterThanOrEqualVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector of values to be compared. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html" title="Delayed vector comparisons.">DelayedUnaryIsometricCompareVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than-or-equal comparison to a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ad592a6164ae40e0ff6555ce0eeaac63a" name="ad592a6164ae40e0ff6555ce0eeaac63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad592a6164ae40e0ff6555ce0eeaac63a">&#9670;&#160;</a></span>make_DelayedUnaryIsometricLessThanOrEqualVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a>&lt; CompareOperation::LESS_THAN_OR_EQUAL, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricLessThanOrEqualVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector of values to be compared. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html" title="Delayed vector comparisons.">DelayedUnaryIsometricCompareVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than-or-equal comparison to a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a2b643d84e2e356a6dfe472c2f374537a" name="a2b643d84e2e356a6dfe472c2f374537a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b643d84e2e356a6dfe472c2f374537a">&#9670;&#160;</a></span>make_DelayedUnaryIsometricNotEqualVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_  = double, typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html">DelayedUnaryIsometricCompareVector</a>&lt; CompareOperation::NOT_EQUAL, InputValue_, Vector_ &gt; tatami::make_DelayedUnaryIsometricNotEqualVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector of values to be compared. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>vector</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVector.html" title="Delayed vector comparisons.">DelayedUnaryIsometricCompareVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed non-equality comparison to a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a6637de329390c622128024fc2f6d35b7" name="a6637de329390c622128024fc2f6d35b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6637de329390c622128024fc2f6d35b7">&#9670;&#160;</a></span>make_DelayedUnaryIsometricIsnan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool pass_ = true, typename InputValue_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompare.html">DelayedUnaryIsometricSpecialCompare</a>&lt; SpecialCompareOperation::ISNAN, pass_, InputValue_ &gt; tatami::make_DelayedUnaryIsometricIsnan </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pass_</td><td>Whether to return truthy if the matrix value is NaN. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed NaN check, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a2e7b274bc022093c27942ca569ec3630" name="a2e7b274bc022093c27942ca569ec3630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7b274bc022093c27942ca569ec3630">&#9670;&#160;</a></span>make_DelayedUnaryIsometricIsinf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool pass_ = true, typename InputValue_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompare.html">DelayedUnaryIsometricSpecialCompare</a>&lt; SpecialCompareOperation::ISINF, pass_, InputValue_ &gt; tatami::make_DelayedUnaryIsometricIsinf </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pass_</td><td>Whether to return truthy if the matrix value is infinite. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed check for infinity (positive or negative), to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a349d487e245d6082d5131d2f84b74071" name="a349d487e245d6082d5131d2f84b74071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349d487e245d6082d5131d2f84b74071">&#9670;&#160;</a></span>make_DelayedUnaryIsometricIsfinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool pass_ = true, typename InputValue_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompare.html">DelayedUnaryIsometricSpecialCompare</a>&lt; SpecialCompareOperation::ISFINITE, pass_, InputValue_ &gt; tatami::make_DelayedUnaryIsometricIsfinite </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pass_</td><td>Whether to return truthy if the matrix value is finite. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value to use in the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed check for finite values, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a6f23962ec258c833d2c28a8d19e12807" name="a6f23962ec258c833d2c28a8d19e12807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f23962ec258c833d2c28a8d19e12807">&#9670;&#160;</a></span>make_DelayedUnaryIsometricOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_  = double, typename InputValue_ , typename Index_ , class Operation_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; OutputValue_, Index_ &gt; &gt; tatami::make_DelayedUnaryIsometricOperation </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation_</td>          <td class="paramname"><span class="paramname"><em>operation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of matrix value after the operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of matrix value before the operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index value. </td></tr>
    <tr><td class="paramname">Operation_</td><td>Helper class implementing the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">operation</td><td>Instance of the operation helper class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code> class. </dd></dl>

</div>
</div>
<a id="a2f4611e96f639b004ffaa1c17c435070" name="a2f4611e96f639b004ffaa1c17c435070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4611e96f639b004ffaa1c17c435070">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteEqualScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a>&lt; CompareOperation::EQUAL, Value_ &gt; tatami::make_DelayedUnaryIsometricSubstituteEqualScalar </td>
          <td>(</td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>compared</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compared</td><td>Scalar to be compared to the matrix values. </td></tr>
    <tr><td class="paramname">substitute</td><td>Scalar to substitute into the matrix when the comparison is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed equality comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a3ef464e027eeb29e2f82963520c26b0b" name="a3ef464e027eeb29e2f82963520c26b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef464e027eeb29e2f82963520c26b0b">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteGreaterThanScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a>&lt; CompareOperation::GREATER_THAN, Value_ &gt; tatami::make_DelayedUnaryIsometricSubstituteGreaterThanScalar </td>
          <td>(</td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>compared</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compared</td><td>Scalar to be compared to the matrix values. </td></tr>
    <tr><td class="paramname">substitute</td><td>Scalar value to substitute into the matrix when the comparison is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a00d5b011082a2a524f8e9611d07f87a7" name="a00d5b011082a2a524f8e9611d07f87a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d5b011082a2a524f8e9611d07f87a7">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteLessThanScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a>&lt; CompareOperation::LESS_THAN, Value_ &gt; tatami::make_DelayedUnaryIsometricSubstituteLessThanScalar </td>
          <td>(</td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>compared</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compared</td><td>Scalar to be compared to the matrix values. </td></tr>
    <tr><td class="paramname">substitute</td><td>Scalar value to substitute into the matrix when the comparison is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ac10a97c1ec31e3a60d68da0a3f544603" name="ac10a97c1ec31e3a60d68da0a3f544603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10a97c1ec31e3a60d68da0a3f544603">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteGreaterThanOrEqualScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a>&lt; CompareOperation::GREATER_THAN_OR_EQUAL, Value_ &gt; tatami::make_DelayedUnaryIsometricSubstituteGreaterThanOrEqualScalar </td>
          <td>(</td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>compared</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compared</td><td>Scalar to be compared to the matrix values. </td></tr>
    <tr><td class="paramname">substitute</td><td>Scalar value to substitute into the matrix when the comparison is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than-or-equal comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ab9bb7e872341073b579ab59f99870f23" name="ab9bb7e872341073b579ab59f99870f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bb7e872341073b579ab59f99870f23">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteLessThanOrEqualScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a>&lt; CompareOperation::LESS_THAN_OR_EQUAL, Value_ &gt; tatami::make_DelayedUnaryIsometricSubstituteLessThanOrEqualScalar </td>
          <td>(</td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>compared</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compared</td><td>Scalar to be compared to the matrix values. </td></tr>
    <tr><td class="paramname">substitute</td><td>Scalar to substitute into the matrix when the comparison is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than-or-equal comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a4b9f40dd430934d2693a21d09954b103" name="a4b9f40dd430934d2693a21d09954b103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9f40dd430934d2693a21d09954b103">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteNotEqualScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalar.html">DelayedUnaryIsometricSubstituteScalar</a>&lt; CompareOperation::NOT_EQUAL, Value_ &gt; tatami::make_DelayedUnaryIsometricSubstituteNotEqualScalar </td>
          <td>(</td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>compared</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compared</td><td>Scalar to be compared to the matrix values. </td></tr>
    <tr><td class="paramname">substitute</td><td>Scalar value to substitute into the matrix when the comparison is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed non-equality comparison to a scalar, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a90cd5051271fda51be03670848e17bf4" name="a90cd5051271fda51be03670848e17bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cd5051271fda51be03670848e17bf4">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteEqualVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double, typename Vector_  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a>&lt; CompareOperation::EQUAL, Value_, Vector_ &gt; tatami::make_DelayedUnaryIsometricSubstituteEqualVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>compared</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compared</td><td>Vector to be compared to the matrix values. </td></tr>
    <tr><td class="paramname">substitute</td><td>Vector containing values to substitute into the matrix when the comparison is true. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>compared</code> and <code>substitute</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html" title="Delayed vector comparisons.">DelayedUnaryIsometricSubstituteVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed equality comparison to a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a60163836a688ca8b662affec5f3ac92b" name="a60163836a688ca8b662affec5f3ac92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60163836a688ca8b662affec5f3ac92b">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteGreaterThanVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double, typename Vector_  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a>&lt; CompareOperation::GREATER_THAN, Value_, Vector_ &gt; tatami::make_DelayedUnaryIsometricSubstituteGreaterThanVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>compared</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compared</td><td>Vector to be compared to the matrix values. </td></tr>
    <tr><td class="paramname">substitute</td><td>Vector containing values to substitute into the matrix when the comparison is true. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>compared</code> and <code>substitute</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html" title="Delayed vector comparisons.">DelayedUnaryIsometricSubstituteVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than comparison to a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a0a478db711543357f581bbe2d241421f" name="a0a478db711543357f581bbe2d241421f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a478db711543357f581bbe2d241421f">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteLessThanVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double, typename Vector_  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a>&lt; CompareOperation::LESS_THAN, Value_, Vector_ &gt; tatami::make_DelayedUnaryIsometricSubstituteLessThanVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>compared</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compared</td><td>Vector to be compared to the matrix values. </td></tr>
    <tr><td class="paramname">substitute</td><td>Vector containing values to substitute into the matrix when the comparison is true. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>compared</code> and <code>substitute</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html" title="Delayed vector comparisons.">DelayedUnaryIsometricSubstituteVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than comparison to a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="adf046b4ba48222d084a4a1cd84b560c7" name="adf046b4ba48222d084a4a1cd84b560c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf046b4ba48222d084a4a1cd84b560c7">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteGreaterThanOrEqualVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double, typename Vector_  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a>&lt; CompareOperation::GREATER_THAN_OR_EQUAL, Value_, Vector_ &gt; tatami::make_DelayedUnaryIsometricSubstituteGreaterThanOrEqualVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>compared</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compared</td><td>Vector to be compared to the matrix values. </td></tr>
    <tr><td class="paramname">substitute</td><td>Vector containing values to substitute into the matrix when the comparison is true. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>compared</code> and <code>substitute</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html" title="Delayed vector comparisons.">DelayedUnaryIsometricSubstituteVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed greater-than-or-equal comparison to a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a11f450e1cbcd4fbd7427dc5d15392cc4" name="a11f450e1cbcd4fbd7427dc5d15392cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f450e1cbcd4fbd7427dc5d15392cc4">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteLessThanOrEqualVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double, typename Vector_  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a>&lt; CompareOperation::LESS_THAN_OR_EQUAL, Value_, Vector_ &gt; tatami::make_DelayedUnaryIsometricSubstituteLessThanOrEqualVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>compared</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compared</td><td>Vector to be compared to the matrix values. </td></tr>
    <tr><td class="paramname">substitute</td><td>Vector containing values to substitute into the matrix when the comparison is true. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>compared</code> and <code>substitute</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html" title="Delayed vector comparisons.">DelayedUnaryIsometricSubstituteVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed less-than-or-equal comparison to a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ad65490ea8c0ee4d29af2d51d10ba23ca" name="ad65490ea8c0ee4d29af2d51d10ba23ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65490ea8c0ee4d29af2d51d10ba23ca">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteNotEqualVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double, typename Vector_  = std::vector&lt;Value_&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html">DelayedUnaryIsometricSubstituteVector</a>&lt; CompareOperation::NOT_EQUAL, Value_, Vector_ &gt; tatami::make_DelayedUnaryIsometricSubstituteNotEqualVector </td>
          <td>(</td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>compared</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compared</td><td>Vector to be compared to the matrix values. </td></tr>
    <tr><td class="paramname">substitute</td><td>Vector containing values to substitute into the matrix when the comparison is true. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether each element of <code>compared</code> and <code>substitute</code> corresponds to a row, see <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVector.html" title="Delayed vector comparisons.">DelayedUnaryIsometricSubstituteVector</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed non-equality comparison to a vector, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a42ceae1b11636c213088c6d923fad313" name="a42ceae1b11636c213088c6d923fad313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ceae1b11636c213088c6d923fad313">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteIsnan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool pass_ = true, typename Value_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstitute.html">DelayedUnaryIsometricSpecialSubstitute</a>&lt; SpecialCompareOperation::ISNAN, pass_, Value_ &gt; tatami::make_DelayedUnaryIsometricSubstituteIsnan </td>
          <td>(</td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pass_</td><td>Whether to perform the substitution if the matrix value is NaN. If false, the substitution is performed if the matrix value is not NaN. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed NaN check, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a9d5ab6b324705fb16662933815c589c9" name="a9d5ab6b324705fb16662933815c589c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5ab6b324705fb16662933815c589c9">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteIsinf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool pass_ = true, typename Value_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstitute.html">DelayedUnaryIsometricSpecialSubstitute</a>&lt; SpecialCompareOperation::ISINF, pass_, Value_ &gt; tatami::make_DelayedUnaryIsometricSubstituteIsinf </td>
          <td>(</td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pass_</td><td>Whether to return truthy if the matrix value is infinite. If false, the substitution is performed if the matrix value is not infinite. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed check for infinity (positive or negative), to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="a87a1194718021bcd4b97a6c420ffbdfa" name="a87a1194718021bcd4b97a6c420ffbdfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a1194718021bcd4b97a6c420ffbdfa">&#9670;&#160;</a></span>make_DelayedUnaryIsometricSubstituteIsfinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool pass_ = true, typename Value_  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstitute.html">DelayedUnaryIsometricSpecialSubstitute</a>&lt; SpecialCompareOperation::ISFINITE, pass_, Value_ &gt; tatami::make_DelayedUnaryIsometricSubstituteIsfinite </td>
          <td>(</td>
          <td class="paramtype">Value_</td>          <td class="paramname"><span class="paramname"><em>substitute</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pass_</td><td>Whether to return truthy if the matrix value is finite. If false, the substitution is performed if the matrix value is not finite. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper class for a delayed check for finite values, to be used as the <code>operation</code> in a <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>. </dd></dl>

</div>
</div>
<a id="ab4c8b88eeaa5fcbb1e5d47d020eb98ea" name="ab4c8b88eeaa5fcbb1e5d47d020eb98ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c8b88eeaa5fcbb1e5d47d020eb98ea">&#9670;&#160;</a></span>make_DelayedCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueOut_ , typename IndexOut_ , typename ValueIn_ , typename IndexIn_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; ValueOut_, IndexOut_ &gt; &gt; tatami::make_DelayedCast </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; ValueIn_, IndexIn_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recast a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> to a different interface type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueOut_</td><td>Data type to cast to. </td></tr>
    <tr><td class="paramname">IndexOut_</td><td>Index type to cast to. </td></tr>
    <tr><td class="paramname">ValueIn_</td><td>Data type to cast from. </td></tr>
    <tr><td class="paramname">IndexIn_</td><td>Index type to cast from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the (possbly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> instance to cast from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> instance of the desired interface type. </dd></dl>

</div>
</div>
<a id="a3b2756af73514cbf89b42f5abd7997cc" name="a3b2756af73514cbf89b42f5abd7997cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2756af73514cbf89b42f5abd7997cc">&#9670;&#160;</a></span>compress_sparse_triplets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Values_ , class RowIndices_ , class ColumnIndices_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; tatami::compress_sparse_triplets </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>ncol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Values_ &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RowIndices_ &amp;</td>          <td class="paramname"><span class="paramname"><em>row_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColumnIndices_ &amp;</td>          <td class="paramname"><span class="paramname"><em>column_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>csr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Values_</td><td>Random-access container for the values. </td></tr>
    <tr><td class="paramname">RowIndices_</td><td>Random access container for the row indices. </td></tr>
    <tr><td class="paramname">ColumnIndices_</td><td>Random access container for the column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nrow</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">ncol</td><td>Number of columns. </td></tr>
    <tr><td class="paramname">row_indices</td><td>Row indices of the structural non-zeros. Values must be non-negative integers less than <code>nrow</code>. </td></tr>
    <tr><td class="paramname">column_indices</td><td>Column indices of the structural non-zeros. This must be of the same length as <code>row_indices</code>, where corresponding entries contain data for a single structural non-zero. Values must be non-negative integers less than <code>ncol</code>. </td></tr>
    <tr><td class="paramname">values</td><td>Values of the structural non-zeros. This must be of the same length as <code>row_indices</code> and <code>column_indices</code>, where corresponding entries contain data for a single structural non-zero. </td></tr>
    <tr><td class="paramname">csr</td><td>Whether to create a compressed sparse row format. If <code>false</code>, the compressed sparse column format is used instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>row_indices</code>, <code>column_indices</code> and <code>values</code> are sorted in-place by the row and column indices (if <code>csr = true</code>) or by the column and row indices (if <code>csr = false</code>). A vector of index pointers is returned with length <code>nrow + 1</code> (if <code>csr = true</code>) or <code>ncol + 1</code> (if <code>csr = false</code>). </dd></dl>

</div>
</div>
<a id="ac004bfb30ee5623bec14d3783c2cc21e" name="ac004bfb30ee5623bec14d3783c2cc21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac004bfb30ee5623bec14d3783c2cc21e">&#9670;&#160;</a></span>count_compressed_sparse_non_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Count_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::count_compressed_sparse_non_zeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Count_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1CountCompressedSparseNonZerosOptions.html">CountCompressedSparseNonZerosOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of value in the matrix. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of row/column index. </td></tr>
    <tr><td class="paramname">Count_</td><td>Integer type for the non-zero count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to count structural non-zeros by row. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length equal to the number of rows (if <code>row = true</code>) or columns (otherwise) of <code>matrix</code>. On output, this stores the number of structural non-zeros in each row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<p>For sparse <code>matrix</code>, all structural non-zero elements are reported, even if they have actual values of zero. In contrast, for dense <code>matrix</code>, only the non-zero values are counted; these are considered to be structural non-zeros upon conversion to a sparse matrix (e.g., in <code><a class="el" href="#aaadd3c0f36b8cbde2d360a8babba163f">fill_compressed_sparse_contents()</a></code>). </p>

</div>
</div>
<a id="aaadd3c0f36b8cbde2d360a8babba163f" name="aaadd3c0f36b8cbde2d360a8babba163f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadd3c0f36b8cbde2d360a8babba163f">&#9670;&#160;</a></span>fill_compressed_sparse_contents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_ , typename InputIndex_ , typename Pointer_ , typename StoredValue_ , typename StoredIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::fill_compressed_sparse_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pointer_ *</td>          <td class="paramname"><span class="paramname"><em>pointers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoredValue_ *</td>          <td class="paramname"><span class="paramname"><em>output_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoredIndex_ *</td>          <td class="paramname"><span class="paramname"><em>output_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1FillCompressedSparseContentsOptions.html">FillCompressedSparseContentsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">Pointer_</td><td>Integer type for the row/column pointers. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to fill <code>output_value</code> and <code>output_index</code> by row, i.e., the output represents a compressed sparse row matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointers</td><td>Pointer to an array of length greater than or equal to the number of rows (if <code>row = true</code>) or columns (otherwise) of <code>matrix</code>. Each entry contains the position of the start of each row/column in <code>output_value</code> and <code>output_index</code>. This argument is equivalent to the array of pointers for the compressed sparse format (e.g., <code><a class="el" href="structtatami_1_1CompressedSparseContents.html#ad9410e8d3b32bc97086bebf2322c0ef8">CompressedSparseContents::pointers</a></code>), and can be obtained by taking the cumulative sum of the per-row/column counts from <code><a class="el" href="#ac004bfb30ee5623bec14d3783c2cc21e">count_compressed_sparse_non_zeros()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_value</td><td>Pointer to an array of length equal to the total number of structural non-zero elements. On output, this is used to store the values of those elements in a compressed sparse format (e.g., <code><a class="el" href="structtatami_1_1CompressedSparseContents.html#ad406234c4c87a0b3cbdd52948d2ae1b1">CompressedSparseContents::value</a></code>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_index</td><td>Pointer to an array of length equal to the total number of structural non-zero elements. On output, this is used to store the row/column indices of those elements in a compressed sparse format (e.g., <code><a class="el" href="structtatami_1_1CompressedSparseContents.html#a5b30cd6415c0e3cfd91b31590f16bc58">CompressedSparseContents::index</a></code>). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05dc21541e6db5a8896049a0647c4230" name="a05dc21541e6db5a8896049a0647c4230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dc21541e6db5a8896049a0647c4230">&#9670;&#160;</a></span>retrieve_compressed_sparse_contents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StoredValue_ , typename StoredIndex_ , typename StoredPointer_  = size_t, typename InputValue_ , typename InputIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1CompressedSparseContents.html">CompressedSparseContents</a>&lt; StoredValue_, StoredIndex_, StoredPointer_ &gt; tatami::retrieve_compressed_sparse_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1RetrieveCompressedSparseContentsOptions.html">RetrieveCompressedSparseContentsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the row/column indices in the output. </td></tr>
    <tr><td class="paramname">Pointer_</td><td>Integer type for the row/column pointers in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">row</td><td>Whether to retrieve the contents of <code>matrix</code> by row, i.e., the output is a compressed sparse row matrix. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contents of the sparse matrix in compressed form, see <code><a class="el" href="structtatami_1_1CompressedSparseContents.html" title="Compressed sparse contents.">CompressedSparseContents</a></code>.</dd></dl>
<p>The behavior of this function can be replicated by manually calling <code><a class="el" href="#ac004bfb30ee5623bec14d3783c2cc21e">count_compressed_sparse_non_zeros()</a></code> followed by <code><a class="el" href="#aaadd3c0f36b8cbde2d360a8babba163f">fill_compressed_sparse_contents()</a></code>. This may be desirable for users who want to put the compressed sparse contents into pre-existing memory allocations. </p>

</div>
</div>
<a id="a2eaf90f62fd2ccfcd1c35ef291f7f489" name="a2eaf90f62fd2ccfcd1c35ef291f7f489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eaf90f62fd2ccfcd1c35ef291f7f489">&#9670;&#160;</a></span>convert_to_compressed_sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_  = double, typename Index_  = int, typename StoredValue_  = Value_, typename StoredIndex_  = Index_, typename InputValue_ , typename InputIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::convert_to_compressed_sparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1ConvertToCompressedSparseOptions.html">ConvertToCompressedSparseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">row</td><td>Whether to return a compressed sparse row matrix. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>matrix</code>. If <code>row = true</code>, the matrix is in compressed sparse row format, otherwise it is compressed sparse column. </dd></dl>

</div>
</div>
<a id="a5c71daf9bdb1ea8d3e16f35c5b15facc" name="a5c71daf9bdb1ea8d3e16f35c5b15facc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c71daf9bdb1ea8d3e16f35c5b15facc">&#9670;&#160;</a></span>retrieve_fragmented_sparse_contents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StoredValue_ , typename StoredIndex_ , typename InputValue_ , typename InputIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1FragmentedSparseContents.html">FragmentedSparseContents</a>&lt; StoredValue_, StoredIndex_ &gt; tatami::retrieve_fragmented_sparse_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1RetrieveFragmentedSparseContentsOptions.html">RetrieveFragmentedSparseContentsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">row</td><td>Whether to retrieve the contents of <code>matrix</code> by row, i.e., the output is a fragmented sparse row matrix. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contents of the sparse matrix in fragmented form, see <code><a class="el" href="structtatami_1_1FragmentedSparseContents.html" title="Fragmented sparse contents.">FragmentedSparseContents</a></code>. </dd></dl>

</div>
</div>
<a id="add29754647077a82209dfe6ba78cd2b5" name="add29754647077a82209dfe6ba78cd2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add29754647077a82209dfe6ba78cd2b5">&#9670;&#160;</a></span>convert_to_fragmented_sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename StoredValue_  = Value_, typename StoredIndex_  = Index_, typename InputValue_ , typename InputIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::convert_to_fragmented_sparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1ConvertToFragmentedSparseOptions.html">ConvertToFragmentedSparseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">row</td><td>Whether to return a fragmented sparse row matrix. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1FragmentedSparseMatrix.html" title="Fragmented sparse matrix representation.">tatami::FragmentedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>matrix</code>. If <code>row = true</code>, the matrix is in fragmented sparse row format, otherwise it is fragmented sparse column. </dd></dl>

</div>
</div>
<a id="ad50326a317ed80de39a1a872e098b2b2" name="ad50326a317ed80de39a1a872e098b2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50326a317ed80de39a1a872e098b2b2">&#9670;&#160;</a></span>make_DelayedSubsetBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedSubsetBlock </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>subset_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>subset_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Pointer to the underlying (pre-subset) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">subset_start</td><td>Index of the start of the block. This should be a row index if <code>by_row = true</code> and a column index otherwise. </td></tr>
    <tr><td class="paramname">subset_length</td><td>Index of the one-past-the-end of the block. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether to apply the subset to the rows. If false, the subset is applied to the columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedSubsetBlock.html" title="Delayed subsetting to a contiguous block.">DelayedSubsetBlock</a></code> instance. </dd></dl>

</div>
</div>
<a id="a77fad1d2a2553899a7860521d6284f50" name="a77fad1d2a2553899a7860521d6284f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fad1d2a2553899a7860521d6284f50">&#9670;&#160;</a></span>make_DelayedSubset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class SubsetStorage_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedSubset </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubsetStorage_</td>          <td class="paramname"><span class="paramname"><em>subset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. This will automatically dispatch to <code><a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html" title="Delayed subsetting of a matrix with sorted, unique indices.">DelayedSubsetSortedUnique</a></code>, <code><a class="el" href="classtatami_1_1DelayedSubsetUnique.html" title="Delayed subsetting of a matrix with unique indices.">DelayedSubsetUnique</a></code>, <code><a class="el" href="classtatami_1_1DelayedSubsetSorted.html" title="Delayed subsetting of a matrix with sorted indices.">DelayedSubsetSorted</a></code> or <code><a class="el" href="classtatami_1_1DelayedSubset.html" title="Delayed subsetting of a matrix with general indices.">DelayedSubset</a></code>, depending on the values in <code>subset</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the row/column indices. </td></tr>
    <tr><td class="paramname">SubsetStorage_</td><td>Vector containing the subset indices, to be automatically deduced. Any class implementing <code>[</code>, <code>size()</code>, <code>begin()</code> and <code>end()</code> can be used here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">subset</td><td>Instance of the subset index vector. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether to apply the subset to the rows. If false, the subset is applied to the columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedSubset.html" title="Delayed subsetting of a matrix with general indices.">DelayedSubset</a></code> instance. </dd></dl>

</div>
</div>
<a id="aedb635e5ca22b18c04980c08643f2875" name="aedb635e5ca22b18c04980c08643f2875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb635e5ca22b18c04980c08643f2875">&#9670;&#160;</a></span>consecutive_extractor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tatami::consecutive_extractor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>iter_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>iter_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args_ &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates an extractor object with a <code><a class="el" href="classtatami_1_1ConsecutiveOracle.html" title="Predict future accesses along a consecutive sequence.">ConsecutiveOracle</a></code> instance spanning a range of rows or columns. <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> implementations that are oracle-aware can then perform pre-fetching of future accesses for greater performance.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">sparse_</td><td>Whether to perform sparse retrieval. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column index. </td></tr>
    <tr><td class="paramname">Args_</td><td>Types of further arguments to pass to <code><a class="el" href="classtatami_1_1Matrix.html#a168f0e932b5503c9bfc5dbd42754a7a5">Matrix::dense_row</a></code> or <code><a class="el" href="classtatami_1_1Matrix.html#a48300b3739f26bb10732c572ea9e5c57">Matrix::dense_column</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code> to iterate over. </td></tr>
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">iter_start</td><td>Index of the first row (if <code>row = true</code>) or column (otherwise) of the iteration range. </td></tr>
    <tr><td class="paramname">iter_length</td><td>Number of rows (if <code>row = true</code>) or columns (otherwise) in the iteration range. </td></tr>
    <tr><td class="paramname">args</td><td>Further arguments to pass to <code><a class="el" href="#ac1514cda61f96e93a9cbc656f742a044">new_extractor()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An extractor for iteration over consecutive rows/columns in <code>[iter_start, iter_start + iter_length)</code>. This may be either an <code><a class="el" href="classtatami_1_1OracularDenseExtractor.html" title="Extract an element of the target dimension in dense form with an oracle.">OracularDenseExtractor</a></code> or <code><a class="el" href="classtatami_1_1OracularSparseExtractor.html" title="Extract an element of the target dimension in sparse form with an oracle.">OracularSparseExtractor</a></code> depending on <code>sparse_</code>. </dd></dl>

</div>
</div>
<a id="ab52a806e3f13a68741a9e1f77dccab14" name="ab52a806e3f13a68741a9e1f77dccab14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52a806e3f13a68741a9e1f77dccab14">&#9670;&#160;</a></span>copy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Size_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value_ * tatami::copy_n </td>
          <td>(</td>
          <td class="paramtype">const Value_ *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size_</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of value being copied. </td></tr>
    <tr><td class="paramname">Size_</td><td>Type for the array length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to a source array of size <code>n</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Length of the array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to a destination array of size <code>n</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values are copied from <code>input</code> to <code>output</code>, and <code>output</code> is returned. This is a no-op if <code>input == output</code>. </dd></dl>

</div>
</div>
<a id="ac1514cda61f96e93a9cbc656f742a044" name="ac1514cda61f96e93a9cbc656f742a044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1514cda61f96e93a9cbc656f742a044">&#9670;&#160;</a></span>new_extractor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool sparse_, bool oracle_, typename Value_ , typename Index_ , typename ... Args_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tatami::new_extractor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a812af1bfb04773bf28da8549c3e6e5ee">MaybeOracle</a>&lt; oracle_, Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args_ &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This utility makes it easier for developers to write a single templated function that works with and without oracles. A boolean placeholder should be provided as the "oracle" in the myopic extractor case.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">sparse_</td><td>Whether to perform sparse retrieval. </td></tr>
    <tr><td class="paramname">oracle_</td><td>Whether an oracle should be supplied. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer. </td></tr>
    <tr><td class="paramname">Args_</td><td>Further arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code> object to iterate over. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">oracle</td><td>Pointer to an oracle if <code>oracle_ = true</code>, otherwise a placeholder boolean that is ignored. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">args</td><td>Zero or more additional arguments to pass to methods like <code><a class="el" href="classtatami_1_1Matrix.html#a168f0e932b5503c9bfc5dbd42754a7a5">Matrix::dense_row()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An extractor to access elements of the requested dimension of <code>ptr</code>. This may be any of <code><a class="el" href="classtatami_1_1MyopicDenseExtractor.html" title="Extract an element of the target dimension in dense form without an oracle.">MyopicDenseExtractor</a></code>, <code><a class="el" href="classtatami_1_1MyopicSparseExtractor.html" title="Extract an element of the target dimension in sparse form without an oracle.">MyopicSparseExtractor</a></code>, <code><a class="el" href="classtatami_1_1OracularDenseExtractor.html" title="Extract an element of the target dimension in dense form with an oracle.">OracularDenseExtractor</a></code> or <code><a class="el" href="classtatami_1_1OracularSparseExtractor.html" title="Extract an element of the target dimension in sparse form with an oracle.">OracularSparseExtractor</a></code>, depending on <code>sparse_</code> and <code>oracle_</code>. </dd></dl>

</div>
</div>
<a id="a5a08e0387bc00e8045a0364d6e35d120" name="a5a08e0387bc00e8045a0364d6e35d120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a08e0387bc00e8045a0364d6e35d120">&#9670;&#160;</a></span>parallelize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = true, class Function_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::parallelize </td>
          <td>(</td>
          <td class="paramtype">Function_</td>          <td class="paramname"><span class="paramname"><em>fun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>tasks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>threads</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a function to a set of tasks in parallel, usually for iterating over a dimension of a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code>. By default, this uses <code><a class="elRef" href="https://ltla.github.io/subpar/namespacesubpar.html#a9c64cc17f4f8d1fadbba6d25053a8dbe">subpar::parallelize_range()</a></code> internally, which uses OpenMP if available and <code>&lt;thread&gt;</code> otherwise. Advanced users can override the default parallelization mechanism by defining a <code>TATAMI_CUSTOM_PARALLEL</code> function-like macro. The macro should accept the <code>fun</code>, <code>tasks</code> and <code>threads</code> arguments as described below.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether the tasks should be run in parallel. If <code>false</code>, no parallelization is performed and all tasks are run on the current thread. </td></tr>
    <tr><td class="paramname">Function_</td><td>Function to be applied for a contiguous range of tasks. This should accept three arguments:<ul>
<li><code>thread</code>, the thread number executing this task range. This will be passed as a <code>size_t</code>.</li>
<li><code>task_start</code>, the start index of the task range. This will be passed as a <code>Index_</code>.</li>
<li><code>task_length</code>, the number of tasks in the task range. This will be passed as a <code>Index_</code>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the number of tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Function that executes a contiguous range of tasks. </td></tr>
    <tr><td class="paramname">tasks</td><td>Number of tasks. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af01c93a616eb99f6a17861a8b19f7ee0" name="af01c93a616eb99f6a17861a8b19f7ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01c93a616eb99f6a17861a8b19f7ee0">&#9670;&#160;</a></span>process_consecutive_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , class Function_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::process_consecutive_indices </td>
          <td>(</td>
          <td class="paramtype">const Index_ *</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function_</td>          <td class="paramname"><span class="paramname"><em>fun</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process runs of consecutive indices that are used in the index-aware <code>dense_row()</code>, <code>sparse_column()</code>, etc. methods. This provides some opportunities for optimization when the indices contain contiguous stretches. For example, third-party libraries can be asked to process blocks of observations rather than handling them one at a time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Function_</td><td>Function to apply to each contiguous run.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Pointer to an array of sorted and unique indices for row/column elements. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the array pointed to by <code>indices</code>. </td></tr>
    <tr><td class="paramname">fun</td><td>Function to apply to each contiguous run of indices. This should take two arguments - the start index of each run, and the length of the run. Calls to <code>fun</code> are guaranteed to contain increasing start indices with non-overlapping runs. The return value of this function is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab008bae4e33a408de29e9fc49d0f902c" name="ab008bae4e33a408de29e9fc49d0f902c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab008bae4e33a408de29e9fc49d0f902c">&#9670;&#160;</a></span>wrap_shared_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::wrap_shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap a raw pointer inside a <code>shared_ptr</code>, typically to enable use of a raw <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code> pointer with delayed operation wrappers. This enables use of delayed operations inside functions that accept a raw pointer to an externally owned <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the same object addressed by <code>ptr</code>. The assumption is that <code>ptr</code> will always outlive the returned pointer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
