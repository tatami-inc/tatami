<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tatami Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Flexible representations for matrix data.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1ArrayView.html">ArrayView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View into a pre-allocated array.  <a href="classtatami_1_1ArrayView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1BlockSparsifiedWrapper.html">BlockSparsifiedWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a block dense extractor in the sparse interface.  <a href="classtatami_1_1BlockSparsifiedWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1CompressedSparseColumnMatrix.html">CompressedSparseColumnMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse column matrix.  <a href="classtatami_1_1CompressedSparseColumnMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1CompressedSparseContents.html">CompressedSparseContents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse contents.  <a href="structtatami_1_1CompressedSparseContents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1CompressedSparseMatrix.html">CompressedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse matrix representation.  <a href="classtatami_1_1CompressedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1CompressedSparseMatrixOptions.html">CompressedSparseMatrixOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for the <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">CompressedSparseMatrix</a></code>.  <a href="structtatami_1_1CompressedSparseMatrixOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1CompressedSparseRowMatrix.html">CompressedSparseRowMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed sparse row matrix.  <a href="classtatami_1_1CompressedSparseRowMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1ConsecutiveOracle.html">ConsecutiveOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses along a consecutive sequence.  <a href="classtatami_1_1ConsecutiveOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1ConstantMatrix.html">ConstantMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a> containing a constant value.  <a href="classtatami_1_1ConstantMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1ConvertToCompressedSparseOptions.html">ConvertToCompressedSparseOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#ae4758e123ce35dfe718a331a66ac0e16">convert_to_compressed_sparse()</a></code>.  <a href="structtatami_1_1ConvertToCompressedSparseOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1ConvertToDenseOptions.html">ConvertToDenseOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#ac5f5ff476ecb172e59c3535cedb966cd">convert_to_dense()</a></code>.  <a href="structtatami_1_1ConvertToDenseOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1ConvertToFragmentedSparseOptions.html">ConvertToFragmentedSparseOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#acac2470badcf668316367fdea9704035">convert_to_fragmented_sparse()</a></code>.  <a href="structtatami_1_1ConvertToFragmentedSparseOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1CountCompressedSparseNonZerosOptions.html">CountCompressedSparseNonZerosOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#a305c49810ea7cad498399ad7c9dd0ee0">count_compressed_sparse_non_zeros()</a></code>.  <a href="structtatami_1_1CountCompressedSparseNonZerosOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed binary isometric arithmetic.  <a href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html">DelayedBinaryIsometricBooleanHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed binary isometric boolean operations.  <a href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed binary isometric comparisons.  <a href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html">DelayedBinaryIsometricOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed isometric operations on two matrices.  <a href="classtatami_1_1DelayedBinaryIsometricOperation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">DelayedBinaryIsometricOperationHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper operation interface for <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>.  <a href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedBind.html">DelayedBind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed combining of a matrix.  <a href="classtatami_1_1DelayedBind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedCast.html">DelayedCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> to a different interface type.  <a href="classtatami_1_1DelayedCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubset.html">DelayedSubset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with general indices.  <a href="classtatami_1_1DelayedSubset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetBlock.html">DelayedSubsetBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting to a contiguous block.  <a href="classtatami_1_1DelayedSubsetBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetSorted.html">DelayedSubsetSorted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with sorted indices.  <a href="classtatami_1_1DelayedSubsetSorted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html">DelayedSubsetSortedUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with sorted, unique indices.  <a href="classtatami_1_1DelayedSubsetSortedUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedSubsetUnique.html">DelayedSubsetUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed subsetting of a matrix with unique indices.  <a href="classtatami_1_1DelayedSubsetUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedTranspose.html">DelayedTranspose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed transposition of a matrix.  <a href="classtatami_1_1DelayedTranspose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAbsHelper.html">DelayedUnaryIsometricAbsHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the sign of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAbsHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAcosHelper.html">DelayedUnaryIsometricAcosHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the inverse cosine of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAcosHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAcoshHelper.html">DelayedUnaryIsometricAcoshHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the inverse hyperbolic cosine of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAcoshHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed unary isometric scalar arithmetic.  <a href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed unary isometric vector arithmetic.  <a href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAsinHelper.html">DelayedUnaryIsometricAsinHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the inverse sine of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAsinHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAsinhHelper.html">DelayedUnaryIsometricAsinhHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the inverse hyperbolic sine of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAsinhHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAtanHelper.html">DelayedUnaryIsometricAtanHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the inverse tangent of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAtanHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricAtanhHelper.html">DelayedUnaryIsometricAtanhHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the inverse hyperbolic tangent of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricAtanhHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanCastHelper.html">DelayedUnaryIsometricBooleanCastHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed unary isometric boolean cast.  <a href="classtatami_1_1DelayedUnaryIsometricBooleanCastHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanNotHelper.html">DelayedUnaryIsometricBooleanNotHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for a delayed unary isometric boolean NOT operation.  <a href="classtatami_1_1DelayedUnaryIsometricBooleanNotHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalarHelper.html">DelayedUnaryIsometricBooleanScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed unary isometric scalar boolean operations.  <a href="classtatami_1_1DelayedUnaryIsometricBooleanScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVectorHelper.html">DelayedUnaryIsometricBooleanVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed unary isometric vector boolean operations.  <a href="classtatami_1_1DelayedUnaryIsometricBooleanVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCeilingHelper.html">DelayedUnaryIsometricCeilingHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the ceiling of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricCeilingHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed scalar comparisons.  <a href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed vector comparisons.  <a href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCosHelper.html">DelayedUnaryIsometricCosHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the cosine of a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricCosHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricCoshHelper.html">DelayedUnaryIsometricCoshHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the hyperbolic cosine of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricCoshHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricExpHelper.html">DelayedUnaryIsometricExpHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the exponent function for each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricExpHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricExpm1Helper.html">DelayedUnaryIsometricExpm1Helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the exponential function of each matrix entry minus 1.  <a href="classtatami_1_1DelayedUnaryIsometricExpm1Helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricFloorHelper.html">DelayedUnaryIsometricFloorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the floor of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricFloorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricGammaHelper.html">DelayedUnaryIsometricGammaHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the gamma function to a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricGammaHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricLgammaHelper.html">DelayedUnaryIsometricLgammaHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the log-gamma function to a matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricLgammaHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricLog1pHelper.html">DelayedUnaryIsometricLog1pHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for the delayed calculation of the logarithm of each matrix entry plus 1.  <a href="classtatami_1_1DelayedUnaryIsometricLog1pHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricLogHelper.html">DelayedUnaryIsometricLogHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the logarithm of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricLogHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html">DelayedUnaryIsometricOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed isometric operation on a single matrix.  <a href="classtatami_1_1DelayedUnaryIsometricOperation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html">DelayedUnaryIsometricOperationHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper operation interface for <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code>.  <a href="classtatami_1_1DelayedUnaryIsometricOperationHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricRoundHelper.html">DelayedUnaryIsometricRoundHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed rounding of each matrix entry to the nearest integer.  <a href="classtatami_1_1DelayedUnaryIsometricRoundHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSignHelper.html">DelayedUnaryIsometricSignHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the sign of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricSignHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSinHelper.html">DelayedUnaryIsometricSinHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the sine of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricSinHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSinhHelper.html">DelayedUnaryIsometricSinhHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the hyperbolic sine of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricSinhHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompareHelper.html">DelayedUnaryIsometricSpecialCompareHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed special value comparison.  <a href="classtatami_1_1DelayedUnaryIsometricSpecialCompareHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstituteHelper.html">DelayedUnaryIsometricSpecialSubstituteHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed special value substitution.  <a href="classtatami_1_1DelayedUnaryIsometricSpecialSubstituteHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSqrtHelper.html">DelayedUnaryIsometricSqrtHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the square root of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricSqrtHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed scalar substitution.  <a href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed vector comparisons.  <a href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricTanHelper.html">DelayedUnaryIsometricTanHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the tangent of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricTanHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricTanhHelper.html">DelayedUnaryIsometricTanhHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed calculation of the hyperbolic tangent of each matrix entry.  <a href="classtatami_1_1DelayedUnaryIsometricTanhHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DelayedUnaryIsometricTruncHelper.html">DelayedUnaryIsometricTruncHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for delayed truncation of each matrix entry to an integer.  <a href="classtatami_1_1DelayedUnaryIsometricTruncHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DenseColumnMatrix.html">DenseColumnMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense column-major matrix.  <a href="classtatami_1_1DenseColumnMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DenseMatrix.html">DenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense matrix representation.  <a href="classtatami_1_1DenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1DenseRowMatrix.html">DenseRowMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense row-major matrix.  <a href="classtatami_1_1DenseRowMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FillCompressedSparseContentsOptions.html">FillCompressedSparseContentsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#ac8dd052eda49e8b530947753c24f1178">fill_compressed_sparse_contents()</a></code>.  <a href="structtatami_1_1FillCompressedSparseContentsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FixedVectorOracle.html">FixedVectorOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses from a vector containing a fixed sequence.  <a href="classtatami_1_1FixedVectorOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FixedViewOracle.html">FixedViewOracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future accesses from a view on a fixed sequence.  <a href="classtatami_1_1FixedViewOracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FragmentedSparseColumnMatrix.html">FragmentedSparseColumnMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmented sparse column matrix.  <a href="classtatami_1_1FragmentedSparseColumnMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FragmentedSparseContents.html">FragmentedSparseContents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmented sparse contents.  <a href="structtatami_1_1FragmentedSparseContents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FragmentedSparseMatrix.html">FragmentedSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmented sparse matrix representation.  <a href="classtatami_1_1FragmentedSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1FragmentedSparseMatrixOptions.html">FragmentedSparseMatrixOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code>FragmentedSparseMatrix()</code>.  <a href="structtatami_1_1FragmentedSparseMatrixOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FragmentedSparseRowMatrix.html">FragmentedSparseRowMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmented sparse row matrix.  <a href="classtatami_1_1FragmentedSparseRowMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1FullSparsifiedWrapper.html">FullSparsifiedWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a full dense extractor in the sparse interface.  <a href="classtatami_1_1FullSparsifiedWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1has__data.html">has_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the <code>data()</code> method.  <a href="structtatami_1_1has__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1has__data_3_01Type___00_01Container___00_01decltype_07_07void_08_01std_1_1declva66f694cee1ca6e7d197226a9c6d58cf5.html">has_data&lt; Type_, Container_, decltype((void) std::declval&lt; Container_ &gt;().data(), 0)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the <code>data()</code> method.  <a href="structtatami_1_1has__data_3_01Type___00_01Container___00_01decltype_07_07void_08_01std_1_1declva66f694cee1ca6e7d197226a9c6d58cf5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1IndexSparsifiedWrapper.html">IndexSparsifiedWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an indexed dense extractor in the sparse interface.  <a href="classtatami_1_1IndexSparsifiedWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual class for a matrix.  <a href="classtatami_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an element of the target dimension in dense form without an oracle.  <a href="classtatami_1_1MyopicDenseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an element of the target dimension in sparse form without an oracle.  <a href="classtatami_1_1MyopicSparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for accessing data from a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> instance.  <a href="structtatami_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1Oracle.html">Oracle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predict future access requests on the target dimension.  <a href="classtatami_1_1Oracle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an element of the target dimension in dense form with an oracle.  <a href="classtatami_1_1OracularDenseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an element of the target dimension in sparse form with an oracle.  <a href="classtatami_1_1OracularSparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1PseudoOracularDenseExtractor.html">PseudoOracularDenseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mimic the <code><a class="el" href="classtatami_1_1OracularDenseExtractor.html" title="Extract an element of the target dimension in dense form with an oracle.">OracularDenseExtractor</a></code> interface.  <a href="structtatami_1_1PseudoOracularDenseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1PseudoOracularSparseExtractor.html">PseudoOracularSparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mimic the <code><a class="el" href="classtatami_1_1OracularSparseExtractor.html" title="Extract an element of the target dimension in sparse form with an oracle.">OracularSparseExtractor</a></code> interface.  <a href="structtatami_1_1PseudoOracularSparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1RetrieveCompressedSparseContentsOptions.html">RetrieveCompressedSparseContentsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#a7e0ab534fd3195a57abcb47272d41ded">retrieve_compressed_sparse_contents()</a></code>.  <a href="structtatami_1_1RetrieveCompressedSparseContentsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1RetrieveFragmentedSparseContentsOptions.html">RetrieveFragmentedSparseContentsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtatami_1_1Options.html" title="Options for accessing data from a Matrix instance.">Options</a> for <code><a class="el" href="#a4b4feed54780ff0d6ec18a38a5752f22">retrieve_fragmented_sparse_contents()</a></code>.  <a href="structtatami_1_1RetrieveFragmentedSparseContentsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtatami_1_1SomeNumericArray.html">SomeNumericArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of some numeric type, determined at runtime.  <a href="classtatami_1_1SomeNumericArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of a sparse vector.  <a href="structtatami_1_1SparseRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a92f2deb44e0a3cb1c569a379c6facbf0" id="r_a92f2deb44e0a3cb1c569a379c6facbf0"><td class="memTemplParams" colspan="2">template&lt;bool oracle_, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a92f2deb44e0a3cb1c569a379c6facbf0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92f2deb44e0a3cb1c569a379c6facbf0">DenseExtractor</a> = typename std::conditional&lt;oracle_, <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt;Value_, Index_&gt;, <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt;Value_, Index_&gt; &gt;::type</td></tr>
<tr class="separator:a92f2deb44e0a3cb1c569a379c6facbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213ab58ba31e5b5cee3b66ab54d86055" id="r_a213ab58ba31e5b5cee3b66ab54d86055"><td class="memTemplParams" colspan="2">template&lt;bool oracle_, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a213ab58ba31e5b5cee3b66ab54d86055"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a213ab58ba31e5b5cee3b66ab54d86055">SparseExtractor</a> = typename std::conditional&lt;oracle_, <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt;Value_, Index_&gt;, <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt;Value_, Index_&gt; &gt;::type</td></tr>
<tr class="separator:a213ab58ba31e5b5cee3b66ab54d86055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9c70ebcfa94bba3fea89202868f22f" id="r_a1a9c70ebcfa94bba3fea89202868f22f"><td class="memTemplParams" colspan="2">template&lt;typename Index_ &gt; </td></tr>
<tr class="memitem:a1a9c70ebcfa94bba3fea89202868f22f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1a9c70ebcfa94bba3fea89202868f22f">VectorPtr</a> = std::shared_ptr&lt;const std::vector&lt;Index_&gt; &gt;</td></tr>
<tr class="separator:a1a9c70ebcfa94bba3fea89202868f22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0438743ada096f37f307404851849ff" id="r_ae0438743ada096f37f307404851849ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0438743ada096f37f307404851849ff">NumericMatrix</a> = <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt;double, int&gt;</td></tr>
<tr class="separator:ae0438743ada096f37f307404851849ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdedcc902be98f3bd38f3507b906971c" id="r_acdedcc902be98f3bd38f3507b906971c"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdedcc902be98f3bd38f3507b906971c">PredictionIndex</a></td></tr>
<tr class="separator:acdedcc902be98f3bd38f3507b906971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57425b6548448b71576c04f16f4dc38d" id="r_a57425b6548448b71576c04f16f4dc38d"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </td></tr>
<tr class="memitem:a57425b6548448b71576c04f16f4dc38d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57425b6548448b71576c04f16f4dc38d">DelayedBinaryIsometricAddHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::ADD, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a57425b6548448b71576c04f16f4dc38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea7ab7eb80b65e7bc275ae6974dbe91" id="r_a0ea7ab7eb80b65e7bc275ae6974dbe91"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </td></tr>
<tr class="memitem:a0ea7ab7eb80b65e7bc275ae6974dbe91"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ea7ab7eb80b65e7bc275ae6974dbe91">DelayedBinaryIsometricSubtractHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::SUBTRACT, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a0ea7ab7eb80b65e7bc275ae6974dbe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cae360a45009c024535d56ba44df5e9" id="r_a5cae360a45009c024535d56ba44df5e9"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </td></tr>
<tr class="memitem:a5cae360a45009c024535d56ba44df5e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5cae360a45009c024535d56ba44df5e9">DelayedBinaryIsometricMultiplyHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::MULTIPLY, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a5cae360a45009c024535d56ba44df5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc6e39d79401f8c36df9275c5516987" id="r_a7cc6e39d79401f8c36df9275c5516987"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </td></tr>
<tr class="memitem:a7cc6e39d79401f8c36df9275c5516987"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7cc6e39d79401f8c36df9275c5516987">DelayedBinaryIsometricDivideHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::DIVIDE, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a7cc6e39d79401f8c36df9275c5516987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bc59578440745268c68b309dd9148b" id="r_af5bc59578440745268c68b309dd9148b"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </td></tr>
<tr class="memitem:af5bc59578440745268c68b309dd9148b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5bc59578440745268c68b309dd9148b">DelayedBinaryIsometricPowerHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::POWER, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:af5bc59578440745268c68b309dd9148b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aec21138d1d3fcd94d58c3c97bc2306" id="r_a8aec21138d1d3fcd94d58c3c97bc2306"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </td></tr>
<tr class="memitem:a8aec21138d1d3fcd94d58c3c97bc2306"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8aec21138d1d3fcd94d58c3c97bc2306">DelayedBinaryIsometricModuloHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::MODULO, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a8aec21138d1d3fcd94d58c3c97bc2306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739a793b946dc62804ae15b550006ecf" id="r_a739a793b946dc62804ae15b550006ecf"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </td></tr>
<tr class="memitem:a739a793b946dc62804ae15b550006ecf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a739a793b946dc62804ae15b550006ecf">DelayedBinaryIsometricIntegerDivideHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::INTEGER_DIVIDE, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a739a793b946dc62804ae15b550006ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273c375113ac8a41d70dcb96b34a8f70" id="r_a273c375113ac8a41d70dcb96b34a8f70"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a273c375113ac8a41d70dcb96b34a8f70"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a273c375113ac8a41d70dcb96b34a8f70">DelayedBinaryIsometricBooleanEqualHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html">DelayedBinaryIsometricBooleanHelper</a>&lt;BooleanOperation::EQUAL, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a273c375113ac8a41d70dcb96b34a8f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2bedfee72494dd676f535b6e646944" id="r_abb2bedfee72494dd676f535b6e646944"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:abb2bedfee72494dd676f535b6e646944"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abb2bedfee72494dd676f535b6e646944">DelayedBinaryIsometricBooleanAndHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html">DelayedBinaryIsometricBooleanHelper</a>&lt;BooleanOperation::AND, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:abb2bedfee72494dd676f535b6e646944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcffb4b3b4ca704f3c70ca1982b94b5b" id="r_afcffb4b3b4ca704f3c70ca1982b94b5b"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:afcffb4b3b4ca704f3c70ca1982b94b5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afcffb4b3b4ca704f3c70ca1982b94b5b">DelayedBinaryIsometricBooleanOrHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html">DelayedBinaryIsometricBooleanHelper</a>&lt;BooleanOperation::OR, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:afcffb4b3b4ca704f3c70ca1982b94b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6065e08151681689b5023badb803f100" id="r_a6065e08151681689b5023badb803f100"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a6065e08151681689b5023badb803f100"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6065e08151681689b5023badb803f100">DelayedBinaryIsometricBooleanXorHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html">DelayedBinaryIsometricBooleanHelper</a>&lt;BooleanOperation::XOR, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a6065e08151681689b5023badb803f100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8301bb5bced53cf6f9fc880724621536" id="r_a8301bb5bced53cf6f9fc880724621536"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a8301bb5bced53cf6f9fc880724621536"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8301bb5bced53cf6f9fc880724621536">DelayedBinaryIsometricEqualHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a>&lt;CompareOperation::EQUAL, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a8301bb5bced53cf6f9fc880724621536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575089ae32a21531432a27594a04ccd7" id="r_a575089ae32a21531432a27594a04ccd7"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a575089ae32a21531432a27594a04ccd7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a575089ae32a21531432a27594a04ccd7">DelayedBinaryIsometricGreaterThanHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a>&lt;CompareOperation::GREATER_THAN, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a575089ae32a21531432a27594a04ccd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03a1f8ae5f3b551ff6b613c6b99d178" id="r_ae03a1f8ae5f3b551ff6b613c6b99d178"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ae03a1f8ae5f3b551ff6b613c6b99d178"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae03a1f8ae5f3b551ff6b613c6b99d178">DelayedBinaryIsometricLessThanHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a>&lt;CompareOperation::LESS_THAN, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:ae03a1f8ae5f3b551ff6b613c6b99d178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b7253051f5faf636fc2ebde7d495ea" id="r_aa7b7253051f5faf636fc2ebde7d495ea"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:aa7b7253051f5faf636fc2ebde7d495ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa7b7253051f5faf636fc2ebde7d495ea">DelayedBinaryIsometricGreaterThanOrEqualHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a>&lt;CompareOperation::GREATER_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:aa7b7253051f5faf636fc2ebde7d495ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc2cbf8430b064492cba8bdbe7c89aa" id="r_a8dc2cbf8430b064492cba8bdbe7c89aa"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a8dc2cbf8430b064492cba8bdbe7c89aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8dc2cbf8430b064492cba8bdbe7c89aa">DelayedBinaryIsometricLessThanOrEqualHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a>&lt;CompareOperation::LESS_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a8dc2cbf8430b064492cba8bdbe7c89aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d6ad9e461ce20731c532061e09e617" id="r_a83d6ad9e461ce20731c532061e09e617"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a83d6ad9e461ce20731c532061e09e617"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a83d6ad9e461ce20731c532061e09e617">DelayedBinaryIsometricNotEqualHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a>&lt;CompareOperation::NOT_EQUAL, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a83d6ad9e461ce20731c532061e09e617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2292212afeb290e4dff7f36aa054fb9" id="r_af2292212afeb290e4dff7f36aa054fb9"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:af2292212afeb290e4dff7f36aa054fb9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af2292212afeb290e4dff7f36aa054fb9">DelayedUnaryIsometricAddScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::ADD, true, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:af2292212afeb290e4dff7f36aa054fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4809abe02f2d2f90ee7404f42b7b777" id="r_af4809abe02f2d2f90ee7404f42b7b777"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:af4809abe02f2d2f90ee7404f42b7b777"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af4809abe02f2d2f90ee7404f42b7b777">DelayedUnaryIsometricSubtractScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::SUBTRACT, right_, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:af4809abe02f2d2f90ee7404f42b7b777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49c318a02237b845b6aaea33b894242" id="r_ab49c318a02237b845b6aaea33b894242"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:ab49c318a02237b845b6aaea33b894242"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab49c318a02237b845b6aaea33b894242">DelayedUnaryIsometricMultiplyScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::MULTIPLY, true, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:ab49c318a02237b845b6aaea33b894242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56ef7076f6972dc24e450811a624906" id="r_ab56ef7076f6972dc24e450811a624906"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:ab56ef7076f6972dc24e450811a624906"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab56ef7076f6972dc24e450811a624906">DelayedUnaryIsometricDivideScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::DIVIDE, right_, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:ab56ef7076f6972dc24e450811a624906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464a72a2ccd0355d064c2778afbe732b" id="r_a464a72a2ccd0355d064c2778afbe732b"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:a464a72a2ccd0355d064c2778afbe732b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a464a72a2ccd0355d064c2778afbe732b">DelayedUnaryIsometricPowerScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::POWER, right_, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:a464a72a2ccd0355d064c2778afbe732b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15002f7fff6e73aa829f87b9f4fad7b7" id="r_a15002f7fff6e73aa829f87b9f4fad7b7"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:a15002f7fff6e73aa829f87b9f4fad7b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a15002f7fff6e73aa829f87b9f4fad7b7">DelayedUnaryIsometricModuloScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::MODULO, right_, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:a15002f7fff6e73aa829f87b9f4fad7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb6226285e0eafc99868c686d2ff6bf" id="r_aadb6226285e0eafc99868c686d2ff6bf"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:aadb6226285e0eafc99868c686d2ff6bf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aadb6226285e0eafc99868c686d2ff6bf">DelayedUnaryIsometricIntegerDivideScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::INTEGER_DIVIDE, right_, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:aadb6226285e0eafc99868c686d2ff6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdb1b3448ed9bcb6dc7328f96c0e0a5" id="r_aecdb1b3448ed9bcb6dc7328f96c0e0a5"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:aecdb1b3448ed9bcb6dc7328f96c0e0a5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aecdb1b3448ed9bcb6dc7328f96c0e0a5">DelayedUnaryIsometricAddVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::ADD, true, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:aecdb1b3448ed9bcb6dc7328f96c0e0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78329812c3ab5ada1be83f590a96c18a" id="r_a78329812c3ab5ada1be83f590a96c18a"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:a78329812c3ab5ada1be83f590a96c18a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78329812c3ab5ada1be83f590a96c18a">DelayedUnaryIsometricSubtractVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::SUBTRACT, right_, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:a78329812c3ab5ada1be83f590a96c18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e2b0461234d6bf0c9240a8a2777b8a" id="r_a51e2b0461234d6bf0c9240a8a2777b8a"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:a51e2b0461234d6bf0c9240a8a2777b8a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a51e2b0461234d6bf0c9240a8a2777b8a">DelayedUnaryIsometricMultiplyVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::MULTIPLY, true, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:a51e2b0461234d6bf0c9240a8a2777b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbcd076270f137cbfff8f5af613ba49" id="r_a9dbcd076270f137cbfff8f5af613ba49"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:a9dbcd076270f137cbfff8f5af613ba49"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9dbcd076270f137cbfff8f5af613ba49">DelayedUnaryIsometricDivideVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::DIVIDE, right_, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:a9dbcd076270f137cbfff8f5af613ba49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba14f9ea3d6c7b8fb98b34d54aafb59" id="r_a7ba14f9ea3d6c7b8fb98b34d54aafb59"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:a7ba14f9ea3d6c7b8fb98b34d54aafb59"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ba14f9ea3d6c7b8fb98b34d54aafb59">DelayedUnaryIsometricPowerVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::POWER, right_, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:a7ba14f9ea3d6c7b8fb98b34d54aafb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf1c8702a170bf686bda7f50a1d55f8" id="r_afaf1c8702a170bf686bda7f50a1d55f8"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:afaf1c8702a170bf686bda7f50a1d55f8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afaf1c8702a170bf686bda7f50a1d55f8">DelayedUnaryIsometricModuloVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::MODULO, right_, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:afaf1c8702a170bf686bda7f50a1d55f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4ac3cd66fe866bb94e7692f717ce51" id="r_a4c4ac3cd66fe866bb94e7692f717ce51"><td class="memTemplParams" colspan="2">template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:a4c4ac3cd66fe866bb94e7692f717ce51"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c4ac3cd66fe866bb94e7692f717ce51">DelayedUnaryIsometricIntegerDivideVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::INTEGER_DIVIDE, right_, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:a4c4ac3cd66fe866bb94e7692f717ce51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61040dd1b833692e48a53a79015a26d8" id="r_a61040dd1b833692e48a53a79015a26d8"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a61040dd1b833692e48a53a79015a26d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a61040dd1b833692e48a53a79015a26d8">DelayedUnaryIsometricBooleanEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalarHelper.html">DelayedUnaryIsometricBooleanScalarHelper</a>&lt;BooleanOperation::EQUAL, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a61040dd1b833692e48a53a79015a26d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d8f7239498a6631bc728518d2c4d60" id="r_a80d8f7239498a6631bc728518d2c4d60"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a80d8f7239498a6631bc728518d2c4d60"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a80d8f7239498a6631bc728518d2c4d60">DelayedUnaryIsometricBooleanAndScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalarHelper.html">DelayedUnaryIsometricBooleanScalarHelper</a>&lt;BooleanOperation::AND, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a80d8f7239498a6631bc728518d2c4d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6a6321e96323e7cc3ee2c6bbe7de53" id="r_ace6a6321e96323e7cc3ee2c6bbe7de53"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ace6a6321e96323e7cc3ee2c6bbe7de53"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace6a6321e96323e7cc3ee2c6bbe7de53">DelayedUnaryIsometricBooleanOrScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalarHelper.html">DelayedUnaryIsometricBooleanScalarHelper</a>&lt;BooleanOperation::OR, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:ace6a6321e96323e7cc3ee2c6bbe7de53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2803fa1c9ae921fcf7901b7e16723217" id="r_a2803fa1c9ae921fcf7901b7e16723217"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a2803fa1c9ae921fcf7901b7e16723217"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2803fa1c9ae921fcf7901b7e16723217">DelayedUnaryIsometricBooleanXorScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalarHelper.html">DelayedUnaryIsometricBooleanScalarHelper</a>&lt;BooleanOperation::XOR, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a2803fa1c9ae921fcf7901b7e16723217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2da6aa028f9f9b761ad014d3d6e8af" id="r_a2d2da6aa028f9f9b761ad014d3d6e8af"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:a2d2da6aa028f9f9b761ad014d3d6e8af"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d2da6aa028f9f9b761ad014d3d6e8af">DelayedUnaryIsometricBooleanEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVectorHelper.html">DelayedUnaryIsometricBooleanVectorHelper</a>&lt;BooleanOperation::EQUAL, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:a2d2da6aa028f9f9b761ad014d3d6e8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f179809ea91935f94c319ecf687138" id="r_a82f179809ea91935f94c319ecf687138"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:a82f179809ea91935f94c319ecf687138"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a82f179809ea91935f94c319ecf687138">DelayedUnaryIsometricBooleanAndVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVectorHelper.html">DelayedUnaryIsometricBooleanVectorHelper</a>&lt;BooleanOperation::AND, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:a82f179809ea91935f94c319ecf687138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00469f0584ca17dc3e6292f4aad4ef50" id="r_a00469f0584ca17dc3e6292f4aad4ef50"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:a00469f0584ca17dc3e6292f4aad4ef50"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00469f0584ca17dc3e6292f4aad4ef50">DelayedUnaryIsometricBooleanOrVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVectorHelper.html">DelayedUnaryIsometricBooleanVectorHelper</a>&lt;BooleanOperation::OR, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:a00469f0584ca17dc3e6292f4aad4ef50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8497a6e6a96766aa03d0f3de4f502726" id="r_a8497a6e6a96766aa03d0f3de4f502726"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:a8497a6e6a96766aa03d0f3de4f502726"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8497a6e6a96766aa03d0f3de4f502726">DelayedUnaryIsometricBooleanXorVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVectorHelper.html">DelayedUnaryIsometricBooleanVectorHelper</a>&lt;BooleanOperation::XOR, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:a8497a6e6a96766aa03d0f3de4f502726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc54c092d0ed88020a588e968b6aa87" id="r_a5dc54c092d0ed88020a588e968b6aa87"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:a5dc54c092d0ed88020a588e968b6aa87"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5dc54c092d0ed88020a588e968b6aa87">DelayedUnaryIsometricEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a>&lt;CompareOperation::EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:a5dc54c092d0ed88020a588e968b6aa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60ad4ee3808aae10ddd24031ad6f781" id="r_af60ad4ee3808aae10ddd24031ad6f781"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:af60ad4ee3808aae10ddd24031ad6f781"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af60ad4ee3808aae10ddd24031ad6f781">DelayedUnaryIsometricGreaterThanScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a>&lt;CompareOperation::GREATER_THAN, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:af60ad4ee3808aae10ddd24031ad6f781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b19844aaf36539c53436d80ea83c0d6" id="r_a8b19844aaf36539c53436d80ea83c0d6"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:a8b19844aaf36539c53436d80ea83c0d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b19844aaf36539c53436d80ea83c0d6">DelayedUnaryIsometricLessThanScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a>&lt;CompareOperation::LESS_THAN, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:a8b19844aaf36539c53436d80ea83c0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5c19886f4873a8cd84f0cb250c7923" id="r_a8c5c19886f4873a8cd84f0cb250c7923"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:a8c5c19886f4873a8cd84f0cb250c7923"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c5c19886f4873a8cd84f0cb250c7923">DelayedUnaryIsometricGreaterThanOrEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a>&lt;CompareOperation::GREATER_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:a8c5c19886f4873a8cd84f0cb250c7923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8e15999b164083daf19f4b9405f38f" id="r_abf8e15999b164083daf19f4b9405f38f"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:abf8e15999b164083daf19f4b9405f38f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf8e15999b164083daf19f4b9405f38f">DelayedUnaryIsometricLessThanOrEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a>&lt;CompareOperation::LESS_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:abf8e15999b164083daf19f4b9405f38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c56245791d6fc70a5b70d4a67cda390" id="r_a9c56245791d6fc70a5b70d4a67cda390"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:a9c56245791d6fc70a5b70d4a67cda390"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c56245791d6fc70a5b70d4a67cda390">DelayedUnaryIsometricNotEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a>&lt;CompareOperation::NOT_EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:a9c56245791d6fc70a5b70d4a67cda390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28256a85f8fb04234807b89672a4902e" id="r_a28256a85f8fb04234807b89672a4902e"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:a28256a85f8fb04234807b89672a4902e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a28256a85f8fb04234807b89672a4902e">DelayedUnaryIsometricEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a>&lt;CompareOperation::EQUAL, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:a28256a85f8fb04234807b89672a4902e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a3bdf1378f20d210367c69c0c60462" id="r_a57a3bdf1378f20d210367c69c0c60462"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:a57a3bdf1378f20d210367c69c0c60462"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57a3bdf1378f20d210367c69c0c60462">DelayedUnaryIsometricGreaterThanVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a>&lt;CompareOperation::GREATER_THAN, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:a57a3bdf1378f20d210367c69c0c60462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cd0eaa035a836cad4ef992ad11d3f1" id="r_af4cd0eaa035a836cad4ef992ad11d3f1"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:af4cd0eaa035a836cad4ef992ad11d3f1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af4cd0eaa035a836cad4ef992ad11d3f1">DelayedUnaryIsometricLessThanVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a>&lt;CompareOperation::LESS_THAN, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:af4cd0eaa035a836cad4ef992ad11d3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3e5df8ef9e30e0bb33157a54dbb017" id="r_aea3e5df8ef9e30e0bb33157a54dbb017"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:aea3e5df8ef9e30e0bb33157a54dbb017"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea3e5df8ef9e30e0bb33157a54dbb017">DelayedUnaryIsometricGreaterThanOrEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a>&lt;CompareOperation::GREATER_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:aea3e5df8ef9e30e0bb33157a54dbb017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bc075ad032f1fae7a55bcb0c838d28" id="r_ad6bc075ad032f1fae7a55bcb0c838d28"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:ad6bc075ad032f1fae7a55bcb0c838d28"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad6bc075ad032f1fae7a55bcb0c838d28">DelayedUnaryIsometricLessThanOrEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a>&lt;CompareOperation::LESS_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:ad6bc075ad032f1fae7a55bcb0c838d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e91a967f132fa20cea6838ad7a18ecc" id="r_a4e91a967f132fa20cea6838ad7a18ecc"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </td></tr>
<tr class="memitem:a4e91a967f132fa20cea6838ad7a18ecc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e91a967f132fa20cea6838ad7a18ecc">DelayedUnaryIsometricNotEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a>&lt;CompareOperation::NOT_EQUAL, OutputValue_, InputValue_, Index_, Vector_&gt;</td></tr>
<tr class="separator:a4e91a967f132fa20cea6838ad7a18ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af819a1749116a16befe9c6941683acab" id="r_af819a1749116a16befe9c6941683acab"><td class="memTemplParams" colspan="2">template&lt;bool pass_, typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:af819a1749116a16befe9c6941683acab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af819a1749116a16befe9c6941683acab">DelayedUnaryIsometricIsnanHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompareHelper.html">DelayedUnaryIsometricSpecialCompareHelper</a>&lt;SpecialCompareOperation::ISNAN, pass_, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:af819a1749116a16befe9c6941683acab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada7b7f5b035cc60a27600ac893bda98" id="r_aada7b7f5b035cc60a27600ac893bda98"><td class="memTemplParams" colspan="2">template&lt;bool pass_, typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:aada7b7f5b035cc60a27600ac893bda98"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aada7b7f5b035cc60a27600ac893bda98">DelayedUnaryIsometricIsinfHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompareHelper.html">DelayedUnaryIsometricSpecialCompareHelper</a>&lt;SpecialCompareOperation::ISINF, pass_, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:aada7b7f5b035cc60a27600ac893bda98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e742490eb4b0300c915d47fd98e398" id="r_a16e742490eb4b0300c915d47fd98e398"><td class="memTemplParams" colspan="2">template&lt;bool pass_, typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a16e742490eb4b0300c915d47fd98e398"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a16e742490eb4b0300c915d47fd98e398">DelayedUnaryIsometricIsfiniteHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompareHelper.html">DelayedUnaryIsometricSpecialCompareHelper</a>&lt;SpecialCompareOperation::ISFINITE, pass_, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a16e742490eb4b0300c915d47fd98e398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a5e88bdd28d9bda030d8bf20ce0d2e" id="r_a98a5e88bdd28d9bda030d8bf20ce0d2e"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:a98a5e88bdd28d9bda030d8bf20ce0d2e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a98a5e88bdd28d9bda030d8bf20ce0d2e">DelayedUnaryIsometricSubstituteEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a>&lt;CompareOperation::EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:a98a5e88bdd28d9bda030d8bf20ce0d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad240d87978cdf3d57b65c9f25f4c7700" id="r_ad240d87978cdf3d57b65c9f25f4c7700"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:ad240d87978cdf3d57b65c9f25f4c7700"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad240d87978cdf3d57b65c9f25f4c7700">DelayedUnaryIsometricSubstituteGreaterThanScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a>&lt;CompareOperation::GREATER_THAN, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:ad240d87978cdf3d57b65c9f25f4c7700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67195ce7793682b9698dfdbba0ae0396" id="r_a67195ce7793682b9698dfdbba0ae0396"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:a67195ce7793682b9698dfdbba0ae0396"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a67195ce7793682b9698dfdbba0ae0396">DelayedUnaryIsometricSubstituteLessThanScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a>&lt;CompareOperation::LESS_THAN, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:a67195ce7793682b9698dfdbba0ae0396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4079ceca160d5eeca88e1c015b741691" id="r_a4079ceca160d5eeca88e1c015b741691"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:a4079ceca160d5eeca88e1c015b741691"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4079ceca160d5eeca88e1c015b741691">DelayedUnaryIsometricSubstituteGreaterThanOrEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a>&lt;CompareOperation::GREATER_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:a4079ceca160d5eeca88e1c015b741691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe06f2445eea2bac346285bac40ba81" id="r_adbe06f2445eea2bac346285bac40ba81"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:adbe06f2445eea2bac346285bac40ba81"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbe06f2445eea2bac346285bac40ba81">DelayedUnaryIsometricSubstituteLessThanOrEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a>&lt;CompareOperation::LESS_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:adbe06f2445eea2bac346285bac40ba81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14b2d50ec74c5c326298f55dd2e20f5" id="r_ad14b2d50ec74c5c326298f55dd2e20f5"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </td></tr>
<tr class="memitem:ad14b2d50ec74c5c326298f55dd2e20f5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad14b2d50ec74c5c326298f55dd2e20f5">DelayedUnaryIsometricSubstituteNotEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a>&lt;CompareOperation::NOT_EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td></tr>
<tr class="separator:ad14b2d50ec74c5c326298f55dd2e20f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43c2a731fa3de6cd038a6965f81577b" id="r_ac43c2a731fa3de6cd038a6965f81577b"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename ComparedVector_ , typename SubstituteVector_ &gt; </td></tr>
<tr class="memitem:ac43c2a731fa3de6cd038a6965f81577b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac43c2a731fa3de6cd038a6965f81577b">DelayedUnaryIsometricSubstituteEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a>&lt;CompareOperation::EQUAL, OutputValue_, InputValue_, Index_, ComparedVector_, SubstituteVector_&gt;</td></tr>
<tr class="separator:ac43c2a731fa3de6cd038a6965f81577b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c262b66d87bb7e9033d619cdcf169b" id="r_ad9c262b66d87bb7e9033d619cdcf169b"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename ComparedVector_ , typename SubstituteVector_ &gt; </td></tr>
<tr class="memitem:ad9c262b66d87bb7e9033d619cdcf169b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9c262b66d87bb7e9033d619cdcf169b">DelayedUnaryIsometricSubstituteGreaterThanVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a>&lt;CompareOperation::GREATER_THAN, OutputValue_, InputValue_, Index_, ComparedVector_, SubstituteVector_&gt;</td></tr>
<tr class="separator:ad9c262b66d87bb7e9033d619cdcf169b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136ddc464e7c3ca5c0cb161074eb2e4f" id="r_a136ddc464e7c3ca5c0cb161074eb2e4f"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename ComparedVector_ , typename SubstituteVector_ &gt; </td></tr>
<tr class="memitem:a136ddc464e7c3ca5c0cb161074eb2e4f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a136ddc464e7c3ca5c0cb161074eb2e4f">DelayedUnaryIsometricSubstituteLessThanVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a>&lt;CompareOperation::LESS_THAN, OutputValue_, InputValue_, Index_, ComparedVector_, SubstituteVector_&gt;</td></tr>
<tr class="separator:a136ddc464e7c3ca5c0cb161074eb2e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdc6e163e4777518dd881d5e97c566f" id="r_aacdc6e163e4777518dd881d5e97c566f"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename ComparedVector_ , typename SubstituteVector_ &gt; </td></tr>
<tr class="memitem:aacdc6e163e4777518dd881d5e97c566f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aacdc6e163e4777518dd881d5e97c566f">DelayedUnaryIsometricSubstituteGreaterThanOrEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a>&lt;CompareOperation::GREATER_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, ComparedVector_, SubstituteVector_&gt;</td></tr>
<tr class="separator:aacdc6e163e4777518dd881d5e97c566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217608866f96365bd9370c9f09fb242c" id="r_a217608866f96365bd9370c9f09fb242c"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename ComparedVector_ , typename SubstituteVector_ &gt; </td></tr>
<tr class="memitem:a217608866f96365bd9370c9f09fb242c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a217608866f96365bd9370c9f09fb242c">DelayedUnaryIsometricSubstituteLessThanOrEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a>&lt;CompareOperation::LESS_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, ComparedVector_, SubstituteVector_&gt;</td></tr>
<tr class="separator:a217608866f96365bd9370c9f09fb242c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf285b6e52c66ec11445d6a69a6bdd50" id="r_abf285b6e52c66ec11445d6a69a6bdd50"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename ComparedVector_ , typename SubstituteVector_ &gt; </td></tr>
<tr class="memitem:abf285b6e52c66ec11445d6a69a6bdd50"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf285b6e52c66ec11445d6a69a6bdd50">DelayedUnaryIsometricSubstituteNotEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a>&lt;CompareOperation::NOT_EQUAL, OutputValue_, InputValue_, Index_, ComparedVector_, SubstituteVector_&gt;</td></tr>
<tr class="separator:abf285b6e52c66ec11445d6a69a6bdd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20c8766117c8e362b4d7cffb1d4b9e9" id="r_af20c8766117c8e362b4d7cffb1d4b9e9"><td class="memTemplParams" colspan="2">template&lt;bool pass_, typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:af20c8766117c8e362b4d7cffb1d4b9e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af20c8766117c8e362b4d7cffb1d4b9e9">DelayedUnaryIsometricSubstituteIsnanHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstituteHelper.html">DelayedUnaryIsometricSpecialSubstituteHelper</a>&lt;SpecialCompareOperation::ISNAN, pass_, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:af20c8766117c8e362b4d7cffb1d4b9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc2988a433b39c29c4eda6348e023bc" id="r_a7fc2988a433b39c29c4eda6348e023bc"><td class="memTemplParams" colspan="2">template&lt;bool pass_, typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a7fc2988a433b39c29c4eda6348e023bc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7fc2988a433b39c29c4eda6348e023bc">DelayedUnaryIsometricSubstituteIsinfHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstituteHelper.html">DelayedUnaryIsometricSpecialSubstituteHelper</a>&lt;SpecialCompareOperation::ISINF, pass_, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:a7fc2988a433b39c29c4eda6348e023bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add55c44e96392e7c562ac87fce83f11d" id="r_add55c44e96392e7c562ac87fce83f11d"><td class="memTemplParams" colspan="2">template&lt;bool pass_, typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </td></tr>
<tr class="memitem:add55c44e96392e7c562ac87fce83f11d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add55c44e96392e7c562ac87fce83f11d">DelayedUnaryIsometricSubstituteIsfiniteHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstituteHelper.html">DelayedUnaryIsometricSpecialSubstituteHelper</a>&lt;SpecialCompareOperation::ISFINITE, pass_, OutputValue_, InputValue_, Index_&gt;</td></tr>
<tr class="separator:add55c44e96392e7c562ac87fce83f11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7676f28b5618fd937e38b7a5c759d8bf" id="r_a7676f28b5618fd937e38b7a5c759d8bf"><td class="memTemplParams" colspan="2">template&lt;class Array_ &gt; </td></tr>
<tr class="memitem:a7676f28b5618fd937e38b7a5c759d8bf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7676f28b5618fd937e38b7a5c759d8bf">ElementType</a> = I&lt;decltype(std::declval&lt;Array_&gt;()[0])&gt;</td></tr>
<tr class="separator:a7676f28b5618fd937e38b7a5c759d8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812af1bfb04773bf28da8549c3e6e5ee" id="r_a812af1bfb04773bf28da8549c3e6e5ee"><td class="memTemplParams" colspan="2">template&lt;bool oracle_, typename Index_ &gt; </td></tr>
<tr class="memitem:a812af1bfb04773bf28da8549c3e6e5ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a812af1bfb04773bf28da8549c3e6e5ee">MaybeOracle</a> = typename std::conditional&lt;oracle_, std::shared_ptr&lt;const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt;Index_&gt; &gt;, bool&gt;::type</td></tr>
<tr class="separator:a812af1bfb04773bf28da8549c3e6e5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0a2ecaf58e2b69bb4a808e814aeb16a1" id="r_a0a2ecaf58e2b69bb4a808e814aeb16a1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a2ecaf58e2b69bb4a808e814aeb16a1">DimensionSelectionType</a> : char { <b>FULL</b>
, <b>BLOCK</b>
, <b>INDEX</b>
 }</td></tr>
<tr class="separator:a0a2ecaf58e2b69bb4a808e814aeb16a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9050a4b119e027638175c38cc9bbede8" id="r_a9050a4b119e027638175c38cc9bbede8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9050a4b119e027638175c38cc9bbede8">ArithmeticOperation</a> : char { <br />
&#160;&#160;<b>ADD</b>
, <b>SUBTRACT</b>
, <b>MULTIPLY</b>
, <b>DIVIDE</b>
, <br />
&#160;&#160;<b>POWER</b>
, <b>MODULO</b>
, <b>INTEGER_DIVIDE</b>
<br />
 }</td></tr>
<tr class="separator:a9050a4b119e027638175c38cc9bbede8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5eea599200bfb6bc42f184118be28a" id="r_a4e5eea599200bfb6bc42f184118be28a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e5eea599200bfb6bc42f184118be28a">BooleanOperation</a> : char { <b>AND</b>
, <b>OR</b>
, <b>XOR</b>
, <b>EQUAL</b>
 }</td></tr>
<tr class="separator:a4e5eea599200bfb6bc42f184118be28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89475b46f681dd39b9926ced507240cc" id="r_a89475b46f681dd39b9926ced507240cc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89475b46f681dd39b9926ced507240cc">CompareOperation</a> : char { <br />
&#160;&#160;<b>EQUAL</b>
, <b>GREATER_THAN</b>
, <b>LESS_THAN</b>
, <b>GREATER_THAN_OR_EQUAL</b>
, <br />
&#160;&#160;<b>LESS_THAN_OR_EQUAL</b>
, <b>NOT_EQUAL</b>
<br />
 }</td></tr>
<tr class="separator:a89475b46f681dd39b9926ced507240cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef624db40413dabc3fea554fc936d39" id="r_a4ef624db40413dabc3fea554fc936d39"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ef624db40413dabc3fea554fc936d39">SpecialCompareOperation</a> : char { <b>ISNAN</b>
, <b>ISINF</b>
, <b>ISFINITE</b>
 }</td></tr>
<tr class="separator:a4ef624db40413dabc3fea554fc936d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4e0b21d1826723cc5ea81d889a73e5" id="r_a6c4e0b21d1826723cc5ea81d889a73e5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c4e0b21d1826723cc5ea81d889a73e5">SomeNumericType</a> { <br />
&#160;&#160;<b>I8</b>
, <b>U8</b>
, <b>I16</b>
, <b>U16</b>
, <br />
&#160;&#160;<b>I32</b>
, <b>U32</b>
, <b>I64</b>
, <b>U64</b>
, <br />
&#160;&#160;<b>F32</b>
, <b>F64</b>
<br />
 }</td></tr>
<tr class="separator:a6c4e0b21d1826723cc5ea81d889a73e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac5f5ff476ecb172e59c3535cedb966cd" id="r_ac5f5ff476ecb172e59c3535cedb966cd"><td class="memTemplParams" colspan="2">template&lt;typename StoredValue_ , typename InputValue_ , typename InputIndex_ &gt; </td></tr>
<tr class="memitem:ac5f5ff476ecb172e59c3535cedb966cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5f5ff476ecb172e59c3535cedb966cd">convert_to_dense</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, const bool row_major, StoredValue_ *const store, const <a class="el" href="structtatami_1_1ConvertToDenseOptions.html">ConvertToDenseOptions</a> &amp;options)</td></tr>
<tr class="separator:ac5f5ff476ecb172e59c3535cedb966cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512b86bd654884abaa4b42f0640b30e9" id="r_a512b86bd654884abaa4b42f0640b30e9"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename StoredValue_  = Value_, typename InputValue_ , typename InputIndex_ &gt; </td></tr>
<tr class="memitem:a512b86bd654884abaa4b42f0640b30e9"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a512b86bd654884abaa4b42f0640b30e9">convert_to_dense</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, const bool row_major, const <a class="el" href="structtatami_1_1ConvertToDenseOptions.html">ConvertToDenseOptions</a> &amp;options)</td></tr>
<tr class="separator:a512b86bd654884abaa4b42f0640b30e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559b03571aa5f2e9a3cef60723d9ff96" id="r_a559b03571aa5f2e9a3cef60723d9ff96"><td class="memTemplParams" colspan="2">template&lt;typename Input_ , typename Output_ &gt; </td></tr>
<tr class="memitem:a559b03571aa5f2e9a3cef60723d9ff96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a559b03571aa5f2e9a3cef60723d9ff96">transpose</a> (const Input_ *const input, const std::size_t nrow, const std::size_t ncol, const std::size_t input_stride, Output_ *const output, const std::size_t output_stride)</td></tr>
<tr class="separator:a559b03571aa5f2e9a3cef60723d9ff96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c8278aeb3a9f87ec780c8678489924" id="r_af7c8278aeb3a9f87ec780c8678489924"><td class="memTemplParams" colspan="2">template&lt;typename Input_ , typename Output_ &gt; </td></tr>
<tr class="memitem:af7c8278aeb3a9f87ec780c8678489924"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af7c8278aeb3a9f87ec780c8678489924">transpose</a> (const Input_ *const input, const std::size_t nrow, const std::size_t ncol, Output_ *const output)</td></tr>
<tr class="separator:af7c8278aeb3a9f87ec780c8678489924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c8b88eeaa5fcbb1e5d47d020eb98ea" id="r_ab4c8b88eeaa5fcbb1e5d47d020eb98ea"><td class="memTemplParams" colspan="2">template&lt;typename ValueOut_ , typename IndexOut_ , typename ValueIn_ , typename IndexIn_ &gt; </td></tr>
<tr class="memitem:ab4c8b88eeaa5fcbb1e5d47d020eb98ea"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; ValueOut_, IndexOut_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4c8b88eeaa5fcbb1e5d47d020eb98ea">make_DelayedCast</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; ValueIn_, IndexIn_ &gt; &gt; p)</td></tr>
<tr class="separator:ab4c8b88eeaa5fcbb1e5d47d020eb98ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb624f8a5bc844d3e902cde63b84001f" id="r_abb624f8a5bc844d3e902cde63b84001f"><td class="memTemplParams" colspan="2">template&lt;class Values_ , typename Pointer_  = I&lt;decltype(std::declval&lt;Values_&gt;().size())&gt;, class PrimaryIndices_ , class SecondaryIndices_ &gt; </td></tr>
<tr class="memitem:abb624f8a5bc844d3e902cde63b84001f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Pointer_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abb624f8a5bc844d3e902cde63b84001f">compress_sparse_triplets</a> (std::size_t num_primary, Values_ &amp;values, const PrimaryIndices_ &amp;primary_indices, SecondaryIndices_ &amp;secondary_indices)</td></tr>
<tr class="separator:abb624f8a5bc844d3e902cde63b84001f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305c49810ea7cad498399ad7c9dd0ee0" id="r_a305c49810ea7cad498399ad7c9dd0ee0"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Count_ &gt; </td></tr>
<tr class="memitem:a305c49810ea7cad498399ad7c9dd0ee0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a305c49810ea7cad498399ad7c9dd0ee0">count_compressed_sparse_non_zeros</a> (const <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const bool row, Count_ *const output, const <a class="el" href="structtatami_1_1CountCompressedSparseNonZerosOptions.html">CountCompressedSparseNonZerosOptions</a> &amp;options)</td></tr>
<tr class="separator:a305c49810ea7cad498399ad7c9dd0ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dd052eda49e8b530947753c24f1178" id="r_ac8dd052eda49e8b530947753c24f1178"><td class="memTemplParams" colspan="2">template&lt;typename InputValue_ , typename InputIndex_ , typename Pointer_ , typename StoredValue_ , typename StoredIndex_ &gt; </td></tr>
<tr class="memitem:ac8dd052eda49e8b530947753c24f1178"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac8dd052eda49e8b530947753c24f1178">fill_compressed_sparse_contents</a> (const <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, const bool row, const Pointer_ *const pointers, StoredValue_ *const output_value, StoredIndex_ *const output_index, const <a class="el" href="structtatami_1_1FillCompressedSparseContentsOptions.html">FillCompressedSparseContentsOptions</a> &amp;options)</td></tr>
<tr class="separator:ac8dd052eda49e8b530947753c24f1178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0ab534fd3195a57abcb47272d41ded" id="r_a7e0ab534fd3195a57abcb47272d41ded"><td class="memTemplParams" colspan="2">template&lt;typename StoredValue_ , typename StoredIndex_ , typename StoredPointer_  = std::size_t, typename InputValue_ , typename InputIndex_ &gt; </td></tr>
<tr class="memitem:a7e0ab534fd3195a57abcb47272d41ded"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1CompressedSparseContents.html">CompressedSparseContents</a>&lt; StoredValue_, StoredIndex_, StoredPointer_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7e0ab534fd3195a57abcb47272d41ded">retrieve_compressed_sparse_contents</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, const bool row, const <a class="el" href="structtatami_1_1RetrieveCompressedSparseContentsOptions.html">RetrieveCompressedSparseContentsOptions</a> &amp;options)</td></tr>
<tr class="separator:a7e0ab534fd3195a57abcb47272d41ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4758e123ce35dfe718a331a66ac0e16" id="r_ae4758e123ce35dfe718a331a66ac0e16"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename StoredValue_  = Value_, typename StoredIndex_  = Index_, typename StoredPointer_  = std::size_t, typename InputValue_ , typename InputIndex_ &gt; </td></tr>
<tr class="memitem:ae4758e123ce35dfe718a331a66ac0e16"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae4758e123ce35dfe718a331a66ac0e16">convert_to_compressed_sparse</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, const bool row, const <a class="el" href="structtatami_1_1ConvertToCompressedSparseOptions.html">ConvertToCompressedSparseOptions</a> &amp;options)</td></tr>
<tr class="separator:ae4758e123ce35dfe718a331a66ac0e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4feed54780ff0d6ec18a38a5752f22" id="r_a4b4feed54780ff0d6ec18a38a5752f22"><td class="memTemplParams" colspan="2">template&lt;typename StoredValue_ , typename StoredIndex_ , typename InputValue_ , typename InputIndex_ &gt; </td></tr>
<tr class="memitem:a4b4feed54780ff0d6ec18a38a5752f22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtatami_1_1FragmentedSparseContents.html">FragmentedSparseContents</a>&lt; StoredValue_, StoredIndex_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b4feed54780ff0d6ec18a38a5752f22">retrieve_fragmented_sparse_contents</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, const bool row, const <a class="el" href="structtatami_1_1RetrieveFragmentedSparseContentsOptions.html">RetrieveFragmentedSparseContentsOptions</a> &amp;options)</td></tr>
<tr class="separator:a4b4feed54780ff0d6ec18a38a5752f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac2470badcf668316367fdea9704035" id="r_acac2470badcf668316367fdea9704035"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename StoredValue_  = Value_, typename StoredIndex_  = Index_, typename InputValue_ , typename InputIndex_ &gt; </td></tr>
<tr class="memitem:acac2470badcf668316367fdea9704035"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acac2470badcf668316367fdea9704035">convert_to_fragmented_sparse</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;matrix, const bool row, const <a class="el" href="structtatami_1_1ConvertToFragmentedSparseOptions.html">ConvertToFragmentedSparseOptions</a> &amp;options)</td></tr>
<tr class="separator:acac2470badcf668316367fdea9704035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdae940708614108ad158f0c2590f8d" id="r_a4fdae940708614108ad158f0c2590f8d"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a4fdae940708614108ad158f0c2590f8d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4fdae940708614108ad158f0c2590f8d">make_DelayedSubsetBlock</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; matrix, const Index_ subset_start, const Index_ subset_length, bool by_row)</td></tr>
<tr class="separator:a4fdae940708614108ad158f0c2590f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62b9d27c0c501e5b65e52ce37f0ee5d" id="r_af62b9d27c0c501e5b65e52ce37f0ee5d"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , class SubsetStorage_ &gt; </td></tr>
<tr class="memitem:af62b9d27c0c501e5b65e52ce37f0ee5d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af62b9d27c0c501e5b65e52ce37f0ee5d">make_DelayedSubset</a> (std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; matrix, SubsetStorage_ subset, const bool by_row)</td></tr>
<tr class="separator:af62b9d27c0c501e5b65e52ce37f0ee5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cfcdf9fa34c6d0cd6b672472d407b3" id="r_ae5cfcdf9fa34c6d0cd6b672472d407b3"><td class="memTemplParams" colspan="2">template&lt;bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </td></tr>
<tr class="memitem:ae5cfcdf9fa34c6d0cd6b672472d407b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5cfcdf9fa34c6d0cd6b672472d407b3">consecutive_extractor</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const bool row, const Index_ iter_start, const Index_ iter_length, Args_ &amp;&amp;... args)</td></tr>
<tr class="separator:ae5cfcdf9fa34c6d0cd6b672472d407b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca84df9f6331751c29b0bcc0ca656af7" id="r_aca84df9f6331751c29b0bcc0ca656af7"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Size_ &gt; </td></tr>
<tr class="memitem:aca84df9f6331751c29b0bcc0ca656af7"><td class="memTemplItemLeft" align="right" valign="top">Value_ *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca84df9f6331751c29b0bcc0ca656af7">copy_n</a> (const Value_ *const input, const Size_ n, Value_ *const output)</td></tr>
<tr class="separator:aca84df9f6331751c29b0bcc0ca656af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d15fa0c5213ad27fc0c99c3dd5c02ad" id="r_a4d15fa0c5213ad27fc0c99c3dd5c02ad"><td class="memTemplParams" colspan="2">template&lt;typename Container_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a4d15fa0c5213ad27fc0c99c3dd5c02ad"><td class="memTemplItemLeft" align="right" valign="top">Index_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4d15fa0c5213ad27fc0c99c3dd5c02ad">can_cast_Index_to_container_size</a> (const Index_ x)</td></tr>
<tr class="separator:a4d15fa0c5213ad27fc0c99c3dd5c02ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d0f6694ab914f57229b925641779d4" id="r_ac6d0f6694ab914f57229b925641779d4"><td class="memTemplParams" colspan="2">template&lt;typename Container_ , typename Index_ &gt; </td></tr>
<tr class="memitem:ac6d0f6694ab914f57229b925641779d4"><td class="memTemplItemLeft" align="right" valign="top">I&lt; decltype(std::declval&lt; Container_ &gt;().size())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6d0f6694ab914f57229b925641779d4">cast_Index_to_container_size</a> (const Index_ x)</td></tr>
<tr class="separator:ac6d0f6694ab914f57229b925641779d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada885a7e7ae9dcafcaf98cde30622afc" id="r_ada885a7e7ae9dcafcaf98cde30622afc"><td class="memTemplParams" colspan="2">template&lt;typename Container_ , typename Index_ , typename ... Args_&gt; </td></tr>
<tr class="memitem:ada885a7e7ae9dcafcaf98cde30622afc"><td class="memTemplItemLeft" align="right" valign="top">Container_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada885a7e7ae9dcafcaf98cde30622afc">create_container_of_Index_size</a> (const Index_ x, Args_ &amp;&amp;... args)</td></tr>
<tr class="separator:ada885a7e7ae9dcafcaf98cde30622afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b43d2b751c7fcca6815f3be929d4d3" id="r_a61b43d2b751c7fcca6815f3be929d4d3"><td class="memTemplParams" colspan="2">template&lt;typename Container_ , typename Index_ , typename ... Args_&gt; </td></tr>
<tr class="memitem:a61b43d2b751c7fcca6815f3be929d4d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a61b43d2b751c7fcca6815f3be929d4d3">resize_container_to_Index_size</a> (Container_ &amp;container, const Index_ x, Args_ &amp;&amp;... args)</td></tr>
<tr class="separator:a61b43d2b751c7fcca6815f3be929d4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a638ee666d4ded2e1cb68c39bc14b32" id="r_a0a638ee666d4ded2e1cb68c39bc14b32"><td class="memTemplParams" colspan="2">template&lt;bool sparse_, bool oracle_, typename Value_ , typename Index_ , typename ... Args_&gt; </td></tr>
<tr class="memitem:a0a638ee666d4ded2e1cb68c39bc14b32"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a638ee666d4ded2e1cb68c39bc14b32">new_extractor</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const bool row, <a class="el" href="#a812af1bfb04773bf28da8549c3e6e5ee">MaybeOracle</a>&lt; oracle_, Index_ &gt; oracle, Args_ &amp;&amp;... args)</td></tr>
<tr class="separator:a0a638ee666d4ded2e1cb68c39bc14b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea65e5b93eb55c03b00aca301e0396f" id="r_a3ea65e5b93eb55c03b00aca301e0396f"><td class="memTemplParams" colspan="2">template&lt;bool parallel_ = true, class Function_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a3ea65e5b93eb55c03b00aca301e0396f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ea65e5b93eb55c03b00aca301e0396f">parallelize</a> (Function_ fun, const Index_ tasks, const int threads)</td></tr>
<tr class="separator:a3ea65e5b93eb55c03b00aca301e0396f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc238346c521152c4273e3552240d7f7" id="r_adc238346c521152c4273e3552240d7f7"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , class Function_ &gt; </td></tr>
<tr class="memitem:adc238346c521152c4273e3552240d7f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc238346c521152c4273e3552240d7f7">process_consecutive_indices</a> (const Index_ *const indices, const Index_ length, const Function_ fun)</td></tr>
<tr class="separator:adc238346c521152c4273e3552240d7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a07f7937bfdbbe8e355cba20d7c0c3a" id="r_a5a07f7937bfdbbe8e355cba20d7c0c3a"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a5a07f7937bfdbbe8e355cba20d7c0c3a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a07f7937bfdbbe8e355cba20d7c0c3a">wrap_shared_ptr</a> (const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *const ptr)</td></tr>
<tr class="separator:a5a07f7937bfdbbe8e355cba20d7c0c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Flexible representations for matrix data. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a92f2deb44e0a3cb1c569a379c6facbf0" name="a92f2deb44e0a3cb1c569a379c6facbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f2deb44e0a3cb1c569a379c6facbf0">&#9670;&#160;</a></span>DenseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool oracle_, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a92f2deb44e0a3cb1c569a379c6facbf0">tatami::DenseExtractor</a> = typename std::conditional&lt;oracle_, <a class="el" href="classtatami_1_1OracularDenseExtractor.html">OracularDenseExtractor</a>&lt;Value_, Index_&gt;, <a class="el" href="classtatami_1_1MyopicDenseExtractor.html">MyopicDenseExtractor</a>&lt;Value_, Index_&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oracle_</td><td>Whether to use an oracle-aware interface. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Type alias that switches between <code><a class="el" href="classtatami_1_1OracularDenseExtractor.html" title="Extract an element of the target dimension in dense form with an oracle.">OracularDenseExtractor</a></code> and <code><a class="el" href="classtatami_1_1MyopicDenseExtractor.html" title="Extract an element of the target dimension in dense form without an oracle.">MyopicDenseExtractor</a></code> depending on <code>oracle_</code>. Intended for templated class definitions, where setting <code>oracle_</code> can define subclasses for both interfaces. </p>

</div>
</div>
<a id="a213ab58ba31e5b5cee3b66ab54d86055" name="a213ab58ba31e5b5cee3b66ab54d86055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213ab58ba31e5b5cee3b66ab54d86055">&#9670;&#160;</a></span>SparseExtractor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool oracle_, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a213ab58ba31e5b5cee3b66ab54d86055">tatami::SparseExtractor</a> = typename std::conditional&lt;oracle_, <a class="el" href="classtatami_1_1OracularSparseExtractor.html">OracularSparseExtractor</a>&lt;Value_, Index_&gt;, <a class="el" href="classtatami_1_1MyopicSparseExtractor.html">MyopicSparseExtractor</a>&lt;Value_, Index_&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oracle_</td><td>Whether to use an oracle-aware interface. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Type alias that switches between <code><a class="el" href="classtatami_1_1OracularSparseExtractor.html" title="Extract an element of the target dimension in sparse form with an oracle.">OracularSparseExtractor</a></code> and <code><a class="el" href="classtatami_1_1MyopicSparseExtractor.html" title="Extract an element of the target dimension in sparse form without an oracle.">MyopicSparseExtractor</a></code> depending on <code>oracle_</code>. Intended for templated class definitions, where setting <code>oracle_</code> can define subclasses for both interfaces. </p>

</div>
</div>
<a id="a1a9c70ebcfa94bba3fea89202868f22f" name="a1a9c70ebcfa94bba3fea89202868f22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9c70ebcfa94bba3fea89202868f22f">&#9670;&#160;</a></span>VectorPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1a9c70ebcfa94bba3fea89202868f22f">tatami::VectorPtr</a> = std::shared_ptr&lt;const std::vector&lt;Index_&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Pointer to a vector, typically containing unique and sorted indices. We use a shared pointer so that we can cheaply re-use the same sequence of indices for multiple <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> objects. </p>

</div>
</div>
<a id="ae0438743ada096f37f307404851849ff" name="ae0438743ada096f37f307404851849ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0438743ada096f37f307404851849ff">&#9670;&#160;</a></span>NumericMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae0438743ada096f37f307404851849ff">tatami::NumericMatrix</a> = <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt;double, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenient shorthand for the most common use case of double-precision matrices. </p>

</div>
</div>
<a id="acdedcc902be98f3bd38f3507b906971c" name="acdedcc902be98f3bd38f3507b906971c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdedcc902be98f3bd38f3507b906971c">&#9670;&#160;</a></span>PredictionIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="#acdedcc902be98f3bd38f3507b906971c">tatami::PredictionIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unsigned integer type for the prediction index. This is used to obtain the <code>i</code>-th prediction from the <code><a class="el" href="classtatami_1_1Oracle.html" title="Predict future access requests on the target dimension.">Oracle</a></code>. </p>

</div>
</div>
<a id="a57425b6548448b71576c04f16f4dc38d" name="a57425b6548448b71576c04f16f4dc38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57425b6548448b71576c04f16f4dc38d">&#9670;&#160;</a></span>DelayedBinaryIsometricAddHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a57425b6548448b71576c04f16f4dc38d">tatami::DelayedBinaryIsometricAddHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::ADD, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the addition helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the addition. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the addition. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ea7ab7eb80b65e7bc275ae6974dbe91" name="a0ea7ab7eb80b65e7bc275ae6974dbe91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea7ab7eb80b65e7bc275ae6974dbe91">&#9670;&#160;</a></span>DelayedBinaryIsometricSubtractHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0ea7ab7eb80b65e7bc275ae6974dbe91">tatami::DelayedBinaryIsometricSubtractHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::SUBTRACT, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the subtraction helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the subtraction. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the subtraction. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cae360a45009c024535d56ba44df5e9" name="a5cae360a45009c024535d56ba44df5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cae360a45009c024535d56ba44df5e9">&#9670;&#160;</a></span>DelayedBinaryIsometricMultiplyHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5cae360a45009c024535d56ba44df5e9">tatami::DelayedBinaryIsometricMultiplyHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::MULTIPLY, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the multiplication helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the multiplication. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the multiplication. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cc6e39d79401f8c36df9275c5516987" name="a7cc6e39d79401f8c36df9275c5516987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc6e39d79401f8c36df9275c5516987">&#9670;&#160;</a></span>DelayedBinaryIsometricDivideHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7cc6e39d79401f8c36df9275c5516987">tatami::DelayedBinaryIsometricDivideHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::DIVIDE, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the division helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the division. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the division. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5bc59578440745268c68b309dd9148b" name="af5bc59578440745268c68b309dd9148b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bc59578440745268c68b309dd9148b">&#9670;&#160;</a></span>DelayedBinaryIsometricPowerHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af5bc59578440745268c68b309dd9148b">tatami::DelayedBinaryIsometricPowerHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::POWER, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the power operation helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the power operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the power operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aec21138d1d3fcd94d58c3c97bc2306" name="a8aec21138d1d3fcd94d58c3c97bc2306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aec21138d1d3fcd94d58c3c97bc2306">&#9670;&#160;</a></span>DelayedBinaryIsometricModuloHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8aec21138d1d3fcd94d58c3c97bc2306">tatami::DelayedBinaryIsometricModuloHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::MODULO, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the modulo operation helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the modulo operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the modulo operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a739a793b946dc62804ae15b550006ecf" name="a739a793b946dc62804ae15b550006ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739a793b946dc62804ae15b550006ecf">&#9670;&#160;</a></span>DelayedBinaryIsometricIntegerDivideHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_  = double, typename InputValue_  = double, typename Index_  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a739a793b946dc62804ae15b550006ecf">tatami::DelayedBinaryIsometricIntegerDivideHelper</a> = <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html">DelayedBinaryIsometricArithmeticHelper</a>&lt;ArithmeticOperation::INTEGER_DIVIDE, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the integer division helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the integer division. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the integer division. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a273c375113ac8a41d70dcb96b34a8f70" name="a273c375113ac8a41d70dcb96b34a8f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273c375113ac8a41d70dcb96b34a8f70">&#9670;&#160;</a></span>DelayedBinaryIsometricBooleanEqualHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a273c375113ac8a41d70dcb96b34a8f70">tatami::DelayedBinaryIsometricBooleanEqualHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html">DelayedBinaryIsometricBooleanHelper</a>&lt;BooleanOperation::EQUAL, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the boolean equality helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the boolean operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the boolean operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb2bedfee72494dd676f535b6e646944" name="abb2bedfee72494dd676f535b6e646944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2bedfee72494dd676f535b6e646944">&#9670;&#160;</a></span>DelayedBinaryIsometricBooleanAndHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abb2bedfee72494dd676f535b6e646944">tatami::DelayedBinaryIsometricBooleanAndHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html">DelayedBinaryIsometricBooleanHelper</a>&lt;BooleanOperation::AND, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the boolean AND helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the boolean operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the boolean operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcffb4b3b4ca704f3c70ca1982b94b5b" name="afcffb4b3b4ca704f3c70ca1982b94b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcffb4b3b4ca704f3c70ca1982b94b5b">&#9670;&#160;</a></span>DelayedBinaryIsometricBooleanOrHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afcffb4b3b4ca704f3c70ca1982b94b5b">tatami::DelayedBinaryIsometricBooleanOrHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html">DelayedBinaryIsometricBooleanHelper</a>&lt;BooleanOperation::OR, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the boolean OR helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the boolean operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the boolean operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6065e08151681689b5023badb803f100" name="a6065e08151681689b5023badb803f100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6065e08151681689b5023badb803f100">&#9670;&#160;</a></span>DelayedBinaryIsometricBooleanXorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6065e08151681689b5023badb803f100">tatami::DelayedBinaryIsometricBooleanXorHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html">DelayedBinaryIsometricBooleanHelper</a>&lt;BooleanOperation::XOR, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the boolean XOR helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the boolean operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the boolean operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8301bb5bced53cf6f9fc880724621536" name="a8301bb5bced53cf6f9fc880724621536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8301bb5bced53cf6f9fc880724621536">&#9670;&#160;</a></span>DelayedBinaryIsometricEqualHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8301bb5bced53cf6f9fc880724621536">tatami::DelayedBinaryIsometricEqualHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a>&lt;CompareOperation::EQUAL, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the equality comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a575089ae32a21531432a27594a04ccd7" name="a575089ae32a21531432a27594a04ccd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575089ae32a21531432a27594a04ccd7">&#9670;&#160;</a></span>DelayedBinaryIsometricGreaterThanHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a575089ae32a21531432a27594a04ccd7">tatami::DelayedBinaryIsometricGreaterThanHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a>&lt;CompareOperation::GREATER_THAN, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the "greater than" comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae03a1f8ae5f3b551ff6b613c6b99d178" name="ae03a1f8ae5f3b551ff6b613c6b99d178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03a1f8ae5f3b551ff6b613c6b99d178">&#9670;&#160;</a></span>DelayedBinaryIsometricLessThanHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae03a1f8ae5f3b551ff6b613c6b99d178">tatami::DelayedBinaryIsometricLessThanHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a>&lt;CompareOperation::LESS_THAN, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the "less than" comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7b7253051f5faf636fc2ebde7d495ea" name="aa7b7253051f5faf636fc2ebde7d495ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b7253051f5faf636fc2ebde7d495ea">&#9670;&#160;</a></span>DelayedBinaryIsometricGreaterThanOrEqualHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa7b7253051f5faf636fc2ebde7d495ea">tatami::DelayedBinaryIsometricGreaterThanOrEqualHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a>&lt;CompareOperation::GREATER_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the "greater than or equal" comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dc2cbf8430b064492cba8bdbe7c89aa" name="a8dc2cbf8430b064492cba8bdbe7c89aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc2cbf8430b064492cba8bdbe7c89aa">&#9670;&#160;</a></span>DelayedBinaryIsometricLessThanOrEqualHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8dc2cbf8430b064492cba8bdbe7c89aa">tatami::DelayedBinaryIsometricLessThanOrEqualHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a>&lt;CompareOperation::LESS_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the "less than or equal" comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83d6ad9e461ce20731c532061e09e617" name="a83d6ad9e461ce20731c532061e09e617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d6ad9e461ce20731c532061e09e617">&#9670;&#160;</a></span>DelayedBinaryIsometricNotEqualHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a83d6ad9e461ce20731c532061e09e617">tatami::DelayedBinaryIsometricNotEqualHelper</a> = <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html">DelayedBinaryIsometricCompareHelper</a>&lt;CompareOperation::NOT_EQUAL, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the non-equality comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2292212afeb290e4dff7f36aa054fb9" name="af2292212afeb290e4dff7f36aa054fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2292212afeb290e4dff7f36aa054fb9">&#9670;&#160;</a></span>DelayedUnaryIsometricAddScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af2292212afeb290e4dff7f36aa054fb9">tatami::DelayedUnaryIsometricAddScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::ADD, true, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar addition helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the addition. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the addition. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4809abe02f2d2f90ee7404f42b7b777" name="af4809abe02f2d2f90ee7404f42b7b777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4809abe02f2d2f90ee7404f42b7b777">&#9670;&#160;</a></span>DelayedUnaryIsometricSubtractScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af4809abe02f2d2f90ee7404f42b7b777">tatami::DelayedUnaryIsometricSubtractScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::SUBTRACT, right_, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar subtraction helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the subtraction. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the subtraction. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab49c318a02237b845b6aaea33b894242" name="ab49c318a02237b845b6aaea33b894242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49c318a02237b845b6aaea33b894242">&#9670;&#160;</a></span>DelayedUnaryIsometricMultiplyScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab49c318a02237b845b6aaea33b894242">tatami::DelayedUnaryIsometricMultiplyScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::MULTIPLY, true, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar multiplication helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the multiplication. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the multiplication. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab56ef7076f6972dc24e450811a624906" name="ab56ef7076f6972dc24e450811a624906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56ef7076f6972dc24e450811a624906">&#9670;&#160;</a></span>DelayedUnaryIsometricDivideScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab56ef7076f6972dc24e450811a624906">tatami::DelayedUnaryIsometricDivideScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::DIVIDE, right_, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar division helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the division. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the division. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a464a72a2ccd0355d064c2778afbe732b" name="a464a72a2ccd0355d064c2778afbe732b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464a72a2ccd0355d064c2778afbe732b">&#9670;&#160;</a></span>DelayedUnaryIsometricPowerScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a464a72a2ccd0355d064c2778afbe732b">tatami::DelayedUnaryIsometricPowerScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::POWER, right_, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar power helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the power operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the power operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15002f7fff6e73aa829f87b9f4fad7b7" name="a15002f7fff6e73aa829f87b9f4fad7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15002f7fff6e73aa829f87b9f4fad7b7">&#9670;&#160;</a></span>DelayedUnaryIsometricModuloScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a15002f7fff6e73aa829f87b9f4fad7b7">tatami::DelayedUnaryIsometricModuloScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::MODULO, right_, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar modulo helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the modulo operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the modulo operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadb6226285e0eafc99868c686d2ff6bf" name="aadb6226285e0eafc99868c686d2ff6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb6226285e0eafc99868c686d2ff6bf">&#9670;&#160;</a></span>DelayedUnaryIsometricIntegerDivideScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aadb6226285e0eafc99868c686d2ff6bf">tatami::DelayedUnaryIsometricIntegerDivideScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticScalarHelper.html">DelayedUnaryIsometricArithmeticScalarHelper</a>&lt;ArithmeticOperation::INTEGER_DIVIDE, right_, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar modulo helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the scalar should be on the right hand side. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the modulo operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the modulo operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecdb1b3448ed9bcb6dc7328f96c0e0a5" name="aecdb1b3448ed9bcb6dc7328f96c0e0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdb1b3448ed9bcb6dc7328f96c0e0a5">&#9670;&#160;</a></span>DelayedUnaryIsometricAddVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aecdb1b3448ed9bcb6dc7328f96c0e0a5">tatami::DelayedUnaryIsometricAddVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::ADD, true, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector addition helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the addition. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the addition. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78329812c3ab5ada1be83f590a96c18a" name="a78329812c3ab5ada1be83f590a96c18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78329812c3ab5ada1be83f590a96c18a">&#9670;&#160;</a></span>DelayedUnaryIsometricSubtractVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a78329812c3ab5ada1be83f590a96c18a">tatami::DelayedUnaryIsometricSubtractVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::SUBTRACT, right_, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector subtraction helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the vector should be on the right hand side. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the subtraction. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the subtraction. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of index. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51e2b0461234d6bf0c9240a8a2777b8a" name="a51e2b0461234d6bf0c9240a8a2777b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e2b0461234d6bf0c9240a8a2777b8a">&#9670;&#160;</a></span>DelayedUnaryIsometricMultiplyVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a51e2b0461234d6bf0c9240a8a2777b8a">tatami::DelayedUnaryIsometricMultiplyVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::MULTIPLY, true, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector multiplication helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the multiplication. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the multiplication. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dbcd076270f137cbfff8f5af613ba49" name="a9dbcd076270f137cbfff8f5af613ba49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbcd076270f137cbfff8f5af613ba49">&#9670;&#160;</a></span>DelayedUnaryIsometricDivideVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9dbcd076270f137cbfff8f5af613ba49">tatami::DelayedUnaryIsometricDivideVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::DIVIDE, right_, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector division helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the vector should be on the right hand side. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the division. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the division. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ba14f9ea3d6c7b8fb98b34d54aafb59" name="a7ba14f9ea3d6c7b8fb98b34d54aafb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba14f9ea3d6c7b8fb98b34d54aafb59">&#9670;&#160;</a></span>DelayedUnaryIsometricPowerVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7ba14f9ea3d6c7b8fb98b34d54aafb59">tatami::DelayedUnaryIsometricPowerVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::POWER, right_, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector power helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the vector should be on the right hand side. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the power operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the power operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaf1c8702a170bf686bda7f50a1d55f8" name="afaf1c8702a170bf686bda7f50a1d55f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf1c8702a170bf686bda7f50a1d55f8">&#9670;&#160;</a></span>DelayedUnaryIsometricModuloVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afaf1c8702a170bf686bda7f50a1d55f8">tatami::DelayedUnaryIsometricModuloVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::MODULO, right_, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector modulo helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the vector should be on the right hand side. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the modulo operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the modulo operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c4ac3cd66fe866bb94e7692f717ce51" name="a4c4ac3cd66fe866bb94e7692f717ce51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4ac3cd66fe866bb94e7692f717ce51">&#9670;&#160;</a></span>DelayedUnaryIsometricIntegerDivideVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool right_, typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4c4ac3cd66fe866bb94e7692f717ce51">tatami::DelayedUnaryIsometricIntegerDivideVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricArithmeticVectorHelper.html">DelayedUnaryIsometricArithmeticVectorHelper</a>&lt;ArithmeticOperation::INTEGER_DIVIDE, right_, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector modulo helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">right_</td><td>Whether the vector should be on the right hand side. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the modulo operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the modulo operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61040dd1b833692e48a53a79015a26d8" name="a61040dd1b833692e48a53a79015a26d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61040dd1b833692e48a53a79015a26d8">&#9670;&#160;</a></span>DelayedUnaryIsometricBooleanEqualScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a61040dd1b833692e48a53a79015a26d8">tatami::DelayedUnaryIsometricBooleanEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalarHelper.html">DelayedUnaryIsometricBooleanScalarHelper</a>&lt;BooleanOperation::EQUAL, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the boolean equality scalar helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the boolean operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the boolean operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80d8f7239498a6631bc728518d2c4d60" name="a80d8f7239498a6631bc728518d2c4d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d8f7239498a6631bc728518d2c4d60">&#9670;&#160;</a></span>DelayedUnaryIsometricBooleanAndScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a80d8f7239498a6631bc728518d2c4d60">tatami::DelayedUnaryIsometricBooleanAndScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalarHelper.html">DelayedUnaryIsometricBooleanScalarHelper</a>&lt;BooleanOperation::AND, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the boolean AND scalar helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the boolean operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the boolean operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace6a6321e96323e7cc3ee2c6bbe7de53" name="ace6a6321e96323e7cc3ee2c6bbe7de53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6a6321e96323e7cc3ee2c6bbe7de53">&#9670;&#160;</a></span>DelayedUnaryIsometricBooleanOrScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ace6a6321e96323e7cc3ee2c6bbe7de53">tatami::DelayedUnaryIsometricBooleanOrScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalarHelper.html">DelayedUnaryIsometricBooleanScalarHelper</a>&lt;BooleanOperation::OR, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the boolean OR scalar helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the boolean operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the boolean operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2803fa1c9ae921fcf7901b7e16723217" name="a2803fa1c9ae921fcf7901b7e16723217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2803fa1c9ae921fcf7901b7e16723217">&#9670;&#160;</a></span>DelayedUnaryIsometricBooleanXorScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2803fa1c9ae921fcf7901b7e16723217">tatami::DelayedUnaryIsometricBooleanXorScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanScalarHelper.html">DelayedUnaryIsometricBooleanScalarHelper</a>&lt;BooleanOperation::XOR, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the boolean XOR scalar helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the boolean operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the boolean operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d2da6aa028f9f9b761ad014d3d6e8af" name="a2d2da6aa028f9f9b761ad014d3d6e8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2da6aa028f9f9b761ad014d3d6e8af">&#9670;&#160;</a></span>DelayedUnaryIsometricBooleanEqualVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2d2da6aa028f9f9b761ad014d3d6e8af">tatami::DelayedUnaryIsometricBooleanEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVectorHelper.html">DelayedUnaryIsometricBooleanVectorHelper</a>&lt;BooleanOperation::EQUAL, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the boolean equality vector helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the boolean operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the boolean operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82f179809ea91935f94c319ecf687138" name="a82f179809ea91935f94c319ecf687138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f179809ea91935f94c319ecf687138">&#9670;&#160;</a></span>DelayedUnaryIsometricBooleanAndVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a82f179809ea91935f94c319ecf687138">tatami::DelayedUnaryIsometricBooleanAndVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVectorHelper.html">DelayedUnaryIsometricBooleanVectorHelper</a>&lt;BooleanOperation::AND, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the boolean AND vector helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the boolean operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the boolean operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00469f0584ca17dc3e6292f4aad4ef50" name="a00469f0584ca17dc3e6292f4aad4ef50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00469f0584ca17dc3e6292f4aad4ef50">&#9670;&#160;</a></span>DelayedUnaryIsometricBooleanOrVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a00469f0584ca17dc3e6292f4aad4ef50">tatami::DelayedUnaryIsometricBooleanOrVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVectorHelper.html">DelayedUnaryIsometricBooleanVectorHelper</a>&lt;BooleanOperation::OR, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the boolean OR vector helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the boolean operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the boolean operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8497a6e6a96766aa03d0f3de4f502726" name="a8497a6e6a96766aa03d0f3de4f502726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8497a6e6a96766aa03d0f3de4f502726">&#9670;&#160;</a></span>DelayedUnaryIsometricBooleanXorVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8497a6e6a96766aa03d0f3de4f502726">tatami::DelayedUnaryIsometricBooleanXorVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricBooleanVectorHelper.html">DelayedUnaryIsometricBooleanVectorHelper</a>&lt;BooleanOperation::XOR, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the boolean XOR vector helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the boolean operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the boolean operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dc54c092d0ed88020a588e968b6aa87" name="a5dc54c092d0ed88020a588e968b6aa87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc54c092d0ed88020a588e968b6aa87">&#9670;&#160;</a></span>DelayedUnaryIsometricEqualScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5dc54c092d0ed88020a588e968b6aa87">tatami::DelayedUnaryIsometricEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a>&lt;CompareOperation::EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar equality comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af60ad4ee3808aae10ddd24031ad6f781" name="af60ad4ee3808aae10ddd24031ad6f781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60ad4ee3808aae10ddd24031ad6f781">&#9670;&#160;</a></span>DelayedUnaryIsometricGreaterThanScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af60ad4ee3808aae10ddd24031ad6f781">tatami::DelayedUnaryIsometricGreaterThanScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a>&lt;CompareOperation::GREATER_THAN, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar "greater than" comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b19844aaf36539c53436d80ea83c0d6" name="a8b19844aaf36539c53436d80ea83c0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b19844aaf36539c53436d80ea83c0d6">&#9670;&#160;</a></span>DelayedUnaryIsometricLessThanScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8b19844aaf36539c53436d80ea83c0d6">tatami::DelayedUnaryIsometricLessThanScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a>&lt;CompareOperation::LESS_THAN, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar "less than" comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c5c19886f4873a8cd84f0cb250c7923" name="a8c5c19886f4873a8cd84f0cb250c7923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5c19886f4873a8cd84f0cb250c7923">&#9670;&#160;</a></span>DelayedUnaryIsometricGreaterThanOrEqualScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8c5c19886f4873a8cd84f0cb250c7923">tatami::DelayedUnaryIsometricGreaterThanOrEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a>&lt;CompareOperation::GREATER_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar "greater than or equal" comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf8e15999b164083daf19f4b9405f38f" name="abf8e15999b164083daf19f4b9405f38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8e15999b164083daf19f4b9405f38f">&#9670;&#160;</a></span>DelayedUnaryIsometricLessThanOrEqualScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abf8e15999b164083daf19f4b9405f38f">tatami::DelayedUnaryIsometricLessThanOrEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a>&lt;CompareOperation::LESS_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar "less than or equal" comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c56245791d6fc70a5b70d4a67cda390" name="a9c56245791d6fc70a5b70d4a67cda390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c56245791d6fc70a5b70d4a67cda390">&#9670;&#160;</a></span>DelayedUnaryIsometricNotEqualScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9c56245791d6fc70a5b70d4a67cda390">tatami::DelayedUnaryIsometricNotEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareScalarHelper.html">DelayedUnaryIsometricCompareScalarHelper</a>&lt;CompareOperation::NOT_EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar non-equality comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28256a85f8fb04234807b89672a4902e" name="a28256a85f8fb04234807b89672a4902e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28256a85f8fb04234807b89672a4902e">&#9670;&#160;</a></span>DelayedUnaryIsometricEqualVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a28256a85f8fb04234807b89672a4902e">tatami::DelayedUnaryIsometricEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a>&lt;CompareOperation::EQUAL, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector equality comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57a3bdf1378f20d210367c69c0c60462" name="a57a3bdf1378f20d210367c69c0c60462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a3bdf1378f20d210367c69c0c60462">&#9670;&#160;</a></span>DelayedUnaryIsometricGreaterThanVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a57a3bdf1378f20d210367c69c0c60462">tatami::DelayedUnaryIsometricGreaterThanVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a>&lt;CompareOperation::GREATER_THAN, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector "greater than" comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4cd0eaa035a836cad4ef992ad11d3f1" name="af4cd0eaa035a836cad4ef992ad11d3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cd0eaa035a836cad4ef992ad11d3f1">&#9670;&#160;</a></span>DelayedUnaryIsometricLessThanVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af4cd0eaa035a836cad4ef992ad11d3f1">tatami::DelayedUnaryIsometricLessThanVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a>&lt;CompareOperation::LESS_THAN, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector "less than" comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea3e5df8ef9e30e0bb33157a54dbb017" name="aea3e5df8ef9e30e0bb33157a54dbb017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3e5df8ef9e30e0bb33157a54dbb017">&#9670;&#160;</a></span>DelayedUnaryIsometricGreaterThanOrEqualVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aea3e5df8ef9e30e0bb33157a54dbb017">tatami::DelayedUnaryIsometricGreaterThanOrEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a>&lt;CompareOperation::GREATER_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector "greater than or equal" comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6bc075ad032f1fae7a55bcb0c838d28" name="ad6bc075ad032f1fae7a55bcb0c838d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bc075ad032f1fae7a55bcb0c838d28">&#9670;&#160;</a></span>DelayedUnaryIsometricLessThanOrEqualVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad6bc075ad032f1fae7a55bcb0c838d28">tatami::DelayedUnaryIsometricLessThanOrEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a>&lt;CompareOperation::LESS_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector "less than or equal" comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e91a967f132fa20cea6838ad7a18ecc" name="a4e91a967f132fa20cea6838ad7a18ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e91a967f132fa20cea6838ad7a18ecc">&#9670;&#160;</a></span>DelayedUnaryIsometricNotEqualVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Vector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4e91a967f132fa20cea6838ad7a18ecc">tatami::DelayedUnaryIsometricNotEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricCompareVectorHelper.html">DelayedUnaryIsometricCompareVectorHelper</a>&lt;CompareOperation::NOT_EQUAL, OutputValue_, InputValue_, Index_, Vector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the vector non-equality comparison helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Vector_</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af819a1749116a16befe9c6941683acab" name="af819a1749116a16befe9c6941683acab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af819a1749116a16befe9c6941683acab">&#9670;&#160;</a></span>DelayedUnaryIsometricIsnanHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool pass_, typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af819a1749116a16befe9c6941683acab">tatami::DelayedUnaryIsometricIsnanHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompareHelper.html">DelayedUnaryIsometricSpecialCompareHelper</a>&lt;SpecialCompareOperation::ISNAN, pass_, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the "comparison to NaN" helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pass_</td><td>Whether to return true if the input value is NaN. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aada7b7f5b035cc60a27600ac893bda98" name="aada7b7f5b035cc60a27600ac893bda98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada7b7f5b035cc60a27600ac893bda98">&#9670;&#160;</a></span>DelayedUnaryIsometricIsinfHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool pass_, typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aada7b7f5b035cc60a27600ac893bda98">tatami::DelayedUnaryIsometricIsinfHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompareHelper.html">DelayedUnaryIsometricSpecialCompareHelper</a>&lt;SpecialCompareOperation::ISINF, pass_, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the "comparison to infinity" helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pass_</td><td>Whether to return true if the input value is infinite. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16e742490eb4b0300c915d47fd98e398" name="a16e742490eb4b0300c915d47fd98e398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e742490eb4b0300c915d47fd98e398">&#9670;&#160;</a></span>DelayedUnaryIsometricIsfiniteHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool pass_, typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a16e742490eb4b0300c915d47fd98e398">tatami::DelayedUnaryIsometricIsfiniteHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialCompareHelper.html">DelayedUnaryIsometricSpecialCompareHelper</a>&lt;SpecialCompareOperation::ISFINITE, pass_, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the "is finite" helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pass_</td><td>Whether to return true if the input value is finite. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98a5e88bdd28d9bda030d8bf20ce0d2e" name="a98a5e88bdd28d9bda030d8bf20ce0d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a5e88bdd28d9bda030d8bf20ce0d2e">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteEqualScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a98a5e88bdd28d9bda030d8bf20ce0d2e">tatami::DelayedUnaryIsometricSubstituteEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a>&lt;CompareOperation::EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar equality substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the substitution. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the substitution. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad240d87978cdf3d57b65c9f25f4c7700" name="ad240d87978cdf3d57b65c9f25f4c7700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad240d87978cdf3d57b65c9f25f4c7700">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteGreaterThanScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad240d87978cdf3d57b65c9f25f4c7700">tatami::DelayedUnaryIsometricSubstituteGreaterThanScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a>&lt;CompareOperation::GREATER_THAN, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar "greater than" substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the substitution. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the substitution. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67195ce7793682b9698dfdbba0ae0396" name="a67195ce7793682b9698dfdbba0ae0396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67195ce7793682b9698dfdbba0ae0396">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteLessThanScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a67195ce7793682b9698dfdbba0ae0396">tatami::DelayedUnaryIsometricSubstituteLessThanScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a>&lt;CompareOperation::LESS_THAN, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar "less than" substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the substitution. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the substitution. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4079ceca160d5eeca88e1c015b741691" name="a4079ceca160d5eeca88e1c015b741691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4079ceca160d5eeca88e1c015b741691">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteGreaterThanOrEqualScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4079ceca160d5eeca88e1c015b741691">tatami::DelayedUnaryIsometricSubstituteGreaterThanOrEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a>&lt;CompareOperation::GREATER_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar "greater than or equal" substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the substitution. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the substitution. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbe06f2445eea2bac346285bac40ba81" name="adbe06f2445eea2bac346285bac40ba81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe06f2445eea2bac346285bac40ba81">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteLessThanOrEqualScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#adbe06f2445eea2bac346285bac40ba81">tatami::DelayedUnaryIsometricSubstituteLessThanOrEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a>&lt;CompareOperation::LESS_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar "less than or equal" substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the substitution. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the substitution. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad14b2d50ec74c5c326298f55dd2e20f5" name="ad14b2d50ec74c5c326298f55dd2e20f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14b2d50ec74c5c326298f55dd2e20f5">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteNotEqualScalarHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename Scalar_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad14b2d50ec74c5c326298f55dd2e20f5">tatami::DelayedUnaryIsometricSubstituteNotEqualScalarHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteScalarHelper.html">DelayedUnaryIsometricSubstituteScalarHelper</a>&lt;CompareOperation::NOT_EQUAL, OutputValue_, InputValue_, Index_, Scalar_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar non-equality substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the substitution. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the substitution. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Scalar_</td><td>Type of the scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac43c2a731fa3de6cd038a6965f81577b" name="ac43c2a731fa3de6cd038a6965f81577b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43c2a731fa3de6cd038a6965f81577b">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteEqualVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename ComparedVector_ , typename SubstituteVector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac43c2a731fa3de6cd038a6965f81577b">tatami::DelayedUnaryIsometricSubstituteEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a>&lt;CompareOperation::EQUAL, OutputValue_, InputValue_, Index_, ComparedVector_, SubstituteVector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar equality substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the substitution. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the substitution. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">ComparedVector_</td><td>Type of the vector containing values to compare to the input matrix. </td></tr>
    <tr><td class="paramname">SubstituteVector_</td><td>Type of the vector containing values to substitute in the output matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9c262b66d87bb7e9033d619cdcf169b" name="ad9c262b66d87bb7e9033d619cdcf169b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c262b66d87bb7e9033d619cdcf169b">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteGreaterThanVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename ComparedVector_ , typename SubstituteVector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad9c262b66d87bb7e9033d619cdcf169b">tatami::DelayedUnaryIsometricSubstituteGreaterThanVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a>&lt;CompareOperation::GREATER_THAN, OutputValue_, InputValue_, Index_, ComparedVector_, SubstituteVector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar "greater than" substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the substitution. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the substitution. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">ComparedVector_</td><td>Type of the vector containing values to compare to the input matrix. </td></tr>
    <tr><td class="paramname">SubstituteVector_</td><td>Type of the vector containing values to substitute in the output matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a136ddc464e7c3ca5c0cb161074eb2e4f" name="a136ddc464e7c3ca5c0cb161074eb2e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136ddc464e7c3ca5c0cb161074eb2e4f">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteLessThanVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename ComparedVector_ , typename SubstituteVector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a136ddc464e7c3ca5c0cb161074eb2e4f">tatami::DelayedUnaryIsometricSubstituteLessThanVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a>&lt;CompareOperation::LESS_THAN, OutputValue_, InputValue_, Index_, ComparedVector_, SubstituteVector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar "less than" substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the substitution. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the substitution. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">ComparedVector_</td><td>Type of the vector containing values to compare to the input matrix. </td></tr>
    <tr><td class="paramname">SubstituteVector_</td><td>Type of the vector containing values to substitute in the output matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacdc6e163e4777518dd881d5e97c566f" name="aacdc6e163e4777518dd881d5e97c566f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdc6e163e4777518dd881d5e97c566f">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteGreaterThanOrEqualVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename ComparedVector_ , typename SubstituteVector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aacdc6e163e4777518dd881d5e97c566f">tatami::DelayedUnaryIsometricSubstituteGreaterThanOrEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a>&lt;CompareOperation::GREATER_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, ComparedVector_, SubstituteVector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar "greater than or equal" substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the substitution. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the substitution. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">ComparedVector_</td><td>Type of the vector containing values to compare to the input matrix. </td></tr>
    <tr><td class="paramname">SubstituteVector_</td><td>Type of the vector containing values to substitute in the output matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a217608866f96365bd9370c9f09fb242c" name="a217608866f96365bd9370c9f09fb242c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217608866f96365bd9370c9f09fb242c">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteLessThanOrEqualVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename ComparedVector_ , typename SubstituteVector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a217608866f96365bd9370c9f09fb242c">tatami::DelayedUnaryIsometricSubstituteLessThanOrEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a>&lt;CompareOperation::LESS_THAN_OR_EQUAL, OutputValue_, InputValue_, Index_, ComparedVector_, SubstituteVector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar "less than or equal" substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the substitution. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the substitution. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">ComparedVector_</td><td>Type of the vector containing values to compare to the input matrix. </td></tr>
    <tr><td class="paramname">SubstituteVector_</td><td>Type of the vector containing values to substitute in the output matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf285b6e52c66ec11445d6a69a6bdd50" name="abf285b6e52c66ec11445d6a69a6bdd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf285b6e52c66ec11445d6a69a6bdd50">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteNotEqualVectorHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ , typename ComparedVector_ , typename SubstituteVector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abf285b6e52c66ec11445d6a69a6bdd50">tatami::DelayedUnaryIsometricSubstituteNotEqualVectorHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSubstituteVectorHelper.html">DelayedUnaryIsometricSubstituteVectorHelper</a>&lt;CompareOperation::NOT_EQUAL, OutputValue_, InputValue_, Index_, ComparedVector_, SubstituteVector_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the scalar non-equality substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the substitution. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the substitution. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">ComparedVector_</td><td>Type of the vector containing values to compare to the input matrix. </td></tr>
    <tr><td class="paramname">SubstituteVector_</td><td>Type of the vector containing values to substitute in the output matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af20c8766117c8e362b4d7cffb1d4b9e9" name="af20c8766117c8e362b4d7cffb1d4b9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20c8766117c8e362b4d7cffb1d4b9e9">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteIsnanHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool pass_, typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af20c8766117c8e362b4d7cffb1d4b9e9">tatami::DelayedUnaryIsometricSubstituteIsnanHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstituteHelper.html">DelayedUnaryIsometricSpecialSubstituteHelper</a>&lt;SpecialCompareOperation::ISNAN, pass_, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the NaN substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pass_</td><td>Whether to substitute if the input value is NaN. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fc2988a433b39c29c4eda6348e023bc" name="a7fc2988a433b39c29c4eda6348e023bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc2988a433b39c29c4eda6348e023bc">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteIsinfHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool pass_, typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7fc2988a433b39c29c4eda6348e023bc">tatami::DelayedUnaryIsometricSubstituteIsinfHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstituteHelper.html">DelayedUnaryIsometricSpecialSubstituteHelper</a>&lt;SpecialCompareOperation::ISINF, pass_, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the infinity substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pass_</td><td>Whether to substitute if the input value is infinite. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add55c44e96392e7c562ac87fce83f11d" name="add55c44e96392e7c562ac87fce83f11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add55c44e96392e7c562ac87fce83f11d">&#9670;&#160;</a></span>DelayedUnaryIsometricSubstituteIsfiniteHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool pass_, typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#add55c44e96392e7c562ac87fce83f11d">tatami::DelayedUnaryIsometricSubstituteIsfiniteHelper</a> = <a class="el" href="classtatami_1_1DelayedUnaryIsometricSpecialSubstituteHelper.html">DelayedUnaryIsometricSpecialSubstituteHelper</a>&lt;SpecialCompareOperation::ISFINITE, pass_, OutputValue_, InputValue_, Index_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenient alias for the finite value substitution helper.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">pass_</td><td>Whether to substitute if the input value is finite. </td></tr>
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the comparison. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the comparison. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7676f28b5618fd937e38b7a5c759d8bf" name="a7676f28b5618fd937e38b7a5c759d8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7676f28b5618fd937e38b7a5c759d8bf">&#9670;&#160;</a></span>ElementType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Array_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7676f28b5618fd937e38b7a5c759d8bf">tatami::ElementType</a> = I&lt;decltype(std::declval&lt;Array_&gt;()[0])&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array_</td><td>Some array of values that are accessed with <code>[</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Extract the type of array elements, after stripping away references and <code>const</code>-ness. </p>

</div>
</div>
<a id="a812af1bfb04773bf28da8549c3e6e5ee" name="a812af1bfb04773bf28da8549c3e6e5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812af1bfb04773bf28da8549c3e6e5ee">&#9670;&#160;</a></span>MaybeOracle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool oracle_, typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a812af1bfb04773bf28da8549c3e6e5ee">tatami::MaybeOracle</a> = typename std::conditional&lt;oracle_, std::shared_ptr&lt;const <a class="el" href="classtatami_1_1Oracle.html">Oracle</a>&lt;Index_&gt; &gt;, bool&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oracle_</td><td>Whether an oracle should be supplied. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer.</td></tr>
  </table>
  </dd>
</dl>
<p>Maybe an <code><a class="el" href="classtatami_1_1Oracle.html" title="Predict future access requests on the target dimension.">Oracle</a></code>, maybe a placeholder boolean, depending on <code>oracle_</code>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0a2ecaf58e2b69bb4a808e814aeb16a1" name="a0a2ecaf58e2b69bb4a808e814aeb16a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2ecaf58e2b69bb4a808e814aeb16a1">&#9670;&#160;</a></span>DimensionSelectionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a0a2ecaf58e2b69bb4a808e814aeb16a1">tatami::DimensionSelectionType</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Selection of dimension elements:</p>
<ul>
<li><code>FULL</code>: selects the full extent of the dimension, i.e., all elements.</li>
<li><code>BLOCK</code>: selects a contiguous block of elements in the dimension.</li>
<li><code>INDEX</code>: selects a sorted and unique array of indices of dimension elements.</li>
</ul>
<p>This corresponds to the various overloads of <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> methods (e.g., <code><a class="el" href="classtatami_1_1Matrix.html#a168f0e932b5503c9bfc5dbd42754a7a5">Matrix::dense_row()</a></code>), each of which extracts a different selection of elements from the non-target dimension. </p>

</div>
</div>
<a id="a9050a4b119e027638175c38cc9bbede8" name="a9050a4b119e027638175c38cc9bbede8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9050a4b119e027638175c38cc9bbede8">&#9670;&#160;</a></span>ArithmeticOperation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a9050a4b119e027638175c38cc9bbede8">tatami::ArithmeticOperation</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of arithmetic operation.</p>
<p>The <code>INTEGER_DIVIDE</code> refers to a floored division, which differs from truncation for negative quotients. This choice is based on R's <code>%/%</code>, which in turn is based on a recommendation by Donald Knuth.</p>
<p>Similarly, <code>x MODULO y</code> is defined as <code>x - floor(x / y)</code>, based on the same floored division. Note that this differs from the built-in <code>%</code> operator, which performs truncation. </p>

</div>
</div>
<a id="a4e5eea599200bfb6bc42f184118be28a" name="a4e5eea599200bfb6bc42f184118be28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5eea599200bfb6bc42f184118be28a">&#9670;&#160;</a></span>BooleanOperation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a4e5eea599200bfb6bc42f184118be28a">tatami::BooleanOperation</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of boolean operation. </p>

</div>
</div>
<a id="a89475b46f681dd39b9926ced507240cc" name="a89475b46f681dd39b9926ced507240cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89475b46f681dd39b9926ced507240cc">&#9670;&#160;</a></span>CompareOperation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a89475b46f681dd39b9926ced507240cc">tatami::CompareOperation</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of comparison operation. </p>

</div>
</div>
<a id="a4ef624db40413dabc3fea554fc936d39" name="a4ef624db40413dabc3fea554fc936d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef624db40413dabc3fea554fc936d39">&#9670;&#160;</a></span>SpecialCompareOperation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a4ef624db40413dabc3fea554fc936d39">tatami::SpecialCompareOperation</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of comparison operation for special IEEE values. </p>

</div>
</div>
<a id="a6c4e0b21d1826723cc5ea81d889a73e5" name="a6c4e0b21d1826723cc5ea81d889a73e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4e0b21d1826723cc5ea81d889a73e5">&#9670;&#160;</a></span>SomeNumericType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a6c4e0b21d1826723cc5ea81d889a73e5">tatami::SomeNumericType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Types supported in <code><a class="el" href="classtatami_1_1SomeNumericArray.html" title="Array of some numeric type, determined at runtime.">SomeNumericArray</a></code>. The letters indicate whether it is an integer (I), unsigned integer (U) or a float, while the numbers specify the number of bits for the type. So, for example, <code>U16</code> is an unsigned 16-bit integer, while <code>F64</code> is a <code>double</code>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac5f5ff476ecb172e59c3535cedb966cd" name="ac5f5ff476ecb172e59c3535cedb966cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f5ff476ecb172e59c3535cedb966cd">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StoredValue_ , typename InputValue_ , typename InputIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>row_major</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoredValue_ *const</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1ConvertToDenseOptions.html">ConvertToDenseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for the indices in the input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row_major</td><td>Whether to store the output as a row-major matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">store</td><td>Pointer to an array of length equal to the product of the dimensions of <code>matrix</code>. On output, this is filled with values from <code>matrix</code> in row- or column-major format depending on <code>row_major</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a512b86bd654884abaa4b42f0640b30e9" name="a512b86bd654884abaa4b42f0640b30e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512b86bd654884abaa4b42f0640b30e9">&#9670;&#160;</a></span>convert_to_dense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename StoredValue_  = Value_, typename InputValue_ , typename InputIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::convert_to_dense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>row_major</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1ConvertToDenseOptions.html">ConvertToDenseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for the indices in the input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">row_major</td><td>Whether to return a row-major matrix. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1DenseMatrix.html" title="Dense matrix representation.">tatami::DenseMatrix</a></code> with the same dimensions and type as the matrix referenced by <code>matrix</code>. If <code>row_major = true</code>, the matrix is row-major, otherwise it is column-major. </dd></dl>

</div>
</div>
<a id="a559b03571aa5f2e9a3cef60723d9ff96" name="a559b03571aa5f2e9a3cef60723d9ff96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559b03571aa5f2e9a3cef60723d9ff96">&#9670;&#160;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input_ , typename Output_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::transpose </td>
          <td>(</td>
          <td class="paramtype">const Input_ *const</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>nrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>ncol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>input_stride</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_ *const</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>output_stride</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_</td><td>Input type. </td></tr>
    <tr><td class="paramname">Output_</td><td>Output type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing a row-major matrix with <code>nrow</code> rows and <code>ncol</code> columns. Elements within each row should be contiguous but consecutive rows can be separated by a constant stride, see <code>input_stride</code>. The array should have at least <code>(nrow - 1) * input_stride + ncol</code> addressable elements. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nrow</td><td>Number of rows in the matrix stored at <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ncol</td><td>Number of columns in the matrix stored at <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">input_stride</td><td>Distance between corresponding entries on consecutive rows of the <code>input</code> matrix. This should be greater than or equal to <code>ncol</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array in which to store the transpose of the matrix in <code>input</code>. On output, this stores a row-major matrix with <code>ncol</code> rows and <code>nrow</code> columns. Elements within each row should be contiguous but consecutive rows can be separated by a constant stride, see <code>output_stride</code>. The array should have at least <code>(ncol - 1) * output_stride + nrow</code> addressable elements. It is assumed that <code>output</code> does not alias <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">output_stride</td><td>Distance between corresponding entries on consecutive rows of the <code>output</code> matrix. This should be greater than or equal to <code>nrow</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is intended for developers of <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> subclasses who need to do some transposition, e.g., for dense chunks during caching. The <code>*_stride</code> arguments allow <code>input</code> and <code>output</code> to refer to submatrices of larger arrays.</p>
<p>The argument descriptions refer to row-major matrices only for the sake of convenience. This function is equally applicable to column-major matrices, just replace all instances of "row" with "column" and vice versa. </p>

</div>
</div>
<a id="af7c8278aeb3a9f87ec780c8678489924" name="af7c8278aeb3a9f87ec780c8678489924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c8278aeb3a9f87ec780c8678489924">&#9670;&#160;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input_ , typename Output_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::transpose </td>
          <td>(</td>
          <td class="paramtype">const Input_ *const</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>nrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>ncol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_ *const</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_</td><td>Input type. </td></tr>
    <tr><td class="paramname">Output_</td><td>Output type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing a row-major matrix with <code>nrow</code> rows and <code>ncol</code> columns. The array should have at least <code>nrow * ncol</code> addressable elements, and all elements should be stored contiguously in the array. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nrow</td><td>Number of rows in the matrix stored at <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ncol</td><td>Number of columns in the matrix stored at <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length <code>nrow * ncol</code>. On output, this will hold the transpose of the matrix represented by <code>input</code>, i.e., a row-major matrix with <code>ncol</code> rows and <code>nrow</code> columns. It is assumed that <code>output</code> does not alias <code>input</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is intended for developers of <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> subclasses who need to do some transposition, e.g., for dense chunks during caching. Users should instead construct a <code><a class="el" href="classtatami_1_1DelayedTranspose.html" title="Delayed transposition of a matrix.">DelayedTranspose</a></code> object to perform a memory-efficient delayed transposition, or use <code><a class="el" href="#ac5f5ff476ecb172e59c3535cedb966cd">convert_to_dense()</a></code> to convert their dense data into the desired storage layout.</p>
<p>The argument descriptions refer to row-major matrices only for the sake of convenience. This function is equally applicable to column-major matrices, just replace all instances of "row" with "column" and vice versa. </p>

</div>
</div>
<a id="ab4c8b88eeaa5fcbb1e5d47d020eb98ea" name="ab4c8b88eeaa5fcbb1e5d47d020eb98ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c8b88eeaa5fcbb1e5d47d020eb98ea">&#9670;&#160;</a></span>make_DelayedCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueOut_ , typename IndexOut_ , typename ValueIn_ , typename IndexIn_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; ValueOut_, IndexOut_ &gt; &gt; tatami::make_DelayedCast </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; ValueIn_, IndexIn_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recast a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> to a different interface type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueOut_</td><td>Data type to cast to. </td></tr>
    <tr><td class="paramname">IndexOut_</td><td>Index type to cast to. </td></tr>
    <tr><td class="paramname">ValueIn_</td><td>Data type to cast from. </td></tr>
    <tr><td class="paramname">IndexIn_</td><td>Index type to cast from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the (possbly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> instance to cast from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> instance of the desired interface type. </dd></dl>

</div>
</div>
<a id="abb624f8a5bc844d3e902cde63b84001f" name="abb624f8a5bc844d3e902cde63b84001f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb624f8a5bc844d3e902cde63b84001f">&#9670;&#160;</a></span>compress_sparse_triplets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Values_ , typename Pointer_  = I&lt;decltype(std::declval&lt;Values_&gt;().size())&gt;, class PrimaryIndices_ , class SecondaryIndices_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Pointer_ &gt; tatami::compress_sparse_triplets </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_primary</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Values_ &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrimaryIndices_ &amp;</td>          <td class="paramname"><span class="paramname"><em>primary_indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SecondaryIndices_ &amp;</td>          <td class="paramname"><span class="paramname"><em>secondary_indices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For compressed sparse matrices, we consider the "primary" dimension to be that along which the structural non-zero elements are grouped in memory, e.g., the columns and rows for compressed sparse row and column matrices, respectively. Thus, the matrix only needs to retain the indices of structural non-zeros along the other (i.e., "secondary") dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Values_</td><td>Random-access container for the values. This should have a <code>size()</code> method and a <code>[</code> access operator. </td></tr>
    <tr><td class="paramname">Pointer_</td><td>Integer type of the index pointers in the output. </td></tr>
    <tr><td class="paramname">PrimaryIndices_</td><td>Random access container for the primary indices. This should have a <code>size()</code> method and a <code>[</code> access operator. </td></tr>
    <tr><td class="paramname">SecondaryIndices_</td><td>Random access container for the secondary indices. This should have a <code>size()</code> method and a <code>[</code> access operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_primary</td><td>Extent of the primary dimension. </td></tr>
    <tr><td class="paramname">values</td><td>Values of the structural non-zeros. </td></tr>
    <tr><td class="paramname">primary_indices</td><td>Indices of the structural non-zeros along the primary dimension. Values must be non-negative integers less than <code>num_primary</code>. The length of the vector should be equal to <code>values</code>. </td></tr>
    <tr><td class="paramname">secondary_indices</td><td>Indices of the structural non-zeros along the secondary dimension. Values must be non-negative integers. The length of the vector should be equal to <code>values</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>secondary_indices</code> and <code>values</code> are sorted in-place, as if all the structural non-zeros were sorted by increasing <code>primary_indices</code> and then <code>secondary_indices</code>. A vector of index pointers is returned with length <code>num_primary + 1</code>, specifying the subarray of <code>values</code> and <code>secondary_indices</code> corresponding to each primary dimension element.</dd></dl>
<p>Note that <code>primary_indices</code> is not modified inside this function for efficiency. If needed, a sorted <code>primary_indices</code> can be easily created by simply filling <code>primary_indices</code> based on the differences between consecutive index pointers. </p>

</div>
</div>
<a id="a305c49810ea7cad498399ad7c9dd0ee0" name="a305c49810ea7cad498399ad7c9dd0ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305c49810ea7cad498399ad7c9dd0ee0">&#9670;&#160;</a></span>count_compressed_sparse_non_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Count_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::count_compressed_sparse_non_zeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Count_ *const</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1CountCompressedSparseNonZerosOptions.html">CountCompressedSparseNonZerosOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of value in the matrix. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of row/column index. </td></tr>
    <tr><td class="paramname">Count_</td><td>Integer type for the non-zero count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to count structural non-zeros by row. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length equal to the number of rows (if <code>row = true</code>) or columns (otherwise) of <code>matrix</code>. On output, this stores the number of structural non-zeros in each row (if <code>row = true</code>) or column (otherwise). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<p>For sparse <code>matrix</code>, all structural non-zero elements are reported, even if they have actual values of zero. In contrast, for dense <code>matrix</code>, only the non-zero values are counted; these are considered to be structural non-zeros upon conversion to a sparse matrix (e.g., in <code><a class="el" href="#ac8dd052eda49e8b530947753c24f1178">fill_compressed_sparse_contents()</a></code>). </p>

</div>
</div>
<a id="ac8dd052eda49e8b530947753c24f1178" name="ac8dd052eda49e8b530947753c24f1178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8dd052eda49e8b530947753c24f1178">&#9670;&#160;</a></span>fill_compressed_sparse_contents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputValue_ , typename InputIndex_ , typename Pointer_ , typename StoredValue_ , typename StoredIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::fill_compressed_sparse_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pointer_ *const</td>          <td class="paramname"><span class="paramname"><em>pointers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoredValue_ *const</td>          <td class="paramname"><span class="paramname"><em>output_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoredIndex_ *const</td>          <td class="paramname"><span class="paramname"><em>output_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1FillCompressedSparseContentsOptions.html">FillCompressedSparseContentsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">Pointer_</td><td>Integer type for the row/column pointers. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to fill <code>output_value</code> and <code>output_index</code> by row, i.e., the output represents a compressed sparse row matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointers</td><td>Pointer to an array of length greater than or equal to the number of rows (if <code>row = true</code>) or columns (otherwise) of <code>matrix</code>. Each entry contains the position of the start of each row/column in <code>output_value</code> and <code>output_index</code>. This argument is equivalent to the array of pointers for the compressed sparse format (e.g., <code><a class="el" href="structtatami_1_1CompressedSparseContents.html#ad9410e8d3b32bc97086bebf2322c0ef8">CompressedSparseContents::pointers</a></code>), and can be obtained by taking the cumulative sum of the per-row/column counts from <code><a class="el" href="#a305c49810ea7cad498399ad7c9dd0ee0">count_compressed_sparse_non_zeros()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_value</td><td>Pointer to an array of length equal to the total number of structural non-zero elements. On output, this is used to store the values of those elements in a compressed sparse format (e.g., <code><a class="el" href="structtatami_1_1CompressedSparseContents.html#ad406234c4c87a0b3cbdd52948d2ae1b1">CompressedSparseContents::value</a></code>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_index</td><td>Pointer to an array of length equal to the total number of structural non-zero elements. On output, this is used to store the row/column indices of those elements in a compressed sparse format (e.g., <code><a class="el" href="structtatami_1_1CompressedSparseContents.html#a5b30cd6415c0e3cfd91b31590f16bc58">CompressedSparseContents::index</a></code>). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e0ab534fd3195a57abcb47272d41ded" name="a7e0ab534fd3195a57abcb47272d41ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0ab534fd3195a57abcb47272d41ded">&#9670;&#160;</a></span>retrieve_compressed_sparse_contents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StoredValue_ , typename StoredIndex_ , typename StoredPointer_  = std::size_t, typename InputValue_ , typename InputIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1CompressedSparseContents.html">CompressedSparseContents</a>&lt; StoredValue_, StoredIndex_, StoredPointer_ &gt; tatami::retrieve_compressed_sparse_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1RetrieveCompressedSparseContentsOptions.html">RetrieveCompressedSparseContentsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the row/column indices in the output. </td></tr>
    <tr><td class="paramname">StoredPointer_</td><td>Integer type for the row/column pointers in the output. This should be large enough to hold the number of non-zero elements in <code>matrix</code>. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">row</td><td>Whether to retrieve the contents of <code>matrix</code> by row, i.e., the output is a compressed sparse row matrix. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contents of the sparse matrix in compressed form, see <code><a class="el" href="structtatami_1_1CompressedSparseContents.html" title="Compressed sparse contents.">CompressedSparseContents</a></code>.</dd></dl>
<p>The behavior of this function can be replicated by manually calling <code><a class="el" href="#a305c49810ea7cad498399ad7c9dd0ee0">count_compressed_sparse_non_zeros()</a></code> followed by <code><a class="el" href="#ac8dd052eda49e8b530947753c24f1178">fill_compressed_sparse_contents()</a></code>. This may be desirable for users who want to put the compressed sparse contents into pre-existing memory allocations. </p>

</div>
</div>
<a id="ae4758e123ce35dfe718a331a66ac0e16" name="ae4758e123ce35dfe718a331a66ac0e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4758e123ce35dfe718a331a66ac0e16">&#9670;&#160;</a></span>convert_to_compressed_sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename StoredValue_  = Value_, typename StoredIndex_  = Index_, typename StoredPointer_  = std::size_t, typename InputValue_ , typename InputIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::convert_to_compressed_sparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1ConvertToCompressedSparseOptions.html">ConvertToCompressedSparseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">StoredPointer_</td><td>Integer type for the row/column pointers in the output. This should be large enough to hold the number of non-zero elements in <code>matrix</code>. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">row</td><td>Whether to return a compressed sparse row matrix. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1CompressedSparseMatrix.html" title="Compressed sparse matrix representation.">tatami::CompressedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>matrix</code>. If <code>row = true</code>, the matrix is in compressed sparse row format, otherwise it is compressed sparse column. </dd></dl>

</div>
</div>
<a id="a4b4feed54780ff0d6ec18a38a5752f22" name="a4b4feed54780ff0d6ec18a38a5752f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4feed54780ff0d6ec18a38a5752f22">&#9670;&#160;</a></span>retrieve_fragmented_sparse_contents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StoredValue_ , typename StoredIndex_ , typename InputValue_ , typename InputIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtatami_1_1FragmentedSparseContents.html">FragmentedSparseContents</a>&lt; StoredValue_, StoredIndex_ &gt; tatami::retrieve_fragmented_sparse_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1RetrieveFragmentedSparseContentsOptions.html">RetrieveFragmentedSparseContentsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">row</td><td>Whether to retrieve the contents of <code>matrix</code> by row, i.e., the output is a fragmented sparse row matrix. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contents of the sparse matrix in fragmented form, see <code><a class="el" href="structtatami_1_1FragmentedSparseContents.html" title="Fragmented sparse contents.">FragmentedSparseContents</a></code>. </dd></dl>

</div>
</div>
<a id="acac2470badcf668316367fdea9704035" name="acac2470badcf668316367fdea9704035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac2470badcf668316367fdea9704035">&#9670;&#160;</a></span>convert_to_fragmented_sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename StoredValue_  = Value_, typename StoredIndex_  = Index_, typename InputValue_ , typename InputIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::convert_to_fragmented_sparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; InputValue_, InputIndex_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1ConvertToFragmentedSparseOptions.html">ConvertToFragmentedSparseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of data values in the output interface. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices in the output interface. </td></tr>
    <tr><td class="paramname">StoredValue_</td><td>Type of data values to be stored in the output. </td></tr>
    <tr><td class="paramname">StoredIndex_</td><td>Integer type for storing the indices in the output. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of data values in the input interface. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for indices in the input interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>. </td></tr>
    <tr><td class="paramname">row</td><td>Whether to return a fragmented sparse row matrix. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new <code><a class="el" href="classtatami_1_1FragmentedSparseMatrix.html" title="Fragmented sparse matrix representation.">tatami::FragmentedSparseMatrix</a></code>, with the same dimensions and type as the matrix referenced by <code>matrix</code>. If <code>row = true</code>, the matrix is in fragmented sparse row format, otherwise it is fragmented sparse column. </dd></dl>

</div>
</div>
<a id="a4fdae940708614108ad158f0c2590f8d" name="a4fdae940708614108ad158f0c2590f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdae940708614108ad158f0c2590f8d">&#9670;&#160;</a></span>make_DelayedSubsetBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedSubsetBlock </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index_</td>          <td class="paramname"><span class="paramname"><em>subset_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index_</td>          <td class="paramname"><span class="paramname"><em>subset_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Pointer to the underlying (pre-subset) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">subset_start</td><td>Index of the start of the block. This should be a row index if <code>by_row = true</code> and a column index otherwise. </td></tr>
    <tr><td class="paramname">subset_length</td><td>Index of the one-past-the-end of the block. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether to apply the subset to the rows. If false, the subset is applied to the columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedSubsetBlock.html" title="Delayed subsetting to a contiguous block.">DelayedSubsetBlock</a></code> instance. </dd></dl>

</div>
</div>
<a id="af62b9d27c0c501e5b65e52ce37f0ee5d" name="af62b9d27c0c501e5b65e52ce37f0ee5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62b9d27c0c501e5b65e52ce37f0ee5d">&#9670;&#160;</a></span>make_DelayedSubset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , class SubsetStorage_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::make_DelayedSubset </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubsetStorage_</td>          <td class="paramname"><span class="paramname"><em>subset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>by_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <code>make_*</code> helper function to enable partial template deduction of supplied types. This will automatically dispatch to <code><a class="el" href="classtatami_1_1DelayedSubsetSortedUnique.html" title="Delayed subsetting of a matrix with sorted, unique indices.">DelayedSubsetSortedUnique</a></code>, <code><a class="el" href="classtatami_1_1DelayedSubsetUnique.html" title="Delayed subsetting of a matrix with unique indices.">DelayedSubsetUnique</a></code>, <code><a class="el" href="classtatami_1_1DelayedSubsetSorted.html" title="Delayed subsetting of a matrix with sorted indices.">DelayedSubsetSorted</a></code> or <code><a class="el" href="classtatami_1_1DelayedSubset.html" title="Delayed subsetting of a matrix with general indices.">DelayedSubset</a></code>, depending on the values in <code>subset</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the row/column indices. </td></tr>
    <tr><td class="paramname">SubsetStorage_</td><td>Vector containing the subset indices, to be automatically deduced. Any class implementing <code>[</code>, <code>size()</code>, <code>begin()</code> and <code>end()</code> can be used here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Pointer to a (possibly <code>const</code>) <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code>. </td></tr>
    <tr><td class="paramname">subset</td><td>Instance of the subset index vector. </td></tr>
    <tr><td class="paramname">by_row</td><td>Whether to apply the subset to the rows. If false, the subset is applied to the columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="classtatami_1_1DelayedSubset.html" title="Delayed subsetting of a matrix with general indices.">DelayedSubset</a></code> instance. </dd></dl>

</div>
</div>
<a id="ae5cfcdf9fa34c6d0cd6b672472d407b3" name="ae5cfcdf9fa34c6d0cd6b672472d407b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cfcdf9fa34c6d0cd6b672472d407b3">&#9670;&#160;</a></span>consecutive_extractor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool sparse_, typename Value_ , typename Index_ , typename ... Args_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tatami::consecutive_extractor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index_</td>          <td class="paramname"><span class="paramname"><em>iter_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index_</td>          <td class="paramname"><span class="paramname"><em>iter_length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args_ &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates an extractor object with a <code><a class="el" href="classtatami_1_1ConsecutiveOracle.html" title="Predict future accesses along a consecutive sequence.">ConsecutiveOracle</a></code> instance spanning a range of rows or columns. <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code> implementations that are oracle-aware can then perform pre-fetching of future accesses for greater performance.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">sparse_</td><td>Whether to perform sparse retrieval. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Type of the row/column index. </td></tr>
    <tr><td class="paramname">Args_</td><td>Types of further arguments to pass to <code><a class="el" href="classtatami_1_1Matrix.html#a168f0e932b5503c9bfc5dbd42754a7a5">Matrix::dense_row</a></code> or <code><a class="el" href="classtatami_1_1Matrix.html#a48300b3739f26bb10732c572ea9e5c57">Matrix::dense_column</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code> to iterate over. </td></tr>
    <tr><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramname">iter_start</td><td>Index of the first row (if <code>row = true</code>) or column (otherwise) of the iteration range. </td></tr>
    <tr><td class="paramname">iter_length</td><td>Number of rows (if <code>row = true</code>) or columns (otherwise) in the iteration range. </td></tr>
    <tr><td class="paramname">args</td><td>Further arguments to pass to <code><a class="el" href="#a0a638ee666d4ded2e1cb68c39bc14b32">new_extractor()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An extractor for iteration over consecutive rows/columns in <code>[iter_start, iter_start + iter_length)</code>. This may be either an <code><a class="el" href="classtatami_1_1OracularDenseExtractor.html" title="Extract an element of the target dimension in dense form with an oracle.">OracularDenseExtractor</a></code> or <code><a class="el" href="classtatami_1_1OracularSparseExtractor.html" title="Extract an element of the target dimension in sparse form with an oracle.">OracularSparseExtractor</a></code> depending on <code>sparse_</code>. </dd></dl>

</div>
</div>
<a id="aca84df9f6331751c29b0bcc0ca656af7" name="aca84df9f6331751c29b0bcc0ca656af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca84df9f6331751c29b0bcc0ca656af7">&#9670;&#160;</a></span>copy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Size_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value_ * tatami::copy_n </td>
          <td>(</td>
          <td class="paramtype">const Value_ *const</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Size_</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value_ *const</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of value being copied. </td></tr>
    <tr><td class="paramname">Size_</td><td>Integer type of the array length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to a source array of size <code>n</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Length of the array. This should fit into a <code>std::size_t</code>, even if <code>Size_</code> is of a larger type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to a destination array of size <code>n</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values are copied from <code>input</code> to <code>output</code>, and <code>output</code> is returned. This is a no-op if <code>input == output</code>. </dd></dl>

</div>
</div>
<a id="a4d15fa0c5213ad27fc0c99c3dd5c02ad" name="a4d15fa0c5213ad27fc0c99c3dd5c02ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d15fa0c5213ad27fc0c99c3dd5c02ad">&#9670;&#160;</a></span>can_cast_Index_to_container_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Index_ tatami::can_cast_Index_to_container_size </td>
          <td>(</td>
          <td class="paramtype">const Index_</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container_</td><td>Container with a <code>size()</code> method. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Size of the container as an <code>Index_</code>, typically the dimension extents. It is assumed that <code>x</code> can be represented by a <code>std::size_t</code>, even if <code>Index_</code> is a larger type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> as its input type. An error is raised if casting to the type of <code>Container_::size()</code> would result in overflow. </dd></dl>

</div>
</div>
<a id="ac6d0f6694ab914f57229b925641779d4" name="ac6d0f6694ab914f57229b925641779d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d0f6694ab914f57229b925641779d4">&#9670;&#160;</a></span>cast_Index_to_container_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I&lt; decltype(std::declval&lt; Container_ &gt;().size())&gt; tatami::cast_Index_to_container_size </td>
          <td>(</td>
          <td class="paramtype">const Index_</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container_</td><td>Container with a <code>size()</code> method. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Size of the container as an <code>Index_</code>, typically the dimension extents. It is assumed that <code>x</code> can be represented by a <code>std::size_t</code>, even if <code>Index_</code> is a larger type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> as the type of <code>Container_::size()</code>. An error is raised if the cast would result in overflow. </dd></dl>

</div>
</div>
<a id="ada885a7e7ae9dcafcaf98cde30622afc" name="ada885a7e7ae9dcafcaf98cde30622afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada885a7e7ae9dcafcaf98cde30622afc">&#9670;&#160;</a></span>create_container_of_Index_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container_ , typename Index_ , typename ... Args_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container_ tatami::create_container_of_Index_size </td>
          <td>(</td>
          <td class="paramtype">const Index_</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args_ &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container_</td><td>Container with a <code>size()</code> method and a constructor that accepts the size as the first argument. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the row/column indices. </td></tr>
    <tr><td class="paramname">Args_</td><td>Further arguments to pass to the <code>Container_</code>'s constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Size of the container as an <code>Index_</code>, typically the dimension extents. It is assumed that <code>x</code> can be represented by a <code>std::size_t</code>, even if <code>Index_</code> is a larger type. </td></tr>
    <tr><td class="paramname">args</td><td>Further arguments to pass to the <code>Container_</code> constructor, after <code>x</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of a <code>Container_</code> of size <code>x</code>. An error is raised if <code>x</code> is too large. </dd></dl>

</div>
</div>
<a id="a61b43d2b751c7fcca6815f3be929d4d3" name="a61b43d2b751c7fcca6815f3be929d4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b43d2b751c7fcca6815f3be929d4d3">&#9670;&#160;</a></span>resize_container_to_Index_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container_ , typename Index_ , typename ... Args_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::resize_container_to_Index_size </td>
          <td>(</td>
          <td class="paramtype">Container_ &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index_</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args_ &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container_</td><td>Container with a <code>size()</code> method and a <code>resize()</code> method that accepts the new length as the first argument. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the row/column indices. </td></tr>
    <tr><td class="paramname">Args_</td><td>Further arguments to pass to <code>Container_::resize()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Instance of a container. On output, this is resized to size <code>x</code>. An error is raised if <code>x</code> is too large. </td></tr>
    <tr><td class="paramname">x</td><td>Size of the container as an <code>Index_</code>, typically the dimension extents. It is assumed that <code>x</code> can be represented by a <code>std::size_t</code>, even if <code>Index_</code> is a larger type. </td></tr>
    <tr><td class="paramname">args</td><td>Further arguments to pass to the <code>resize()</code> method, after <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a638ee666d4ded2e1cb68c39bc14b32" name="a0a638ee666d4ded2e1cb68c39bc14b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a638ee666d4ded2e1cb68c39bc14b32">&#9670;&#160;</a></span>new_extractor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool sparse_, bool oracle_, typename Value_ , typename Index_ , typename ... Args_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tatami::new_extractor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a812af1bfb04773bf28da8549c3e6e5ee">MaybeOracle</a>&lt; oracle_, Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>oracle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args_ &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This utility makes it easier for developers to write a single templated function that works with and without oracles. A boolean placeholder should be provided as the "oracle" in the myopic extractor case.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">sparse_</td><td>Whether to perform sparse retrieval. </td></tr>
    <tr><td class="paramname">oracle_</td><td>Whether an oracle should be supplied. </td></tr>
    <tr><td class="paramname">Value_</td><td>Data value type, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Row/column index type, should be integer. </td></tr>
    <tr><td class="paramname">Args_</td><td>Further arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>A <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code> object to iterate over. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether to create a row-wise extractor, i.e., the rows are the target dimension. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">oracle</td><td>Pointer to an oracle if <code>oracle_ = true</code>, otherwise a placeholder boolean that is ignored. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">args</td><td>Zero or more additional arguments to pass to methods like <code><a class="el" href="classtatami_1_1Matrix.html#a168f0e932b5503c9bfc5dbd42754a7a5">Matrix::dense_row()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An extractor to access elements of the requested dimension of <code>ptr</code>. This may be any of <code><a class="el" href="classtatami_1_1MyopicDenseExtractor.html" title="Extract an element of the target dimension in dense form without an oracle.">MyopicDenseExtractor</a></code>, <code><a class="el" href="classtatami_1_1MyopicSparseExtractor.html" title="Extract an element of the target dimension in sparse form without an oracle.">MyopicSparseExtractor</a></code>, <code><a class="el" href="classtatami_1_1OracularDenseExtractor.html" title="Extract an element of the target dimension in dense form with an oracle.">OracularDenseExtractor</a></code> or <code><a class="el" href="classtatami_1_1OracularSparseExtractor.html" title="Extract an element of the target dimension in sparse form with an oracle.">OracularSparseExtractor</a></code>, depending on <code>sparse_</code> and <code>oracle_</code>. </dd></dl>

</div>
</div>
<a id="a3ea65e5b93eb55c03b00aca301e0396f" name="a3ea65e5b93eb55c03b00aca301e0396f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea65e5b93eb55c03b00aca301e0396f">&#9670;&#160;</a></span>parallelize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool parallel_ = true, class Function_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::parallelize </td>
          <td>(</td>
          <td class="paramtype">Function_</td>          <td class="paramname"><span class="paramname"><em>fun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index_</td>          <td class="paramname"><span class="paramname"><em>tasks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>threads</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a function to a set of tasks in parallel, usually for iterating over a dimension of a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">Matrix</a></code>. By default, this uses <code><a class="elRef" href="https://ltla.github.io/subpar/namespacesubpar.html#a9c64cc17f4f8d1fadbba6d25053a8dbe">subpar::parallelize_range()</a></code> internally, which uses OpenMP if available and <code>&lt;thread&gt;</code> otherwise. Advanced users can override the default parallelization mechanism by defining a <code>TATAMI_CUSTOM_PARALLEL</code> function-like macro. The macro should accept the <code>fun</code>, <code>tasks</code> and <code>threads</code> arguments as described below.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">parallel_</td><td>Whether the tasks should be run in parallel. If <code>false</code>, no parallelization is performed and all tasks are run on the current thread. </td></tr>
    <tr><td class="paramname">Function_</td><td>Function to be applied for a contiguous range of tasks. This should accept three arguments:<ul>
<li><code>thread</code>, the thread number executing this task range. This will be passed as an <code>int</code>.</li>
<li><code>task_start</code>, the start index of the task range. This will be passed as an <code>Index_</code>.</li>
<li><code>task_length</code>, the number of tasks in the task range. This will be passed as an <code>Index_</code>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the number of tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Function that executes a contiguous range of tasks. </td></tr>
    <tr><td class="paramname">tasks</td><td>Number of tasks. </td></tr>
    <tr><td class="paramname">threads</td><td>Number of threads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc238346c521152c4273e3552240d7f7" name="adc238346c521152c4273e3552240d7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc238346c521152c4273e3552240d7f7">&#9670;&#160;</a></span>process_consecutive_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , class Function_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tatami::process_consecutive_indices </td>
          <td>(</td>
          <td class="paramtype">const Index_ *const</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index_</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Function_</td>          <td class="paramname"><span class="paramname"><em>fun</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process runs of consecutive indices that are used in the index-aware <code>dense_row()</code>, <code>sparse_column()</code>, etc. methods. This provides some opportunities for optimization when the indices contain contiguous stretches. For example, third-party libraries can be asked to process blocks of observations rather than handling them one at a time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Function_</td><td>Function to apply to each contiguous run.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Pointer to an array of sorted and unique indices for row/column elements. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the array pointed to by <code>indices</code>. </td></tr>
    <tr><td class="paramname">fun</td><td>Function to apply to each contiguous run of indices. This should take two arguments - the start index of each run, and the length of the run. Calls to <code>fun</code> are guaranteed to contain increasing start indices with non-overlapping runs. The return value of this function is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a07f7937bfdbbe8e355cba20d7c0c3a" name="a5a07f7937bfdbbe8e355cba20d7c0c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a07f7937bfdbbe8e355cba20d7c0c3a">&#9670;&#160;</a></span>wrap_shared_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; &gt; tatami::wrap_shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtatami_1_1Matrix.html">Matrix</a>&lt; Value_, Index_ &gt; *const</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap a raw pointer inside a <code>shared_ptr</code>, typically to enable use of a raw <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code> pointer with delayed operation wrappers. This enables use of delayed operations inside functions that accept a raw pointer to an externally owned <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix value. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to a <code><a class="el" href="classtatami_1_1Matrix.html" title="Virtual class for a matrix.">tatami::Matrix</a></code> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the same object addressed by <code>ptr</code>. The assumption is that <code>ptr</code> will always outlive the returned pointer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
