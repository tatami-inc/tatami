<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tatami: tatami::DelayedBinaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tatami
   </div>
   <div id="projectbrief">C++ API for different matrix representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetatami.html">tatami</a></li><li class="navelem"><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">DelayedBinaryIsometricOperationHelper</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtatami_1_1DelayedBinaryIsometricOperationHelper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tatami::DelayedBinaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Helper operation interface for <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="binary_2helper__interface_8hpp_source.html">helper_interface.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tatami::DelayedBinaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtatami_1_1DelayedBinaryIsometricOperationHelper__inherit__graph.png" border="0" usemap="#atatami_1_1DelayedBinaryIsometricOperationHelper_3_01OutputValue___00_01InputValue___00_01Index___01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atatami_1_1DelayedBinaryIsometricOperationHelper_3_01OutputValue___00_01InputValue___00_01Index___01_4_inherit__map" id="atatami_1_1DelayedBinaryIsometricOperationHelper_3_01OutputValue___00_01InputValue___00_01Index___01_4_inherit__map">
<area shape="rect" title="Helper operation interface for DelayedBinaryIsometricOperation." alt="" coords="5,85,205,141"/>
<area shape="rect" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html" title="Helper for delayed binary isometric arithmetic." alt="" coords="253,5,482,61"/>
<area shape="poly" title=" " alt="" coords="212,78,273,59,274,64,214,83"/>
<area shape="rect" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html" title="Helper for delayed binary isometric boolean operations." alt="" coords="259,85,476,141"/>
<area shape="poly" title=" " alt="" coords="220,110,258,110,258,116,220,116"/>
<area shape="rect" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html" title="Helper for delayed binary isometric comparisons." alt="" coords="256,165,478,221"/>
<area shape="poly" title=" " alt="" coords="214,144,274,162,273,167,212,149"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f75c3d4dcce970e34c407f03d91c318" id="r_a9f75c3d4dcce970e34c407f03d91c318"><td class="memItemLeft" align="right" valign="top">virtual OutputValue_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f75c3d4dcce970e34c407f03d91c318">fill</a> (bool row, Index_ i) const =0</td></tr>
<tr class="separator:a9f75c3d4dcce970e34c407f03d91c318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c3339f8e04edecfe22bd787475dd04" id="r_ae7c3339f8e04edecfe22bd787475dd04"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7c3339f8e04edecfe22bd787475dd04">zero_depends_on_row</a> () const =0</td></tr>
<tr class="separator:ae7c3339f8e04edecfe22bd787475dd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa5a07e0f51354e33e884870c1b16ce" id="r_a4fa5a07e0f51354e33e884870c1b16ce"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fa5a07e0f51354e33e884870c1b16ce">zero_depends_on_column</a> () const =0</td></tr>
<tr class="separator:a4fa5a07e0f51354e33e884870c1b16ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21228693dde483130089a425a7fb4f7e" id="r_a21228693dde483130089a425a7fb4f7e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21228693dde483130089a425a7fb4f7e">non_zero_depends_on_row</a> () const =0</td></tr>
<tr class="separator:a21228693dde483130089a425a7fb4f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af515ba90e7c96d5091b1a478fbb9ea13" id="r_af515ba90e7c96d5091b1a478fbb9ea13"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af515ba90e7c96d5091b1a478fbb9ea13">non_zero_depends_on_column</a> () const =0</td></tr>
<tr class="separator:af515ba90e7c96d5091b1a478fbb9ea13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc75a3a95cef0bf13f93875f001bd43" id="r_aebc75a3a95cef0bf13f93875f001bd43"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebc75a3a95cef0bf13f93875f001bd43">dense</a> (bool row, Index_ i, Index_ start, Index_ length, const InputValue_ *left_buffer, const InputValue_ *right_buffer, OutputValue_ *output_buffer) const =0</td></tr>
<tr class="separator:aebc75a3a95cef0bf13f93875f001bd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6980856c142504d6cea946f2d92c7362" id="r_a6980856c142504d6cea946f2d92c7362"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6980856c142504d6cea946f2d92c7362">dense</a> (bool row, Index_ i, const std::vector&lt; Index_ &gt; &amp;indices, const InputValue_ *left_buffer, const InputValue_ *right_buffer, OutputValue_ *output_buffer) const =0</td></tr>
<tr class="separator:a6980856c142504d6cea946f2d92c7362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2715fa12671a4c8fbe5caa092db60957" id="r_a2715fa12671a4c8fbe5caa092db60957"><td class="memItemLeft" align="right" valign="top">virtual Index_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2715fa12671a4c8fbe5caa092db60957">sparse</a> (bool row, Index_ i, const <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; InputValue_, Index_ &gt; &amp;left, const <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; InputValue_, Index_ &gt; &amp;right, OutputValue_ *output_value, Index_ *output_index, bool report_value, bool report_index) const =0</td></tr>
<tr class="separator:a2715fa12671a4c8fbe5caa092db60957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac894879c4fb4f6a8a6edb13236468613" id="r_ac894879c4fb4f6a8a6edb13236468613"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac894879c4fb4f6a8a6edb13236468613">is_sparse</a> () const =0</td></tr>
<tr class="separator:ac894879c4fb4f6a8a6edb13236468613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2838a8794fd9ab3b5fdc1d62a25f64eb" id="r_a2838a8794fd9ab3b5fdc1d62a25f64eb"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; Index_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2838a8794fd9ab3b5fdc1d62a25f64eb">nrow</a> () const =0</td></tr>
<tr class="separator:a2838a8794fd9ab3b5fdc1d62a25f64eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e10a8b0b2cb9961f7976b7295e3ab71" id="r_a8e10a8b0b2cb9961f7976b7295e3ab71"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; Index_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e10a8b0b2cb9961f7976b7295e3ab71">ncol</a> () const =0</td></tr>
<tr class="separator:a8e10a8b0b2cb9961f7976b7295e3ab71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename OutputValue_, typename InputValue_, typename Index_&gt;<br />
class tatami::DelayedBinaryIsometricOperationHelper&lt; OutputValue_, InputValue_, Index_ &gt;</div><p>Helper operation interface for <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. </p>
<p>This class defines the interface for an operation helper in <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code>. Operations should generally inherit from this class, though it is possible for developers to define their own classes with the same signatures for compile-time polymorphism.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Type of the result of the operation. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Type of the matrix value used in the operation. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9f75c3d4dcce970e34c407f03d91c318" name="a9f75c3d4dcce970e34c407f03d91c318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f75c3d4dcce970e34c407f03d91c318">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual OutputValue_ <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">tatami::DelayedBinaryIsometricOperationHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Whether <code>i</code> refers to the row or column index. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row (if <code>row = true</code>) or column (otherwise) containing the zeros. This argument should be ignored if the operation does not depend on the row/column (i.e., when all of <code><a class="el" href="#ae7c3339f8e04edecfe22bd787475dd04">zero_depends_on_row()</a></code> and friends return false), in which case an arbitrary placeholder may be supplied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of <code>OP(lz, rz)</code> where <code>OP</code> is the operation, <code>lz</code> is a structural zero from the <code>i</code>-th row/column of the left matrix, and <code>rz</code> is a structural zero from the <code>i</code>-th row/column of the left matrix, </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html#a9cc8760f73087b4a7709ec866a6e05ae">tatami::DelayedBinaryIsometricArithmeticHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html#ad9f0b1b843847c8ad835baa549740269">tatami::DelayedBinaryIsometricBooleanHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, and <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html#ae11ed16f50fa1830c16fb1ffbfd3a23e">tatami::DelayedBinaryIsometricCompareHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="ae7c3339f8e04edecfe22bd787475dd04" name="ae7c3339f8e04edecfe22bd787475dd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c3339f8e04edecfe22bd787475dd04">&#9670;&#160;</a></span>zero_depends_on_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">tatami::DelayedBinaryIsometricOperationHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::zero_depends_on_row </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether applying the operation to a pair of structural zeros (one from each matrix) yields a value that depends on the identity of the row containing those zeros.</dd></dl>
<p>This method is only called when <code><a class="el" href="#ac894879c4fb4f6a8a6edb13236468613">is_sparse()</a></code> returns false. It is not necessary to explicitly return <code>false</code> here for sparsity-preserving operations, as <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code> will automatically recognize such operations as being row-independent. </p>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html#a17ffb4618be1a0b7a9f3787c6498de77">tatami::DelayedBinaryIsometricArithmeticHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html#a018e062f9502757475c8b9f5f3f6ecff">tatami::DelayedBinaryIsometricBooleanHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, and <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html#a9912d3762af38af25a9ac24f9d5fb921">tatami::DelayedBinaryIsometricCompareHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a4fa5a07e0f51354e33e884870c1b16ce" name="a4fa5a07e0f51354e33e884870c1b16ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa5a07e0f51354e33e884870c1b16ce">&#9670;&#160;</a></span>zero_depends_on_column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">tatami::DelayedBinaryIsometricOperationHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::zero_depends_on_column </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether applying the operation to a pair of structural zeros (one from each matrix) yields a value that depends on the identity of the column containing those zeros.</dd></dl>
<p>This method is only called when <code><a class="el" href="#ac894879c4fb4f6a8a6edb13236468613">is_sparse()</a></code> returns false. It is not necessary to explicitly return <code>false</code> here for sparsity-preserving operations, as <code><a class="el" href="classtatami_1_1DelayedBinaryIsometricOperation.html" title="Delayed isometric operations on two matrices.">DelayedBinaryIsometricOperation</a></code> will automatically recognize such operations as being row-independent. </p>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html#a065484dc333c31a950bf52f74913f54b">tatami::DelayedBinaryIsometricArithmeticHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html#aa86c06a1bdbc79042e641dea30c7f8e2">tatami::DelayedBinaryIsometricBooleanHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, and <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html#a1e4f4e15e90eee06d31eb35afcbfc778">tatami::DelayedBinaryIsometricCompareHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a21228693dde483130089a425a7fb4f7e" name="a21228693dde483130089a425a7fb4f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21228693dde483130089a425a7fb4f7e">&#9670;&#160;</a></span>non_zero_depends_on_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">tatami::DelayedBinaryIsometricOperationHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::non_zero_depends_on_row </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the result of the operation depends on the identity of the row containing the operands, where at least one of the operands is non-zero. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html#a35e830040ed2a2cc69af23c3ed099540">tatami::DelayedBinaryIsometricArithmeticHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html#afbde6fe4632172c00c242ee64ea59752">tatami::DelayedBinaryIsometricBooleanHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, and <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html#a2ad37ae3f73fca6bea3e44778e643ca8">tatami::DelayedBinaryIsometricCompareHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="af515ba90e7c96d5091b1a478fbb9ea13" name="af515ba90e7c96d5091b1a478fbb9ea13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af515ba90e7c96d5091b1a478fbb9ea13">&#9670;&#160;</a></span>non_zero_depends_on_column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">tatami::DelayedBinaryIsometricOperationHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::non_zero_depends_on_column </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the result of the operation depends on the identity of the column containing the operands, where at least one of the operands is non-zero. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html#ac0bddf42c45ac3b67b22579cc9e08a04">tatami::DelayedBinaryIsometricArithmeticHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html#a1752c2a93561c332da379e266ac26249">tatami::DelayedBinaryIsometricBooleanHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, and <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html#ae5b6fec1056cf82dc25ce3c369ddec14">tatami::DelayedBinaryIsometricCompareHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="aebc75a3a95cef0bf13f93875f001bd43" name="aebc75a3a95cef0bf13f93875f001bd43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc75a3a95cef0bf13f93875f001bd43">&#9670;&#160;</a></span>dense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">tatami::DelayedBinaryIsometricOperationHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::dense </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputValue_ *</td>          <td class="paramname"><span class="paramname"><em>left_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputValue_ *</td>          <td class="paramname"><span class="paramname"><em>right_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputValue_ *</td>          <td class="paramname"><span class="paramname"><em>output_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method should apply the operation to corresponding values of <code>left_buffer</code> and <code>right_buffer</code>. These buffers represent the same element of the target dimension from the left and right matrices, respectively, in dense form. Each buffer holds values from a contiguous block of the non-target dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether the rows are the target dimension. If true, <code>left_buffer</code> and <code>right_buffer</code> hold the contents of the <code>i</code>-th row from both matrices; otherwise, they hold the contents of the <code>i</code>-th column. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). This argument should be ignored if the operation does not depend on the row/column (i.e., when all of <code><a class="el" href="#ae7c3339f8e04edecfe22bd787475dd04">zero_depends_on_row()</a></code> and friends return false), in which case an arbitrary placeholder may be supplied. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>Start of the contiguous block of columns (if <code>row = true</code>) or rows (otherwise) extracted from <code>i</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>Length of the contiguous block. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">left_buffer</td><td>Pointer to an array containing the row/column extracted from the left matrix. This has <code>length</code> addressable elements, and the result of the operation should be stored here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_buffer</td><td>Pointer to an array containing the row/column extracted from the right matrix. This has <code>length</code> addressable elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_buffer</td><td>Pointer to an array in which to store the result of the operation. This has <code>length</code> addressable elements. If <code>InputValue_ == OutputValue_</code>, this is guaranteed to be the same as <code>left_buffer</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html#ac1e24871344496496d22c4387527ed59">tatami::DelayedBinaryIsometricArithmeticHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html#a86090bd536e8098860e1ed87a00b8345">tatami::DelayedBinaryIsometricBooleanHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, and <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html#a0b12595e12724feb9776834522941229">tatami::DelayedBinaryIsometricCompareHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a6980856c142504d6cea946f2d92c7362" name="a6980856c142504d6cea946f2d92c7362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6980856c142504d6cea946f2d92c7362">&#9670;&#160;</a></span>dense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">tatami::DelayedBinaryIsometricOperationHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::dense </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputValue_ *</td>          <td class="paramname"><span class="paramname"><em>left_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputValue_ *</td>          <td class="paramname"><span class="paramname"><em>right_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputValue_ *</td>          <td class="paramname"><span class="paramname"><em>output_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method should apply the operation to corresponding values of <code>left_buffer</code> and <code>right_buffer</code>, These buffers represent the same element of the target dimension from the left and right matrices, respectively, in dense form. Each buffer holds values from an indexed subset of the non-target dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether the rows are the target dimension. If true, <code>left_buffer</code> and <code>right_buffer</code> hold the contents of the <code>i</code>-th row from both matrices; otherwise, they hold the contents of the <code>i</code>-th column. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). This argument should be ignored if the operation does not depend on the row/column (i.e., when all of <code><a class="el" href="#ae7c3339f8e04edecfe22bd787475dd04">zero_depends_on_row()</a></code> and friends return false), in which case an arbitrary placeholder may be supplied. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">indices</td><td>Sorted and unique indices of columns (if <code>row = true</code>) or rows (otherwise) extracted from <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">left_buffer</td><td>Pointer to an array containing the row/column extracted from the left matrix. This has <code>length</code> addressable elements, and the result of the operation should be stored here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_buffer</td><td>Pointer to an array containing the row/column extracted from the right matrix. This has <code>length</code> addressable elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_buffer</td><td>Pointer to an array in which to store the result of the operation. This has <code>length</code> addressable elements. If <code>InputValue_ == OutputValue_</code>, this is guaranteed to be the same as <code>left_buffer</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html#ad8ae4c115469a23ba7ce2d66b51509c6">tatami::DelayedBinaryIsometricArithmeticHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html#a73a6afde717caf876af65267eeaa364c">tatami::DelayedBinaryIsometricBooleanHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, and <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html#af6c753084c7b39b18c429ca5cdc9e472">tatami::DelayedBinaryIsometricCompareHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a2715fa12671a4c8fbe5caa092db60957" name="a2715fa12671a4c8fbe5caa092db60957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2715fa12671a4c8fbe5caa092db60957">&#9670;&#160;</a></span>sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index_ <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">tatami::DelayedBinaryIsometricOperationHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::sparse </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; InputValue_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtatami_1_1SparseRange.html">SparseRange</a>&lt; InputValue_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>right</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputValue_ *</td>          <td class="paramname"><span class="paramname"><em>output_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_ *</td>          <td class="paramname"><span class="paramname"><em>output_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>report_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>report_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method applies the operation to the sparse ranges in <code>left</code> and <code>right</code>, containing values from the same element of the target dimension from the left and right matrices, respectively. Specifically, the operation only needs to be applied to the structural non-zeros, and results of the operation should be stored in the <code>output_*</code> buffers. Structural zeros are either ignored for sparsity-preserving operations, or the result of the operation on zeros will be populated by <code><a class="el" href="#a9f75c3d4dcce970e34c407f03d91c318">fill()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">row</td><td>Whether the rows are the target dimension. If true, <code>left_buffer</code> and <code>right_buffer</code> hold the contents of the <code>i</code>-th row from both matrices; otherwise, they hold the contents of the <code>i</code>-th column. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">i</td><td>Index of the extracted row (if <code>row = true</code>) or column (otherwise). This argument should be ignored if the operation does not depend on the row/column (i.e., when all of <code><a class="el" href="#ae7c3339f8e04edecfe22bd787475dd04">zero_depends_on_row()</a></code> and friends return false), in which case an arbitrary placeholder may be supplied. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">left</td><td>Contents of row/column <code>i</code> extracted from the left matrix. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">right</td><td>Contents of row/column <code>i</code> extracted from the right matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_value</td><td>Pointer to an array for storing output values of the operation. This is guaranteed to have enough space for the union of indices in <code>left</code> and <code>right</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_index</td><td>Pointer to an array for storing output indices. This is guaranteed to have enough space for the union of indices in <code>left</code> and <code>right</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">report_value</td><td>Whether to return the values in <code>output_value</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">report_index</td><td>Whether to return the indices in <code>output_index</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of structural non-zero elements in the <code>output_*</code> buffers.</dd></dl>
<p>If <code>report_value = true</code>, <code>left.value</code> and <code>right.value</code> and <code>output_value</code> are all guaranteed to be non-NULL. Otherwise, any of these pointers may be NULL and should be ignored.</p>
<p>If <code>report_index = true</code>, <code>output_index</code> is guaranteed to be non-NULL; otherwise, <code>output_index</code> should be ignored. <code>left.index</code> and <code>right.index</code> will always return be non-NULL regardless of <code>report_index</code>. Indices in <code>left.index</code> and <code>right.index</code> are also guaranteed to be in ascending order.</p>
<p>It is expected that the results of the operation are sorted in ascending order, i.e., indices in <code>output_index</code> should be increasing.</p>
<p>The settings of <code>report_index</code> and <code>report_value</code> should not change the number or ordering of the results. That is, <code>output_index</code> should have the same indices regardless of <code>report_value</code>, and <code>output_value</code> should have the same values regardless of <code>report_index</code>. This implies that implementations should not omit structural non-zeros even if the actual value is zero, as the computation of the actual value requires <code>report_value = true</code>. </p>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html#a50916145a69c54a606bd978cf1a2bee4">tatami::DelayedBinaryIsometricArithmeticHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html#ab525b2622f00cf9392a8d87fee36b3f8">tatami::DelayedBinaryIsometricBooleanHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, and <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html#abd741e389477dc1f8ba4196a2535176a">tatami::DelayedBinaryIsometricCompareHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="ac894879c4fb4f6a8a6edb13236468613" name="ac894879c4fb4f6a8a6edb13236468613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac894879c4fb4f6a8a6edb13236468613">&#9670;&#160;</a></span>is_sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">tatami::DelayedBinaryIsometricOperationHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::is_sparse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether this operation preserves sparsity. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html#aa36ab571e1e3f350354e8b0f97e86823">tatami::DelayedBinaryIsometricArithmeticHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html#a7afb53bdf0a10934e2e27d140f847823">tatami::DelayedBinaryIsometricBooleanHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, and <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html#a8b6eee392b4396f529eae93b1d159eb5">tatami::DelayedBinaryIsometricCompareHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a2838a8794fd9ab3b5fdc1d62a25f64eb" name="a2838a8794fd9ab3b5fdc1d62a25f64eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2838a8794fd9ab3b5fdc1d62a25f64eb">&#9670;&#160;</a></span>nrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; Index_ &gt; <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">tatami::DelayedBinaryIsometricOperationHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::nrow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Expected number of rows in the matrix to which this operation is to be applied (i.e., the underlying matrix in the <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code> constructor). If no value is returned, the matrix may have any number of rows. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html#a11c082a13e550afdd10891360a17e43c">tatami::DelayedBinaryIsometricArithmeticHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html#aa0b0d5f6ade7d6864c15853bface0983">tatami::DelayedBinaryIsometricBooleanHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, and <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html#ac0f34c94f718d29cebb7760e1a18a2d3">tatami::DelayedBinaryIsometricCompareHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<a id="a8e10a8b0b2cb9961f7976b7295e3ab71" name="a8e10a8b0b2cb9961f7976b7295e3ab71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e10a8b0b2cb9961f7976b7295e3ab71">&#9670;&#160;</a></span>ncol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_ , typename InputValue_ , typename Index_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; Index_ &gt; <a class="el" href="classtatami_1_1DelayedBinaryIsometricOperationHelper.html">tatami::DelayedBinaryIsometricOperationHelper</a>&lt; OutputValue_, InputValue_, Index_ &gt;::ncol </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Expected number of columns in the matrix to which this operation is to be applied (i.e., the underlying matrix in the <code><a class="el" href="classtatami_1_1DelayedUnaryIsometricOperation.html" title="Delayed isometric operation on a single matrix.">DelayedUnaryIsometricOperation</a></code> constructor). If no value is returned, the matrix may have any number of columns. </dd></dl>

<p>Implemented in <a class="el" href="classtatami_1_1DelayedBinaryIsometricArithmeticHelper.html#ae839440671931f9f8fe63b50a80922c4">tatami::DelayedBinaryIsometricArithmeticHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, <a class="el" href="structtatami_1_1DelayedBinaryIsometricBooleanHelper.html#ae85fd34e94835281e0be47803c0a19a4">tatami::DelayedBinaryIsometricBooleanHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>, and <a class="el" href="structtatami_1_1DelayedBinaryIsometricCompareHelper.html#a00111821f0c280dac35ee9c31f287043">tatami::DelayedBinaryIsometricCompareHelper&lt; op_, OutputValue_, InputValue_, Index_ &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tatami/isometric/binary/<a class="el" href="binary_2helper__interface_8hpp_source.html">helper_interface.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
